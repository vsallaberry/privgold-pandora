--- ./CMakeLists.txt.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./CMakeLists.txt	2023-09-20 16:28:01.812000000 +0200
@@ -66,7 +66,14 @@
 
 IF(NOT WIN32)
     # Wayland support
-    OPTION(FREEGLUT_WAYLAND "Use Wayland (no X11)" OFF)
+    OPTION(FREEGLUT_WAYLAND "Use Wayland" OFF)
+    OPTION(FREEGLUT_X11 "Use X11" ON)
+    OPTION(FREEGLUT_DYNLIB_XKBCOMMON "runtime xkbcommon loading" OFF)
+    OPTION(FREEGLUT_DYNLIB_WAYLAND "runtime wayland loading" OFF)
+    OPTION(FREEGLUT_DYNLIB_EGL "runtime EGL loading" OFF)
+    OPTION(FREEGLUT_DYNLIB_X11 "runtime X11 loading" OFF)
+    OPTION(FREEGLUT_DYNLIB_GL "runtime GL loading" OFF)
+    OPTION(FREEGLUT_DYNLIB_GLES "runtime GLES loading" OFF)
 ENDIF()
 
 
@@ -110,6 +117,7 @@
     src/fg_teapot_data.h
     src/fg_videoresize.c
     src/fg_window.c
+    src/fg_lib_gl.c
 )
 # TODO: OpenGL ES requires a compatible version of these files:
 IF(NOT FREEGLUT_GLES)
@@ -201,13 +209,20 @@
             src/wayland/fg_state_wl.c
             src/wayland/fg_structure_wl.c
             src/wayland/fg_window_wl.c
-            # font, serial port & joystick code are agnostic
-            src/x11/fg_glutfont_definitions_x11.c
-            src/x11/fg_input_devices_x11.c
-            src/x11/fg_joystick_x11.c
+            src/wayland/fg_lib_xkb.c
+            src/wayland/fg_lib_wl.c
         )
+        IF(NOT FREEGLUT_X11)
+            LIST(APPEND FREEGLUT_SRCS
+                # font, serial port & joystick code are agnostic
+                src/x11/fg_glutfont_definitions_x11.c
+                src/x11/fg_input_devices_x11.c
+                src/x11/fg_joystick_x11.c
+            )
+        ENDIF()
+    ENDIF()
     # UNIX (X11)
-    ELSE()
+    IF(FREEGLUT_X11)
         LIST(APPEND FREEGLUT_SRCS
             src/x11/fg_cursor_x11.c
             src/x11/fg_ext_x11.c
@@ -225,6 +240,7 @@
             src/x11/fg_window_x11.c
             src/x11/fg_xinput_x11.c
 	    src/x11/fg_cmap_x11.c
+            src/x11/fg_lib_X.c
         )
         IF(NOT(FREEGLUT_GLES))
             LIST(APPEND FREEGLUT_SRCS
@@ -234,6 +250,7 @@
                 src/x11/fg_state_x11_glx.h
                 src/x11/fg_window_x11_glx.c
                 src/x11/fg_window_x11_glx.h
+                src/x11/fg_lib_glx.c
             )
         ENDIF()
     ENDIF()
@@ -253,29 +270,59 @@
         src/egl/fg_structure_egl.h
         src/egl/fg_window_egl.c
         src/egl/fg_window_egl.h
+        src/egl/fg_lib_egl.c
     )
 ENDIF()
 
+MACRO(fg_find_library _NAME _LIB)
+    IF (EXISTS "${_LIB}")
+        SET(FG_${_NAME}_LIB "${_LIB}")
+    ELSE()
+        find_library("FG_${_NAME}_LIB" NAME ${_LIB} HINTS ${X11_LIB_PATH}) # HINTS <paths>
+    ENDIF()
+    IF(FG_${_NAME}_LIB)
+        get_filename_component(_LIB_REALPATH ${FG_${_NAME}_LIB} REALPATH)  # resolves symlinks
+        get_filename_component(_LIB_BASENAME ${_LIB_REALPATH} NAME)
+        IF(APPLE)
+            STRING(REGEX REPLACE "(\\.[0-9]*)\\.[0-9\\.]*dylib$" "\\1.dylib" _LIB_MAJOR_NAME "${_LIB_BASENAME}")
+        ELSE()
+            STRING(REGEX REPLACE "(\\.[0-9]*)\\.[0-9\\.]*$" "\\1" _LIB_MAJOR_NAME "${_LIB_BASENAME}")
+        ENDIF()
+        SET(FG_${_NAME}_MAJOR_NAME "${_LIB_MAJOR_NAME}")
+    ENDIF()
+ENDMACRO()
+
 INCLUDE(CheckIncludeFiles)
-IF(UNIX AND NOT(ANDROID OR BLACKBERRY OR FREEGLUT_WAYLAND))
+IF(UNIX AND NOT(ANDROID OR BLACKBERRY OR FREEGLUT_WAYLAND) OR FREEGLUT_X11)
     FIND_PACKAGE(X11 REQUIRED)
     INCLUDE_DIRECTORIES(${X11_X11_INCLUDE_PATH})
-    LIST(APPEND LIBS ${X11_X11_LIB})
+    ADD_DEFINITIONS(-DFREEGLUT_X11)
+    LIST(APPEND LIBS_X11 ${X11_X11_LIB})
     IF(X11_Xrandr_FOUND)
         SET(HAVE_X11_EXTENSIONS_XRANDR_H TRUE)
-        LIST(APPEND LIBS ${X11_Xrandr_LIB})
+        LIST(APPEND LIBS_X11 ${X11_Xrandr_LIB})
     ENDIF()
     IF(X11_xf86vmode_FOUND)
         SET(HAVE_X11_EXTENSIONS_XF86VMODE_H TRUE)
-        LIST(APPEND LIBS ${X11_Xxf86vm_LIB})
+        LIST(APPEND LIBS_X11 ${X11_Xxf86vm_LIB})
     ENDIF()
     IF(X11_Xinput_FOUND)
         # Needed for multi-touch:
         CHECK_INCLUDE_FILES("${X11_Xinput_INCLUDE_PATH}/X11/extensions/XInput2.h" HAVE_X11_EXTENSIONS_XINPUT2_H)
-        LIST(APPEND LIBS ${X11_Xinput_LIB})
+        LIST(APPEND LIBS_X11 ${X11_Xinput_LIB})
     ELSE()
         MESSAGE(FATAL_ERROR "Missing X11's XInput2.h (X11/extensions/XInput2.h)")
     ENDIF()
+    IF(NOT FREEGLUT_DYNLIB_X11)
+        LIST(APPEND LIBS ${LIBS_X11})
+    ELSE()
+      SET(FG_LIB_SEP "")
+      FOREACH(FG_LIB_NAME ${LIBS_X11})
+          fg_find_library("${FG_LIB_NAME}" "${FG_LIB_NAME}")
+          STRING(APPEND FG_X_SO_NAME "${FG_LIB_SEP}${FG_${FG_LIB_NAME}_MAJOR_NAME}")
+          SET(FG_LIB_SEP "\",\"")
+      ENDFOREACH()
+    ENDIF()
 ENDIF()
 
 # FreeBSD and NetBSD joystick code uses libusbhid
@@ -299,20 +346,51 @@
     if("${CMAKE_SYSTEM_NAME}" STREQUAL "Darwin")
       # get path where X11 libs are
       get_filename_component(X11_LIB_PATH ${X11_Xi_LIB} DIRECTORY)
-      
+
       find_library(OPENGL_gl_LIBRARY NAME GL HINTS ${X11_LIB_PATH})
       find_library(OPENGL_glu_LIBRARY NAME GLU HINTS ${X11_LIB_PATH})
     endif()
 
     FIND_PACKAGE(OpenGL REQUIRED)
-    LIST(APPEND LIBS ${OPENGL_gl_LIBRARY})
+    IF(NOT FREEGLUT_DYNLIB_GL)
+        LIST(APPEND LIBS ${OPENGL_gl_LIBRARY})
+    ELSE()
+        fg_find_library("GL" "${OPENGL_gl_LIBRARY}")
+        SET(FG_GL_SO_NAME ${FG_GL_MAJOR_NAME})
+        IF(FREEGLUT_X11)
+            SET(FG_GLX_SO_NAME ${FG_GL_SO_NAME})
+        ENDIF()
+        LIST(APPEND FG_DEMOS_CPPFLAGS -DFG_GL_SO_NAME -include fg_lib_defs_gl.h)
+        #STRING(APPEND FG_DEMOS_CPPFLAGS "-include;config.h;-include;fg_lib_defs_gl.h")
+    ENDIF()
     INCLUDE_DIRECTORIES(${OPENGL_INCLUDE_DIR})
 ENDIF()
 
 # For Wayland: compile with -DFREEGLUT_WAYLAND and pull EGL
 IF(FREEGLUT_WAYLAND)
   ADD_DEFINITIONS(-DFREEGLUT_WAYLAND)
-  LIST(APPEND LIBS wayland-client wayland-cursor wayland-egl EGL xkbcommon)
+  IF(NOT FREEGLUT_DYNLIB_WAYLAND)
+      LIST(APPEND LIBS wayland-client wayland-cursor wayland-egl)
+  ELSE()
+      SET(FG_LIB_SEP "")
+      FOREACH(FG_LIB_NAME wayland-client wayland-cursor wayland-egl)
+          fg_find_library("${FG_LIB_NAME}" "${FG_LIB_NAME}")
+          STRING(APPEND FG_WL_SO_NAME "${FG_LIB_SEP}${FG_${FG_LIB_NAME}_MAJOR_NAME}")
+          SET(FG_LIB_SEP "\",\"")
+      ENDFOREACH()
+  ENDIF()
+  IF(NOT FREEGLUT_DYNLIB_EGL)
+      LIST(APPEND LIBS EGL)
+  ELSE()
+      fg_find_library("EGL" "EGL")
+      SET(FG_EGL_SO_NAME ${FG_EGL_MAJOR_NAME})
+  ENDIF()
+  IF(NOT FREEGLUT_DYNLIB_XKBCOMMON)
+     LIST(APPEND LIBS xkbcommon)
+  ELSE()
+      fg_find_library(XKB xkbcommon)
+      SET(FG_XKB_SO_NAME ${FG_XKB_MAJOR_NAME})
+  ENDIF()
 ENDIF()
 
 # lib m for math, not needed on windows
@@ -329,7 +407,7 @@
     IF(MSVC)
         SET( CMAKE_DEBUG_POSTFIX "d" )
     ENDIF(MSVC)
-    
+
     IF(NOT(MSVC_VERSION LESS "1600"))
     # minimum requirement for WM_TOUCH device
         ADD_DEFINITIONS(-D_WIN32_WINNT=0x0601)
@@ -501,6 +579,10 @@
         ENDIF()
     ENDIF()
 ENDIF()
+IF(FREEGLUT_DYNLIB_WAYLAND OR FREEGLUT_DYNLIB_X11 OR FREEGLUT_DYNLIB_EGL OR FREEGLUT_DYNLIB_GL OR FREEGLUT_DYNLIB_XKBCOMMON)
+    find_library(FG_LIB_DL NAME dl HINTS ${X11_LIB_PATH})
+    LIST(APPEND LIBS ${FG_LIB_DL})
+ENDIF()
 IF(FREEGLUT_BUILD_SHARED_LIBS)
     TARGET_LINK_LIBRARIES(freeglut ${LIBS})
     TARGET_COMPILE_DEFINITIONS(freeglut PUBLIC ${PUBLIC_DEFINITIONS})
@@ -547,7 +629,8 @@
 # Optionally build demos, on by default.
 option( FREEGLUT_BUILD_DEMOS "Build FreeGLUT demos." ON )
 
-SET(DEMO_LIBS ${OPENGL_glu_LIBRARY} ${LIBS})
+#SET(DEMO_LIBS ${OPENGL_glu_LIBRARY} ${LIBS})
+SET(DEMO_LIBS ${OPENGL_glu_LIBRARY} ${OPENGL_gl_LIBRARY} ${LIBS})
 # lib m for math, not needed on windows
 IF (NOT WIN32)
     LIST(APPEND DEMO_LIBS m)
@@ -557,6 +640,8 @@
     IF( FREEGLUT_BUILD_DEMOS )
         IF(FREEGLUT_BUILD_SHARED_LIBS)
             ADD_EXECUTABLE(${name} ${ARGN})
+            Message("${FG_DEMOS_CPPFLAGS}")
+            target_compile_options(${name} PUBLIC ${FG_DEMOS_CPPFLAGS})
             TARGET_LINK_LIBRARIES(${name} ${DEMO_LIBS} freeglut)
             IF(WIN32 AND MSVC)
                 SET_TARGET_PROPERTIES(${name} PROPERTIES DEBUG_POSTFIX d)
@@ -564,6 +649,7 @@
         ENDIF()
         IF(FREEGLUT_BUILD_STATIC_LIBS)
             ADD_EXECUTABLE(${name}_static ${ARGN})
+            target_compile_options(${name}_static PUBLIC ${FG_DEMOS_CPPFLAGS})
             TARGET_LINK_LIBRARIES(${name}_static ${DEMO_LIBS} freeglut_static)
             IF(WIN32 AND MSVC)
                 SET_TARGET_PROPERTIES(${name}_static PROPERTIES DEBUG_POSTFIX d)
@@ -603,6 +689,7 @@
 
 # pkg-config support, to install at $(libdir)/pkgconfig
 # Define static build dependencies
+UNSET(PC_LIBS_PRIVATE)
 IF(WIN32)
   SET(PC_LIBS_PRIVATE "-lopengl32 -lwinmm -lgdi32")
 ELSEIF(FREEGLUT_GLES)
@@ -615,13 +702,35 @@
       SET(PC_LIBS_PRIVATE "-lbps -lslog2 -lscreen -lGLESv2 -lGLESv1_CM -lEGL -lm")
     ENDIF()
   ELSEIF(FREEGLUT_WAYLAND)
-    SET(PC_LIBS_PRIVATE "-lwayland-client -lwayland-cursor -lwayland-egl -lGLESv2 -lGLESv1_CM -lEGL -lxkbcommon -lm")
+    IF (NOT FREEGLUT_DYNLIB_WAYLAND)
+        STRING(APPEND PC_LIBS_PRIVATE " -lwayland-client -lwayland-cursor -lwayland-egl")
+    ENDIF()
+    IF(NOT FREEGLUT_DYNLIB_EGL)
+        STRING(APPEND PC_LIBS_PRIVATE " -lGLESv2 -lGLESv1_CM -lEGL")
+    ENDIF()
+    IF(NOT FREEGLUT_DYNLIB_XKBCOMMON)
+        STRING(APPEND PC_LIBS_PRIVATE " -lxkbcommon")
+    ELSE()
+        SET(FG_XKB_SO_NAME "\"libxkbcommon.so.0\"")
+    ENDIF()
+    STRING(APPEND PC_LIBS_PRIVATE " -lm")
   ELSE()
     SET(PC_LIBS_PRIVATE "-lX11 -lXxf86vm -lXrandr -lGLESv2 -lGLESv1_CM -lEGL -lm")
   ENDIF()
 ELSE()
   IF(FREEGLUT_WAYLAND)
-    SET(PC_LIBS_PRIVATE "-lwayland-client -lwayland-cursor -lwayland-egl -lGL -lxkbcommon -lm")
+    IF (NOT FREEGLUT_DYNLIB_WAYLAND)
+        STRING(APPEND PC_LIBS_PRIVATE " -lwayland-client -lwayland-cursor -lwayland-egl")
+    ENDIF()
+    IF(NOT FREEGLUT_DYNLIB_EGL)
+        STRING(APPEND PC_LIBS_PRIVATE " -lGL")
+    ENDIF()
+    IF(NOT FREEGLUT_DYNLIB_XKBCOMMON)
+        STRING(APPEND PC_LIBS_PRIVATE " -lxkbcommon")
+    ELSE()
+        SET(FG_XKB_SO_NAME "\"libxkbcommon.so.0\"")
+    ENDIF()
+    STRING(APPEND PC_LIBS_PRIVATE " -lm")
   ELSE()
     SET(PC_LIBS_PRIVATE "-lX11 -lXxf86vm -lXrandr -lGL -lm")
   ENDIF()
@@ -670,3 +779,18 @@
     DESTINATION ${ConfigPackageLocation}
     COMPONENT Devel
 )
+
+MESSAGE("FREEGLUT ${VERSION}")
+MESSAGE("FREEGLUT_BUILD_SHARED_LIBS " ${FREEGLUT_BUILD_SHARED_LIBS})
+MESSAGE("FREEGLUT_BUILD_STATIC_LIBS " ${FREEGLUT_BUILD_STATIC_LIBS})
+MESSAGE("FREEGLUT_X11               " ${FREEGLUT_X11})
+MESSAGE("FREEGLUT_WAYLAND           " ${FREEGLUT_WAYLAND})
+MESSAGE("FREEGLUT_GLES              " ${FREEGLUT_GLES})
+MESSAGE("FREEGLUT_DYNLIB_WAYLAND    " ${FREEGLUT_DYNLIB_WAYLAND})
+MESSAGE("FREEGLUT_DYNLIB_XKB_COMMON " ${FREEGLUT_DYNLIB_XKBCOMMON})
+MESSAGE("FREEGLUT_DYNLIB_X11        " ${FREEGLUT_DYNLIB_X11})
+MESSAGE("FREEGLUT_DYNLIB_GL         " ${FREEGLUT_DYNLIB_GL})
+MESSAGE("FREEGLUT_DYNLIB_EGL        " ${FREEGLUT_DYNLIB_EGL})
+MESSAGE("FREEGLUT_DYNLIB_GLES       " ${FREEGLUT_DYNLIB_GLES})
+MESSAGE("FREEGLUT_BUILD_DEMOS       " ${FREEGLUT_BUILD_DEMOS})
+
--- ./config.h.in.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./config.h.in	2023-09-20 16:01:02.756000000 +0200
@@ -22,3 +22,13 @@
 /* warning and errors printed? */
 #cmakedefine FREEGLUT_PRINT_WARNINGS
 #cmakedefine FREEGLUT_PRINT_ERRORS
+
+/* dyn lib loading */
+#cmakedefine FG_XKB_SO_NAME     "${FG_XKB_SO_NAME}"
+#cmakedefine FG_WL_SO_NAME      "${FG_WL_SO_NAME}"
+#cmakedefine FG_EGL_SO_NAME     "${FG_EGL_SO_NAME}"
+#cmakedefine FG_X_SO_NAME       "${FG_X_SO_NAME}"
+#cmakedefine FG_GL_SO_NAME      "${FG_GL_SO_NAME}"
+#cmakedefine FG_GLX_SO_NAME     ""
+#cmakedefine FG_GLES_SO_NAME    "${FG_GLES_SO_NAME}"
+
--- ./lib.sh.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./lib.sh	2023-09-20 18:40:15.660000000 +0200
@@ -0,0 +1,329 @@
+#!/bin/bash
+mydir=$(cd "$(dirname "$0")"; pwd)
+
+source=
+header=
+defines=
+gen_all=
+prefix="wl_"
+gen_prefix=
+includedirs="/usr/include"
+CPP=clang
+srcdir=${mydir}/src
+#so=${mydir}/build_/lib/libglut.so
+so="${mydir}/libglut.so.3"
+fun_excludes="^$"
+fun_excludes="(^glut.*|^glX)"
+sym_prefix="fg_"
+
+show_help() {
+    echo "$(basename "$0") [-h] [-C|--source] [-H|--header] [-D|--defines]"
+    echo "    [-P|--lib-prefix <lib_prefix>] [-S|--sym-prefix <sym_prefix>] [-G|--gen-all]"
+    echo "    [-X|--excludes <excludes_egrep>] [-L|--bin-ref <ref-bin>]"
+    echo "    [-I|--includedirs <dirs>] "
+    echo "    [func_prefix]"
+    exit $?
+}
+while test $# -gt 0; do
+    case "$1" in
+        -h|--help) show_help 0;;
+        -C|--source) source=yes;;
+        -H|--header) header=yes;;
+        -D|--defines) defines=yes;;
+        -P|--lib-prefix) test -n "$2" || { echo "missing lib-prefix argument for '$1'"; show_help 2; }
+                         shift; gen_prefix=$1;;
+        -S|--sym-prefix) test -n "$2" || { echo "missing sym-prefix argument for '$1'"; show_help 2; }
+                         shift; sym_prefix=$1;;
+        -G|--gen-all) gen_all=yes;;
+        -X|--excludes) test -n "$2" || { echo "missing exclude argument for '$1'"; show_help 3; }
+                       shift; fun_excludes=$1;;
+        -L|--bin-ref) test -n "$2" || { echo "missing lib-ref argument for '$1'"; show_help 4; }
+                       shift; so=$1;;
+        -I|--includedirs) test -n "$2" || { echo "missing include-dirs argument for '$1'"; show_help 5; }
+                          shift; includedirs=$1;;
+        -*) show_help 1;;
+        *) prefix=$1;;
+    esac
+    shift
+done
+test -n "${source}${header}${defines}" || { source=yes; header=yes; defines=yes; }
+
+get_funs_old() {
+    grep "${prefix}.*(" -rI "${mydir}/src" \
+        | sed -ne "s/.*[^_a-zA-Z]\(${prefix}[^[:space:]]*[[:space:]]*\)(.*/\1/p" \
+        | sort | uniq
+}
+get_funs() {
+    objdump -h -S "${so}" | sed -ne "s/.*<\(${prefix}[^@>+]*\)[@>+].*/\1/p" \
+        | grep -Ev "${fun_excludes}" \
+        | sort | uniq
+}
+
+funs=$(get_funs)
+
+test -n "${gen_prefix}" && cleanprefix=${gen_prefix} || cleanprefix=${prefix}
+cleanprefix=$(echo "${cleanprefix}" | tr '[A-Z]' '[a-z]')
+cleanprefix=${cleanprefix#_}
+cleanprefix=${cleanprefix%_}
+capcleanprefix=$(echo "${cleanprefix}" | tr '[a-z]' '[A-Z]' || echo "${cleanprefix}")
+capsym_prefix=$(echo "${sym_prefix}" | tr '[a-z]' '[A-Z]' || echo "${sym_prefix}")
+HEADER_NAME="${sym_prefix}lib_syms_${cleanprefix}.h"
+HEADER_DEFINE="FREEGLUT_LIB_SYMS_${capcleanprefix}_H"
+DEF_HEADER_NAME="${sym_prefix}lib_defs_${cleanprefix}.h"
+DEF_HEADER_DEFINE="FREEGLUT_LIB_DEFS_${capcleanprefix}_H"
+SOURCE_NAME="${sym_prefix}lib_${cleanprefix}.c"
+
+LIB_CTX="${sym_prefix}${cleanprefix}_lib"
+LIB_SO_NAME="${capsym_prefix}${capcleanprefix}_SO_NAME"
+FUN_PREFIX="${sym_prefix}"
+LIB_INIT_FUN="${sym_prefix}${cleanprefix}_lib_init"
+LIB_FREE_FUN="${sym_prefix}${cleanprefix}_lib_destroy"
+LIB_FIND_FUN="${sym_prefix}${cleanprefix}_lib_findsymbol"
+LIB_DLOPEN_FUN="${sym_prefix}${cleanprefix}_dlopen"
+CONFIGH="config.h"
+HEADER_print_header() {
+    printf -- "%s\n"                            \
+        "#define FREEGLUT_BUILDING_LIB"         \
+        "#include <GL/freeglut.h>"              \
+        "#include \"fg_internal.h\""
+}
+
+get_proto() {
+    local fun=$1 dbg=0
+
+    grep "${fun}" -rI ${includedirs} | awk -F ':' '{ print $1 }' | sort | uniq \
+    | xargs "${CPP}" -E \
+    | awk 'BEGIN { dbglvl='"${dbg}"'; scope=0; ignore=0; pref=""; proto="" }            \
+           function debug(lvl,str) { if (dbglvl >= lvl) print str > "/dev/stderr"; }    \
+           // { gsub(/\t/, " "); sub(/^[[:space:]]*/, "");                              \
+                slashslash=0; sub(/^extern /, ""); sub(/[[:space:]]extern /, " "); }    \
+           /^[[:space:]]*#/ { slashslash=1; }                                           \
+           /{/ { if (!slashslash) scope++; }                                            \
+           /}/ { if (!slashslash) { scope--; sub(/.*}/, ""); } }                        \
+           // { if (!scope && !ignore && !slashslash) {                                 \
+                    if (($0 ~ /^[^#\/{]*[^a-zA-Z_0-9]'"${fun}"'[[:space:]]*[;(]/)       \
+                    ||  ($0 ~ /^'"${fun}"'[[:space:]]*[;(]/)) {                         \
+                      debug(1, "FUN " pref "/ " $0); proto=pref " " $0; pref="";        \
+                    } else if (proto != "") proto=proto" " $0; else pref=pref " " $0;   \
+                }; }                                                                    \
+           /[;}]/ { if (!scope && !ignore && !slashslash) {                             \
+                    pref=""; if (proto != "" && !( (" " proto) ~ / static /))           \
+                        print proto; proto=""; };                                       \
+           }' \
+    | sort | uniq
+}
+
+## HEADER FILE
+gen_header() {
+    printf -- "%s\n"                                                \
+        "/* GENERATED FILE: ${HEADER_NAME} */"                      \
+        "#ifndef ${HEADER_DEFINE}"                                  \
+        "#define ${HEADER_DEFINE}"                                  \
+        ""
+    test -n "${CONFIGH}"                                            \
+        && printf -- "%s\n" "#include \"${CONFIGH}\""
+
+    printf -- "%s\n"                                                \
+        "#ifndef ${LIB_SO_NAME}"                                    \
+        "int ${LIB_INIT_FUN}();"                                    \
+        "void ${LIB_FREE_FUN}();"                                   \
+        "#else" ""
+
+    HEADER_print_header
+
+    printf -- "%s\n" ""
+
+    for f in $funs; do
+        proto=$(get_proto "${f}")
+        if test -z "${proto}"; then
+            echo "//!! NOT FOUND: $f"
+            funs=$(echo " ${funs} " | tr '[\t\n]' ' ' | sed -e "s/ ${f} / /g")
+        else
+            proto=$(echo "${proto}" | sed -e 's/__attribute__((.*))//')
+            if echo "${proto}" | grep -Eq ^'[^(]*$'; then
+                args=";"
+                type=$(echo "${proto}" | sed -e "s/^\(.*\)[[:space:]]${f}[^[:space:];]*[[:space:];].*/\1/")
+                name="* ${FUN_PREFIX}${f}_fun"
+            else
+                type=$(echo "${proto}" | sed -e "s/^\(.*\)[[:space:]]${f}[^[:space:](]*[[:space:](].*/\1/")
+                args=$(echo "${proto}" | sed -e "s/^.*[[:space:]]${f}[^[:space:](]*\([[:space:](].*\)/\1/")
+                name="(*${FUN_PREFIX}${f}_fun)"
+            fi
+            printf -- "%-24s ${name}${args}\n" "typedef ${type}"
+        fi
+    done
+    printf -- "%s\n" ""
+
+    printf -- "%s\n" "" "#ifdef __cplusplus"                        \
+        "extern \"C\" {"                                            \
+        "#endif" ""
+
+    for f in $funs; do
+        printf "extern %-37s%s;\n" "${FUN_PREFIX}${f}_fun " "${FUN_PREFIX}${f}"
+    done
+
+    printf -- "%s\n" ""                                             \
+        "int     ${LIB_INIT_FUN}();"                                \
+        "void    ${LIB_FREE_FUN}();"                                \
+        "void *  ${LIB_FIND_FUN}(const char * name);"               \
+        "" "#ifdef __cplusplus"                                     \
+        "}"                                                         \
+        "#endif"                                                    \
+        "" "#endif /* ! ifdef ${LIB_SO_NAME} */"                    \
+        "#endif /* ! ifdef ${HEADER_DEFINE} */"
+}
+
+## DEFINES HEADER FILE
+gen_defines() {
+    printf -- "%s\n"                                                \
+        "/* GENERATED FILE: ${DEF_HEADER_NAME} */"                  \
+        "#ifndef ${DEF_HEADER_DEFINE}"                              \
+        "#define ${DEF_HEADER_DEFINE}"                              \
+        ""                                                          \
+        "#ifndef ${LIB_SO_NAME}"
+
+    printf -- "%s\n"                                                \
+        "#else" ""
+
+    for f in $funs; do
+        printf "#define %-36s (*${FUN_PREFIX}${f})\n" "${f}"
+    done
+
+    printf -- "%s\n"                                                \
+        "" "#endif /* ! ifndef ${LIB_SO_NAME} */"                   \
+        "#endif /* ! ifndef ${DEF_HEADER_DEFINE} */"
+}
+
+## C FILE
+gen_source() {
+    printf -- "%s\n" \
+        "/* GENERATED FILE: ${SOURCE_NAME} */"                      \
+        "#include \"${HEADER_NAME}\""                               \
+        ""                                                          \
+        "#ifndef ${LIB_SO_NAME}"                                    \
+        "int  ${LIB_INIT_FUN}() { return 0; }"                      \
+        "void ${LIB_FREE_FUN}() { }"                                \
+        "#else" "" "#include <dlfcn.h>" "#include <stdlib.h>"       \
+        "#include <ctype.h>" "#include <string.h>" ""
+
+    for f in $funs; do
+        printf "%-40s%s = NULL;\n" "${FUN_PREFIX}${f}_fun " "${FUN_PREFIX}${f}"
+    done
+
+    printf -- "%s\n" \
+        "" "static const char * ${LIB_CTX}_names[] = {"             \
+        "    ${LIB_SO_NAME}, NULL"                                  \
+        "};"                                                        \
+        "static void * ${LIB_CTX}[sizeof(${LIB_CTX}_names)/sizeof(*${LIB_CTX}_names)] = { NULL, };" \
+        ""                                                          \
+        "static void * ${LIB_DLOPEN_FUN}(const char * name, int flags) {" \
+        "    void * lib;"                                           \
+        "    if ((lib = dlopen(name, flags)) == NULL) {"            \
+        "        size_t len = strlen(name);"                        \
+        "        char * path = len ? strdup(name) : NULL;"          \
+        "        const char * ext;"                                 \
+        "        if (!path) return NULL;"                           \
+        "        if (len > 3 && !strcasecmp((ext = name + len - 3), \".so\"))" \
+        "            len -= 3;"                                     \
+        "        else if (len > 6 && !strcasecmp((ext = name + len - 6), \".dylib\"))" \
+        "            len -= 6;"                                     \
+        "        else"                                              \
+        "            ext = NULL;"                                   \
+        "        while (len > 0 && (isdigit(path[len-1]) || path[len-1] == '.' || (ext && path[len-1] == '-')))" \
+        "            --len; /* loop */"                             \
+        "        while (ext && isdigit(path[len])) ++len;"          \
+        "        path[len] = 0;"                                    \
+        "        if (ext != NULL)"                                  \
+        "            strcpy(path + len, ext);"                      \
+        "        lib = dlopen(path, flags);"                        \
+        "        free(path);"                                       \
+        "    }"                                                     \
+        "    return lib;"                                           \
+        "}" ""                                                      \
+        "void * ${LIB_FIND_FUN}(const char * name) {"               \
+        "    void * sym;"                                           \
+        "    for (void ** lib = ${LIB_CTX}; *lib != NULL; ++lib) {" \
+        "        if ((sym = dlsym(*lib, name)) != NULL)"            \
+        "            return sym;"                                   \
+        "    }"                                                     \
+        "    return NULL;"                                          \
+        "}" ""                                                      \
+        "int ${LIB_INIT_FUN}() {"                                   \
+        "    int ret = 0, i = 0;"                                   \
+        "    if (*${LIB_CTX} != NULL)"                              \
+        "        return 0;"                                         \
+        "    for (const char ** name = ${LIB_CTX}_names; *name != NULL; ++name, ++i) {" \
+        "        if (**name == 0) { --i; continue; }"               \
+        "        if ((${LIB_CTX}[i] = ${LIB_DLOPEN_FUN}(*name, RTLD_LOCAL|RTLD_NOW)) == NULL) {" \
+        "            return -1;"                                    \
+        "        }"                                                 \
+        "    }"                                                     \
+        "    ${LIB_CTX}[i] = NULL;"
+    for f in $funs; do
+        printf -- "%s\n" \
+            "    if ((${FUN_PREFIX}${f} = ${LIB_FIND_FUN}(\"${f}\")) == NULL && ++ret)" \
+            "        fgWarning(\"cannot load symbol %s\", \"${f}\");"
+    done
+    printf -- "%s\n"                                                \
+        "    return ret;"                                           \
+        "}"
+
+    printf -- "%s\n"                                                \
+        "" "void ${LIB_FREE_FUN}() {"                               \
+        "    if (*${LIB_CTX} == NULL)"                              \
+        "        return ;"                                          \
+        "    for (void ** lib = ${LIB_CTX}; *lib; ++lib) {"         \
+        "        dlclose(*lib);"                                    \
+        "        *lib = NULL;"                                      \
+        "    }"
+    for f in $funs; do
+        printf -- "%s\n" \
+            "    ${FUN_PREFIX}${f} = NULL;"
+    done
+    printf -- "%s\n"                                                \
+        "    return ;"                                              \
+        "}"
+
+    printf -- "%s\n"                                                \
+        ""                                                          \
+        "#endif /* ! ifdef ${LIB_SO_NAME} */"
+}
+
+if test -n "${gen_all}"; then
+
+    echo "not implemented"
+
+    if false; then
+        for f in wl xkb; do
+            ./lib.sh -C $f > src/wayland/${sym_prefix}lib_$f.c \
+                && ./lib.sh -D $f > src/wayland/${sym_prefix}lib_defs_$f.h \
+                && ./lib.sh -H $f > src/wayland/${sym_prefix}lib_syms_$f.h
+        done \
+            && f=egl && ./lib.sh -C "$f" > "src/egl/${sym_prefix}lib_$f.c" \
+            && ./lib.sh -D "$f" > "src/egl/${sym_prefix}lib_defs_$f.h" \
+            && ./lib.sh -H "$f" > "src/egl/${sym_prefix}lib_syms_$f.h" \
+            && f=x11 && ./lib.sh -C -P "$f" X > "src/x11/${sym_prefix}lib_$f.c" \
+            && ./lib.sh -D $f -P "$f" > "src/x11/${sym_prefix}lib_defs_$f.h" \
+            && ./lib.sh -H $f -P "$f" > "src/x11/${sym_prefix}lib_syms_$f.h" \
+            && f=gl && ./lib.sh gl --excludes '^glut' -H -P "$f" > "src/${sym_prefix}lib_syms_$f.h" \
+            && ./lib.sh gl --excludes '^glut' -H -P "$f" > "src/${sym_prefix}lib_syms_$f.h" \
+            && ./lib.sh gl --excludes '^glut' -H -P "$f" > "src/${sym_prefix}lib_syms_$f.h" \
+            && ./lib.sh glX --excludes '^glut' -D > src/x11/${sym_prefix}lib_defs_glx.h \
+            && ./lib.sh glX --excludes '^glut' -H > src/x11/${sym_prefix}lib_syms_glx.h \
+            && ./lib.sh glX --excludes '^glut' -C > src/x11/${sym_prefix}lib_glx.c
+    fi
+
+else
+
+    if test -n "${header}"; then
+        gen_header && printf -- "\n"
+    else
+        # need to generates funs and prototypes
+        gen_header > /dev/null 2>&1
+    fi
+
+    test -z "${defines}"    || { gen_defines && printf -- "\n"; }
+
+    test -z "${source}"     || { gen_source && printf -- "\n"; }
+
+fi
--- ./src/egl/fg_display_egl.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/egl/fg_display_egl.c	2023-09-17 18:03:31.987009998 +0200
@@ -26,8 +26,8 @@
 #include <GL/freeglut.h>
 #include "fg_internal.h"
 
-void fgPlatformGlutSwapBuffers( SFG_PlatformDisplay *pDisplayPtr, SFG_Window* CurrentWindow )
+void fgPlatformGlutSwapBuffers_EGL( SFG_Display * DisplayPtr, SFG_Window* CurrentWindow )
 {
-  if (!eglSwapBuffers(pDisplayPtr->egl.Display, CurrentWindow->Window.pContext.egl.Surface))
+  if (!eglSwapBuffers(fgDisplay.egl.Display, CurrentWindow->Window.eglContext.Surface))
     fgError("eglSwapBuffers: error %x\n", eglGetError());
 }
--- ./src/egl/fg_ext_egl.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/egl/fg_ext_egl.c	2023-09-17 22:00:45.496208000 +0200
@@ -26,7 +26,7 @@
 #include <GL/freeglut.h>
 #include "../fg_internal.h"
 
-SFG_Proc fgPlatformGetProcAddress( const char *procName )
+SFG_Proc fgPlatformGetProcAddress_EGL( const char *procName )
 {
     return (SFG_Proc)eglGetProcAddress(procName);
 }
--- ./src/egl/fg_init_egl.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/egl/fg_init_egl.c	2023-09-19 18:32:07.968201433 +0200
@@ -26,27 +26,30 @@
 #define FREEGLUT_BUILDING_LIB
 #include <GL/freeglut.h>
 #include "fg_internal.h"
+#include "fg_lib_syms_egl.h"
 
 /*
  * A call to this function should initialize all the display stuff...
  */
-void fghPlatformInitializeEGL()
+int fghPlatformInitializeEGL(EGLNativeDisplayType nativeDisplay)
 {
+  if (fg_egl_lib_init() != 0) {
+    fgWarning( "cannot load EGL library" );
+    return -1;
+  }
+
   /* CreateDisplay */
   /* Using EGL_DEFAULT_DISPLAY, or a specific native display */
-#ifdef FREEGLUT_WAYLAND
-  fgDisplay.pDisplay.egl.Display = eglGetDisplay(
-              (EGLNativeDisplayType)fgDisplay.pDisplay.display);
-#else
-  EGLNativeDisplayType nativeDisplay = EGL_DEFAULT_DISPLAY;
-  fgDisplay.pDisplay.egl.Display = eglGetDisplay(nativeDisplay);
-#endif
-
-  FREEGLUT_INTERNAL_ERROR_EXIT(fgDisplay.pDisplay.egl.Display != EGL_NO_DISPLAY,
-			       "No display available", "fgPlatformInitialize");
-  if (eglInitialize(fgDisplay.pDisplay.egl.Display, &fgDisplay.pDisplay.egl.MajorVersion, &fgDisplay.pDisplay.egl.MinorVersion) != EGL_TRUE)
-    fgError("eglInitialize: error %x\n", eglGetError());
+  fgDisplay.egl.Display = eglGetDisplay(nativeDisplay);
 
+  if (fgDisplay.egl.Display == EGL_NO_DISPLAY) {
+      fgWarning("fghPlatformInitializeEGL: No display available");
+      return -1;
+  }
+  if (eglInitialize(fgDisplay.egl.Display, &fgDisplay.egl.MajorVersion, &fgDisplay.egl.MinorVersion) != EGL_TRUE) {
+    fgWarning("eglInitialize: error %x\n", eglGetError());
+    return -1;
+  }
 # ifdef GL_VERSION_1_1  /* or later */
   eglBindAPI(EGL_OPENGL_API);
 # else
@@ -57,23 +60,25 @@
   /* fgDisplay.ScreenHeight = ...; */
   /* fgDisplay.ScreenWidthMM = ...; */
   /* fgDisplay.ScreenHeightMM = ...; */
+  return 0;
 }
 
 void fghPlatformCloseDisplayEGL()
 {
-  if (fgDisplay.pDisplay.egl.Display != EGL_NO_DISPLAY) {
-    eglTerminate(fgDisplay.pDisplay.egl.Display);
-    fgDisplay.pDisplay.egl.Display = EGL_NO_DISPLAY;
-    fgDisplay.pDisplay.egl.MajorVersion = 0;
-    fgDisplay.pDisplay.egl.MinorVersion = 0;
+  if (fgDisplay.egl.Display != EGL_NO_DISPLAY) {
+    eglTerminate(fgDisplay.egl.Display);
+    fgDisplay.egl.Display = EGL_NO_DISPLAY;
+    fgDisplay.egl.MajorVersion = 0;
+    fgDisplay.egl.MinorVersion = 0;
   }
 }
 
 /**
  * Destroy a menu context
  */
-void fgPlatformDestroyContext ( SFG_PlatformDisplay pDisplay, SFG_WindowContextType MContext )
+void fgPlatformDestroyContext_EGL ( SFG_Display * Display, SFG_WindowContextType Context )
 {
-  if (MContext != EGL_NO_CONTEXT)
-    eglDestroyContext(pDisplay.egl.Display, MContext);
+  if (Context.Context_EGL != EGL_NO_CONTEXT)
+    eglDestroyContext(fgDisplay.egl.Display, Context.Context_EGL);
 }
+
--- ./src/egl/fg_init_egl.h.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/egl/fg_init_egl.h	2023-09-17 18:07:43.888898008 +0200
@@ -26,8 +26,8 @@
 #ifndef __FG_INIT_EGL_H__
 #define __FG_INIT_EGL_H__
 
-extern void fghPlatformInitializeEGL();
+extern int fghPlatformInitializeEGL(EGLNativeDisplayType nativeDisplay);
 extern void fghPlatformCloseDisplayEGL();
-extern void fgPlatformDestroyContext();
+extern void fgPlatformDestroyContext_EGL();
 
 #endif
--- ./src/egl/fg_internal_egl.h.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/egl/fg_internal_egl.h	2023-09-17 18:40:34.517720007 +0200
@@ -44,9 +44,9 @@
  * Make "freeglut" window handle and context types so that we don't need so
  * much conditionally-compiled code later in the library.
  */
-typedef EGLNativeWindowType SFG_WindowHandleType;
-typedef EGLContext SFG_WindowContextType;
-typedef int SFG_WindowColormapType;		/* dummy */
+typedef EGLNativeWindowType SFG_WindowHandleType_EGL;
+typedef EGLContext SFG_WindowContextType_EGL;
+typedef int SFG_WindowColormapType_EGL;		/* dummy */
 struct tagSFG_PlatformContextEGL
 {
   EGLSurface          Surface;
--- ./src/egl/fg_lib_defs_egl.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./src/egl/fg_lib_defs_egl.h	2023-09-19 21:19:33.632523423 +0200
@@ -0,0 +1,26 @@
+/* GENERATED FILE: fg_lib_defs_egl.h */
+#ifndef FREEGLUT_LIB_DEFS_EGL_H
+#define FREEGLUT_LIB_DEFS_EGL_H
+
+#ifndef FG_EGL_SO_NAME
+#else
+
+#define eglBindAPI                           (*fg_eglBindAPI)
+#define eglChooseConfig                      (*fg_eglChooseConfig)
+#define eglCreateContext                     (*fg_eglCreateContext)
+#define eglCreateWindowSurface               (*fg_eglCreateWindowSurface)
+#define eglDestroyContext                    (*fg_eglDestroyContext)
+#define eglDestroySurface                    (*fg_eglDestroySurface)
+#define eglGetConfigAttrib                   (*fg_eglGetConfigAttrib)
+#define eglGetDisplay                        (*fg_eglGetDisplay)
+#define eglGetError                          (*fg_eglGetError)
+#define eglGetProcAddress                    (*fg_eglGetProcAddress)
+#define eglInitialize                        (*fg_eglInitialize)
+#define eglMakeCurrent                       (*fg_eglMakeCurrent)
+#define eglQueryContext                      (*fg_eglQueryContext)
+#define eglSwapBuffers                       (*fg_eglSwapBuffers)
+#define eglTerminate                         (*fg_eglTerminate)
+
+#endif /* ! ifndef FG_EGL_SO_NAME */
+#endif /* ! ifndef FREEGLUT_LIB_DEFS_EGL_H */
+
--- ./src/egl/fg_lib_egl.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./src/egl/fg_lib_egl.c	2023-09-20 17:26:13.668000000 +0200
@@ -0,0 +1,139 @@
+/* GENERATED FILE: fg_lib_egl.c */
+#include "fg_lib_syms_egl.h"
+
+#ifndef FG_EGL_SO_NAME
+int  fg_egl_lib_init() { return 0; }
+void fg_egl_lib_destroy() { }
+#else
+
+#include <dlfcn.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+fg_eglBindAPI_fun                       fg_eglBindAPI = NULL;
+fg_eglChooseConfig_fun                  fg_eglChooseConfig = NULL;
+fg_eglCreateContext_fun                 fg_eglCreateContext = NULL;
+fg_eglCreateWindowSurface_fun           fg_eglCreateWindowSurface = NULL;
+fg_eglDestroyContext_fun                fg_eglDestroyContext = NULL;
+fg_eglDestroySurface_fun                fg_eglDestroySurface = NULL;
+fg_eglGetConfigAttrib_fun               fg_eglGetConfigAttrib = NULL;
+fg_eglGetDisplay_fun                    fg_eglGetDisplay = NULL;
+fg_eglGetError_fun                      fg_eglGetError = NULL;
+fg_eglGetProcAddress_fun                fg_eglGetProcAddress = NULL;
+fg_eglInitialize_fun                    fg_eglInitialize = NULL;
+fg_eglMakeCurrent_fun                   fg_eglMakeCurrent = NULL;
+fg_eglQueryContext_fun                  fg_eglQueryContext = NULL;
+fg_eglSwapBuffers_fun                   fg_eglSwapBuffers = NULL;
+fg_eglTerminate_fun                     fg_eglTerminate = NULL;
+
+static const char * fg_egl_lib_names[] = {
+    FG_EGL_SO_NAME, NULL
+};
+static void * fg_egl_lib[sizeof(fg_egl_lib_names)/sizeof(*fg_egl_lib_names)] = { NULL, };
+
+static void * fg_egl_dlopen(const char * name, int flags) {
+    void * lib;
+    if ((lib = dlopen(name, flags)) == NULL) {
+        size_t len = strlen(name);
+        char * path = len ? strdup(name) : NULL;
+        const char * ext;
+        if (!path) return NULL;
+        if (len > 3 && !strcasecmp((ext = name + len - 3), ".so"))
+            len -= 3;
+        else if (len > 6 && !strcasecmp((ext = name + len - 6), ".dylib"))
+            len -= 6;
+        else
+            ext = NULL;
+        while (len > 0 && (isdigit(path[len-1]) || path[len-1] == '.' || (ext && path[len-1] == '-')))
+            --len; /* loop */
+        while (ext && isdigit(path[len])) ++len;
+        path[len] = 0;
+        if (ext != NULL)
+            strcpy(path + len, ext);
+        lib = dlopen(path, flags);
+        free(path);
+    }
+    return lib;
+}
+
+void * fg_egl_findsymbol(const char * name) {
+    void * sym;
+    for (void ** lib = fg_egl_lib; *lib != NULL; ++lib) {
+        if ((sym = dlsym(*lib, name)) != NULL)
+            return sym;
+    }
+    return NULL;
+}
+
+int fg_egl_lib_init() {
+    int ret = 0, i = 0;
+    if (*fg_egl_lib != NULL)
+        return 0;
+    for (const char ** name = fg_egl_lib_names; *name != NULL; ++name, ++i) {
+        if (**name == 0) { --i; continue; }
+        if ((fg_egl_lib[i] = fg_egl_dlopen(*name, RTLD_LOCAL|RTLD_NOW)) == NULL) {
+            return -1;
+        }
+    }
+    fg_egl_lib[i] = NULL;
+    if ((fg_eglBindAPI = fg_egl_findsymbol("eglBindAPI")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "eglBindAPI");
+    if ((fg_eglChooseConfig = fg_egl_findsymbol("eglChooseConfig")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "eglChooseConfig");
+    if ((fg_eglCreateContext = fg_egl_findsymbol("eglCreateContext")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "eglCreateContext");
+    if ((fg_eglCreateWindowSurface = fg_egl_findsymbol("eglCreateWindowSurface")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "eglCreateWindowSurface");
+    if ((fg_eglDestroyContext = fg_egl_findsymbol("eglDestroyContext")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "eglDestroyContext");
+    if ((fg_eglDestroySurface = fg_egl_findsymbol("eglDestroySurface")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "eglDestroySurface");
+    if ((fg_eglGetConfigAttrib = fg_egl_findsymbol("eglGetConfigAttrib")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "eglGetConfigAttrib");
+    if ((fg_eglGetDisplay = fg_egl_findsymbol("eglGetDisplay")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "eglGetDisplay");
+    if ((fg_eglGetError = fg_egl_findsymbol("eglGetError")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "eglGetError");
+    if ((fg_eglGetProcAddress = fg_egl_findsymbol("eglGetProcAddress")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "eglGetProcAddress");
+    if ((fg_eglInitialize = fg_egl_findsymbol("eglInitialize")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "eglInitialize");
+    if ((fg_eglMakeCurrent = fg_egl_findsymbol("eglMakeCurrent")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "eglMakeCurrent");
+    if ((fg_eglQueryContext = fg_egl_findsymbol("eglQueryContext")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "eglQueryContext");
+    if ((fg_eglSwapBuffers = fg_egl_findsymbol("eglSwapBuffers")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "eglSwapBuffers");
+    if ((fg_eglTerminate = fg_egl_findsymbol("eglTerminate")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "eglTerminate");
+    return ret;
+}
+
+void fg_egl_lib_destroy() {
+    if (*fg_egl_lib == NULL)
+        return ;
+    for (void ** lib = fg_egl_lib; *lib; ++lib) {
+        dlclose(*lib);
+        *lib = NULL;
+    }
+    fg_eglBindAPI = NULL;
+    fg_eglChooseConfig = NULL;
+    fg_eglCreateContext = NULL;
+    fg_eglCreateWindowSurface = NULL;
+    fg_eglDestroyContext = NULL;
+    fg_eglDestroySurface = NULL;
+    fg_eglGetConfigAttrib = NULL;
+    fg_eglGetDisplay = NULL;
+    fg_eglGetError = NULL;
+    fg_eglGetProcAddress = NULL;
+    fg_eglInitialize = NULL;
+    fg_eglMakeCurrent = NULL;
+    fg_eglQueryContext = NULL;
+    fg_eglSwapBuffers = NULL;
+    fg_eglTerminate = NULL;
+    return ;
+}
+
+#endif /* ! ifdef FG_EGL_SO_NAME */
+
--- ./src/egl/fg_lib_syms_egl.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./src/egl/fg_lib_syms_egl.h	2023-09-19 21:19:36.129771423 +0200
@@ -0,0 +1,61 @@
+/* GENERATED FILE: fg_lib_syms_egl.h */
+#ifndef FREEGLUT_LIB_SYMS_EGL_H
+#define FREEGLUT_LIB_SYMS_EGL_H
+
+#include "config.h"
+#ifndef FG_EGL_SO_NAME
+int fg_egl_lib_init();
+void fg_egl_lib_destroy();
+#else
+
+#define FREEGLUT_BUILDING_LIB
+#include <GL/freeglut.h>
+#include "fg_internal.h"
+
+typedef   EGLBoolean     (*fg_eglBindAPI_fun) (EGLenum api);
+typedef   EGLBoolean     (*fg_eglChooseConfig_fun) (EGLDisplay dpy, const EGLint *attrib_list, EGLConfig *configs, EGLint config_size, EGLint *num_config);
+typedef   EGLContext     (*fg_eglCreateContext_fun) (EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *attrib_list);
+typedef   EGLSurface     (*fg_eglCreateWindowSurface_fun) (EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *attrib_list);
+typedef   EGLBoolean     (*fg_eglDestroyContext_fun) (EGLDisplay dpy, EGLContext ctx);
+typedef   EGLBoolean     (*fg_eglDestroySurface_fun) (EGLDisplay dpy, EGLSurface surface);
+typedef   EGLBoolean     (*fg_eglGetConfigAttrib_fun) (EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *value);
+typedef   EGLDisplay     (*fg_eglGetDisplay_fun) (EGLNativeDisplayType display_id);
+typedef   EGLint         (*fg_eglGetError_fun) (void);
+typedef   __eglMustCastToProperFunctionPointerType (*fg_eglGetProcAddress_fun) (const char *procname);
+typedef   EGLBoolean     (*fg_eglInitialize_fun) (EGLDisplay dpy, EGLint *major, EGLint *minor);
+typedef   EGLBoolean     (*fg_eglMakeCurrent_fun) (EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx);
+typedef   EGLBoolean     (*fg_eglQueryContext_fun) (EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *value);
+typedef   EGLBoolean     (*fg_eglSwapBuffers_fun) (EGLDisplay dpy, EGLSurface surface);
+typedef   EGLBoolean     (*fg_eglTerminate_fun) (EGLDisplay dpy);
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern fg_eglBindAPI_fun                    fg_eglBindAPI;
+extern fg_eglChooseConfig_fun               fg_eglChooseConfig;
+extern fg_eglCreateContext_fun              fg_eglCreateContext;
+extern fg_eglCreateWindowSurface_fun        fg_eglCreateWindowSurface;
+extern fg_eglDestroyContext_fun             fg_eglDestroyContext;
+extern fg_eglDestroySurface_fun             fg_eglDestroySurface;
+extern fg_eglGetConfigAttrib_fun            fg_eglGetConfigAttrib;
+extern fg_eglGetDisplay_fun                 fg_eglGetDisplay;
+extern fg_eglGetError_fun                   fg_eglGetError;
+extern fg_eglGetProcAddress_fun             fg_eglGetProcAddress;
+extern fg_eglInitialize_fun                 fg_eglInitialize;
+extern fg_eglMakeCurrent_fun                fg_eglMakeCurrent;
+extern fg_eglQueryContext_fun               fg_eglQueryContext;
+extern fg_eglSwapBuffers_fun                fg_eglSwapBuffers;
+extern fg_eglTerminate_fun                  fg_eglTerminate;
+
+int     fg_egl_lib_init();
+void    fg_egl_lib_destroy();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ! ifdef FG_EGL_SO_NAME */
+#endif /* ! ifdef FREEGLUT_LIB_SYMS_EGL_H */
+
--- ./src/egl/fg_state_egl.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/egl/fg_state_egl.c	2023-09-17 21:58:34.522753999 +0200
@@ -36,8 +36,8 @@
   int result __fg_unused;  /*  Not checked  */
 
   if( fgStructure.CurrentWindow )
-      result = eglGetConfigAttrib( fgDisplay.pDisplay.egl.Display,
-				   fgStructure.CurrentWindow->Window.pContext.egl.Config,
+      result = eglGetConfigAttrib( fgDisplay.egl.Display,
+				   fgStructure.CurrentWindow->Window.eglContext.Config,
 				   attribute,
 				   &returnValue );
 
@@ -79,7 +79,7 @@
     {
         /*  We should not have to call fghChooseConfig again here.  */
         EGLConfig config;
-        return fghChooseConfig(&config);
+        return fghChooseConfig_EGL(&config);
     }
 
     /* This is system-dependent */
@@ -99,7 +99,7 @@
     return -1;
 }
 
-int* fgPlatformGlutGetModeValues(GLenum eWhat, int *size)
+int* fgPlatformGlutGetModeValues_EGL(GLenum eWhat, int *size)
 {
   int *array;
 
@@ -108,7 +108,7 @@
 
   array = NULL;
   *size = 0;
-  
+
   switch (eWhat)
     {
     case GLUT_AUX:
@@ -122,34 +122,34 @@
       attributes[4] = EGL_SAMPLES;
       attributes[5] = 1;
       attributes[6] = EGL_NONE;
-      
+
       attribute_name = EGL_SAMPLES;
 
       EGLConfig* configArray;
       EGLint configArraySize = 0;
- 
+
       /* Get number of available configs */
-      if (!eglChooseConfig(fgDisplay.pDisplay.egl.Display,
+      if (!eglChooseConfig(fgDisplay.egl.Display,
 			   attributes, NULL, 0,
 			   &configArraySize))
 	break;
       configArray = calloc(configArraySize, sizeof(EGLConfig));
-      
-      if (!eglChooseConfig(fgDisplay.pDisplay.egl.Display,
+
+      if (!eglChooseConfig(fgDisplay.egl.Display,
 			   attributes, configArray, configArraySize,
 			   &configArraySize))
 	break;
-      
+
       /* We get results in ascending order */
       {
 	int previous_value = 0;
 	int i;
-	
+
 	array = malloc(sizeof(int) * configArraySize);
 
 	for (i = 0; i < configArraySize; i++) {
 	  int value = 0;
-	  eglGetConfigAttrib(fgDisplay.pDisplay.egl.Display,
+	  eglGetConfigAttrib(fgDisplay.egl.Display,
 			     configArray[i], attribute_name, &value);
 	  if (value > previous_value)
 	    {
@@ -158,7 +158,7 @@
 	      (*size)++;
 	    }
 	}
-	
+
 	array = realloc(array, sizeof(int) * (*size));
       }
       free(configArray);
--- ./src/egl/fg_structure_egl.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/egl/fg_structure_egl.c	2023-09-17 17:53:52.777551234 +0200
@@ -31,6 +31,6 @@
  */
 void fghPlatformCreateWindowEGL ( SFG_Window *window )
 {
-  window->Window.pContext.egl.Surface = EGL_NO_SURFACE;
-  window->Window.pContext.egl.Config = NULL;
+  window->Window.eglContext.Surface = EGL_NO_SURFACE;
+  window->Window.eglContext.Config = NULL;
 }
--- ./src/egl/fg_window_egl.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/egl/fg_window_egl.c	2023-09-17 21:50:27.911570008 +0200
@@ -26,20 +26,20 @@
 #include <GL/freeglut.h>
 #include "fg_internal.h"
 
-int fghChooseConfig(EGLConfig* config) {
+int fghChooseConfig_EGL(EGLConfig* config) {
   EGLint num_config;
   EGLint attributes[32];
   int where = 0;
   ATTRIB_VAL(EGL_SURFACE_TYPE, EGL_WINDOW_BIT);
 #ifdef EGL_OPENGL_ES3_BIT
-  if (fgDisplay.pDisplay.egl.MinorVersion >= 5 && fgState.MajorVersion >= 3) {
+  if (fgDisplay.egl.MinorVersion >= 5 && fgState.MajorVersion >= 3) {
     ATTRIB_VAL(EGL_RENDERABLE_TYPE, EGL_OPENGL_ES3_BIT);
   } else
 #endif
   if (fgState.MajorVersion >= 2) {
     /*
-     * Khronos does not specify a EGL_OPENGL_ES3_BIT outside of the OpenGL extension "EGL_KHR_create_context" and EGL 1.5. There are numerous references on the internet 
-     * that say to use EGL_OPENGL_ES3_BIT (pre-EGL 1.5), followed by many saying they can't find it in any headers. In fact, the official updated specification for EGL 
+     * Khronos does not specify a EGL_OPENGL_ES3_BIT outside of the OpenGL extension "EGL_KHR_create_context" and EGL 1.5. There are numerous references on the internet
+     * that say to use EGL_OPENGL_ES3_BIT (pre-EGL 1.5), followed by many saying they can't find it in any headers. In fact, the official updated specification for EGL
      * does not have any references to OpenGL ES 3.x. Tests have shown that EGL_OPENGL_ES2_BIT will work with ES 3.x.
      */
     ATTRIB_VAL(EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT);
@@ -69,7 +69,7 @@
   ATTRIB_VAL(EGL_SAMPLES, (fgState.DisplayMode & GLUT_MULTISAMPLE) ? fgState.SampleNumber : 0);
   ATTRIB(EGL_NONE);
 
-  if (!eglChooseConfig(fgDisplay.pDisplay.egl.Display,
+  if (!eglChooseConfig(fgDisplay.egl.Display,
                attributes, config, 1, &num_config)) {
     fgWarning("eglChooseConfig: error %x\n", eglGetError());
     return 0;
@@ -85,15 +85,15 @@
   EGLContext context;
   EGLint ver = -1;
 
-  EGLDisplay eglDisplay = fgDisplay.pDisplay.egl.Display;
-  EGLConfig eglConfig = window->Window.pContext.egl.Config;
+  EGLDisplay eglDisplay = fgDisplay.egl.Display;
+  EGLConfig eglConfig = window->Window.eglContext.Config;
 
   /* On GLES, user specifies the target version with glutInitContextVersion */
   EGLint attributes[32];
   int where = 0;
   ATTRIB_VAL(EGL_CONTEXT_CLIENT_VERSION, fgState.MajorVersion);
 #ifdef EGL_CONTEXT_MINOR_VERSION
-  if (fgDisplay.pDisplay.egl.MinorVersion >= 5) {
+  if (fgDisplay.egl.MinorVersion >= 5) {
     /* EGL_CONTEXT_CLIENT_VERSION == EGL_CONTEXT_MAJOR_VERSION */
     ATTRIB_VAL(EGL_CONTEXT_MINOR_VERSION, fgState.MinorVersion);
   }
@@ -106,13 +106,13 @@
     fghContextCreationError();
   }
 
-  eglQueryContext(fgDisplay.pDisplay.egl.Display, context, EGL_CONTEXT_CLIENT_VERSION, &ver);
+  eglQueryContext(fgDisplay.egl.Display, context, EGL_CONTEXT_CLIENT_VERSION, &ver);
   if (ver < fgState.MajorVersion) {
     fgError("Wrong GLES major version: %d\n", ver);
   }
 #ifdef EGL_CONTEXT_MINOR_VERSION
-  if (fgDisplay.pDisplay.egl.MinorVersion >= 5) {
-    eglQueryContext(fgDisplay.pDisplay.egl.Display, context, EGL_CONTEXT_MINOR_VERSION, &ver);
+  if (fgDisplay.egl.MinorVersion >= 5) {
+    eglQueryContext(fgDisplay.egl.Display, context, EGL_CONTEXT_MINOR_VERSION, &ver);
     if (ver < fgState.MinorVersion) {
       fgError("Wrong GLES minor version: %d\n", ver);
     }
@@ -122,13 +122,13 @@
   return context;
 }
 
-void fgPlatformSetWindow ( SFG_Window *window )
+void fgPlatformSetWindow_EGL ( SFG_Window *window )
 {
   if ( window != fgStructure.CurrentWindow && window) {
-    if (eglMakeCurrent(fgDisplay.pDisplay.egl.Display,
-               window->Window.pContext.egl.Surface,
-               window->Window.pContext.egl.Surface,
-               window->Window.Context) == EGL_FALSE)
+    if (eglMakeCurrent(fgDisplay.egl.Display,
+               window->Window.eglContext.Surface,
+               window->Window.eglContext.Surface,
+               window->Window.Context.Context_EGL) == EGL_FALSE)
       fgError("eglMakeCurrent: err=%x\n", eglGetError());
   }
 }
@@ -138,15 +138,15 @@
  */
 void fghPlatformOpenWindowEGL( SFG_Window* window )
 {
-  EGLDisplay display = fgDisplay.pDisplay.egl.Display;
-  EGLConfig  config  = window->Window.pContext.egl.Config;
+  EGLDisplay display = fgDisplay.egl.Display;
+  EGLConfig  config  = window->Window.eglContext.Config;
 
-  EGLSurface surface = eglCreateWindowSurface(display, config, window->Window.Handle, NULL);
+  EGLSurface surface = eglCreateWindowSurface(display, config, window->Window.Handle.Handle_EGL, NULL);
   if (surface == EGL_NO_SURFACE)
     fgError("Cannot create EGL window surface, err=%x\n", eglGetError());
-  window->Window.pContext.egl.Surface = surface;
+  window->Window.eglContext.Surface = surface;
 
-  fgPlatformSetWindow(window);
+  fgPlatformSetWindow_EGL(window);
 
   /* EGLint w, h; */
   /* eglQuerySurface(display, surface, EGL_WIDTH, &w); */
@@ -161,9 +161,9 @@
 {
   /* Based on fg_window_mswin fgPlatformCloseWindow */
   if( fgStructure.CurrentWindow == window )
-    eglMakeCurrent(fgDisplay.pDisplay.egl.Display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+    eglMakeCurrent(fgDisplay.egl.Display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
 
-  if (window->Window.Context != EGL_NO_CONTEXT) {
+  if (window->Window.Context.Context_EGL != EGL_NO_CONTEXT) {
     /* Step through the list of windows. If the rendering context is not being used by another window, then delete it */
     {
       GLboolean used = GL_FALSE;
@@ -173,19 +173,19 @@
            iter && used == GL_FALSE;
            iter = (SFG_Window*)iter->Node.Next)
       {
-        if( (iter->Window.Context == window->Window.Context) &&
+        if( (iter->Window.Context.Context_EGL == window->Window.Context.Context_EGL) &&
             (iter != window) )
           used = GL_TRUE;
       }
 
       if( !used )
-        eglDestroyContext(fgDisplay.pDisplay.egl.Display, window->Window.Context);
+        eglDestroyContext(fgDisplay.egl.Display, window->Window.Context.Context_EGL);
     }
-    window->Window.Context = EGL_NO_CONTEXT;
+    window->Window.Context.Context_EGL = EGL_NO_CONTEXT;
   }
 
-  if (window->Window.pContext.egl.Surface != EGL_NO_SURFACE) {
-    eglDestroySurface(fgDisplay.pDisplay.egl.Display, window->Window.pContext.egl.Surface);
-    window->Window.pContext.egl.Surface = EGL_NO_SURFACE;
+  if (window->Window.eglContext.Surface != EGL_NO_SURFACE) {
+    eglDestroySurface(fgDisplay.egl.Display, window->Window.eglContext.Surface);
+    window->Window.eglContext.Surface = EGL_NO_SURFACE;
   }
 }
--- ./src/egl/fg_window_egl.h.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/egl/fg_window_egl.h	2023-09-17 21:48:16.389841997 +0200
@@ -26,10 +26,10 @@
 #ifndef __FG_WINDOW_EGL_H__
 #define __FG_WINDOW_EGL_H__
 
-extern int fghChooseConfig(EGLConfig* config);
+extern int fghChooseConfig_EGL(EGLConfig* config);
 extern void fghPlatformOpenWindowEGL( SFG_Window* window );
 extern EGLConfig fghCreateNewContextEGL( SFG_Window* window );
 extern void fghPlatformCloseWindowEGL( SFG_Window* window );
-extern void fgPlatformSetWindow ( SFG_Window *window );
+extern void fgPlatformSetWindow_EGL ( SFG_Window *window );
 
 #endif
--- ./src/fg_cursor.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/fg_cursor.c	2023-09-16 12:22:48.018001000 +0200
@@ -39,15 +39,15 @@
 
 /* -- PRIVATE FUNCTIONS --------------------------------------------------- */
 
-extern void fgPlatformSetCursor ( SFG_Window *window, int cursorID );
-extern void fgPlatformWarpPointer ( int x, int y );
+/* extern void fgPlatform->SetCursor ( SFG_Window *window, int cursorID ); */
+/* extern void fgPlatform->WarpPointer ( int x, int y ); */
 
 
 
 /* -- INTERNAL FUNCTIONS ---------------------------------------------------- */
 void fgSetCursor ( SFG_Window *window, int cursorID )
 {
-    fgPlatformSetCursor ( window, cursorID );
+    fgPlatform->SetCursor ( window, cursorID );
 }
 
 
@@ -61,7 +61,7 @@
     FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutSetCursor" );
     FREEGLUT_EXIT_IF_NO_WINDOW ( "glutSetCursor" );
 
-    fgPlatformSetCursor ( fgStructure.CurrentWindow, cursorID );
+    fgPlatform->SetCursor ( fgStructure.CurrentWindow, cursorID );
     fgStructure.CurrentWindow->State.Cursor = cursorID;
 }
 
@@ -73,7 +73,7 @@
     FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutWarpPointer" );
     FREEGLUT_EXIT_IF_NO_WINDOW ( "glutWarpPointer" );
 
-    fgPlatformWarpPointer ( x, y );
+    fgPlatform->WarpPointer ( x, y );
 }
 
 /*** END OF FILE ***/
--- ./src/fg_display.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/fg_display.c	2023-09-16 14:54:17.434001000 +0200
@@ -30,7 +30,7 @@
 
 
 /* Function prototypes */
-extern void fgPlatformGlutSwapBuffers( SFG_PlatformDisplay *pDisplayPtr, SFG_Window* CurrentWindow );
+/* extern void fgPlatform->GlutSwapBuffers( SFG_PlatformDisplay *pDisplayPtr, SFG_Window* CurrentWindow ); */
 
 
 /* -- INTERFACE FUNCTIONS -------------------------------------------------- */
@@ -66,7 +66,7 @@
     if( ! fgStructure.CurrentWindow->Window.DoubleBuffered )
         return;
 
-    fgPlatformGlutSwapBuffers( &fgDisplay.pDisplay, fgStructure.CurrentWindow );
+    fgPlatform->GlutSwapBuffers( &fgDisplay, fgStructure.CurrentWindow );
 
     /* GLUT_FPS env var support */
     if( fgState.FPSInterval )
--- ./src/fg_ext.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/fg_ext.c	2023-09-16 12:23:37.962001000 +0200
@@ -29,8 +29,8 @@
 #include <GL/freeglut.h>
 #include "fg_internal.h"
 
-extern SFG_Proc fgPlatformGetProcAddress( const char *procName );
-extern GLUTproc fgPlatformGetGLUTProcAddress( const char *procName );
+/* extern SFG_Proc fgPlatform->GetProcAddress( const char *procName ); */
+/* extern GLUTproc fgPlatform->GetGLUTProcAddress( const char *procName ); */
 
 static GLUTproc fghGetGLUTProcAddress( const char* procName )
 {
@@ -268,7 +268,7 @@
 
     /* Some GLUT functions are platform-specific: */
     if ( !p )
-      p = fgPlatformGetGLUTProcAddress( procName );
+      p = fgPlatform->GetGLUTProcAddress( procName );
 
-    return ( p != NULL ) ? p : fgPlatformGetProcAddress( procName );
+    return ( p != NULL ) ? p : fgPlatform->GetProcAddress( procName );
 }
--- ./src/fg_gamemode.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/fg_gamemode.c	2023-09-16 12:24:58.166001000 +0200
@@ -30,11 +30,11 @@
 
 
 /* -- PRIVATE FUNCTIONS ---------------------------------------------------- */
-extern void fgPlatformRememberState( void );
-extern void fgPlatformRestoreState( void );
-extern GLboolean fgPlatformChangeDisplayMode( GLboolean haveToTest );
-extern void fgPlatformEnterGameMode( void );
-extern void fgPlatformLeaveGameMode( void );
+/* extern void fgPlatform->RememberState( void ); */
+/* extern void fgPlatform->RestoreState( void ); */
+/* extern GLboolean fgPlatform->ChangeDisplayMode( GLboolean haveToTest ); */
+/* extern void fgPlatform->EnterGameMode( void ); */
+/* extern void fgPlatform->LeaveGameMode( void ); */
 
 
 /* -- INTERFACE FUNCTIONS -------------------------------------------------- */
@@ -69,7 +69,7 @@
 
     /* All values not specified are now set to -1, which means those
      * aspects of the current display mode are not changed in
-     * fgPlatformChangeDisplayMode() above.
+     * fgPlatform->ChangeDisplayMode() above.
      */
     fgState.GameModeSize.X  = width;
     fgState.GameModeSize.Y  = height;
@@ -89,9 +89,9 @@
     if( fgStructure.GameModeWindow )
         fgAddToWindowDestroyList( fgStructure.GameModeWindow );
     else
-        fgPlatformRememberState( );
+        fgPlatform->RememberState( );
 
-    if( ! fgPlatformChangeDisplayMode( GL_FALSE ) )
+    if( ! fgPlatform->ChangeDisplayMode( GL_FALSE ) )
     {
         fgWarning( "failed to change screen settings" );
         return 0;
@@ -105,7 +105,7 @@
 
     glutFullScreen();
 
-    fgPlatformEnterGameMode();
+    fgPlatform->EnterGameMode();
 
     return fgStructure.GameModeWindow->ID;
 }
@@ -122,9 +122,9 @@
     fgAddToWindowDestroyList( fgStructure.GameModeWindow );
     fgStructure.GameModeWindow = NULL;
 
-    fgPlatformLeaveGameMode();
+    fgPlatform->LeaveGameMode();
 
-    fgPlatformRestoreState();
+    fgPlatform->RestoreState();
 }
 
 /*
@@ -140,7 +140,7 @@
         return !!fgStructure.GameModeWindow;
 
     case GLUT_GAME_MODE_POSSIBLE:
-        return fgPlatformChangeDisplayMode( GL_TRUE );
+        return fgPlatform->ChangeDisplayMode( GL_TRUE );
 
     case GLUT_GAME_MODE_WIDTH:
         return fgState.GameModeSize.X;
--- ./src/fg_init.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/fg_init.c	2023-09-26 18:16:23.575005000 +0200
@@ -28,6 +28,7 @@
 #define FREEGLUT_BUILDING_LIB
 #include <GL/freeglut.h>
 #include "fg_internal.h"
+#include "fg_lib_syms_gl.h"
 
 /*
  * TODO BEFORE THE STABLE RELEASE:
@@ -49,6 +50,44 @@
  */
 SFG_Display fgDisplay;
 
+/* the current glut platform */
+SFG_Platform * fgPlatform = NULL;
+
+#if  TARGET_HOST_POSIX_WAYLAND
+    extern SFG_Platform fgPlatform_WL;
+#endif
+#if  TARGET_HOST_POSIX_X11
+    extern SFG_Platform fgPlatform_X11;
+#endif
+#if TARGET_HOST_MS_WINDOWS
+    extern SFG_Platform fgPlatform_Win;
+#endif
+#if TARGET_HOST_ANDROID
+    extern SFG_Platform fgPlatform_Android;
+#endif
+#if TARGET_HOST_BLACKBERRY
+    extern SFG_Platform fgPlatform_BlackBerry;
+#endif
+
+/*    extern SFG_Platform fgPlatform_Win; */
+SFG_Platform * fgPlatforms[] = {
+#if  TARGET_HOST_POSIX_WAYLAND
+    &fgPlatform_WL,
+#endif
+#if  TARGET_HOST_POSIX_X11
+    &fgPlatform_X11,
+#endif
+#if TARGET_HOST_MS_WINDOWS
+    &fgPlatform_Win,
+#endif
+#if TARGET_HOST_ANDROID
+    &fgPlatform_Android,
+#endif
+#if TARGET_HOST_BLACKBERRY
+    &fgPlatform_BlackBerry,
+#endif
+};
+
 /*
  * The settings for the current freeglut session
  */
@@ -105,10 +144,10 @@
 
 /* -- PRIVATE FUNCTIONS ---------------------------------------------------- */
 
-extern void fgPlatformInitialize( const char* displayName );
-extern void fgPlatformDeinitialiseInputDevices ( void );
-extern void fgPlatformCloseDisplay ( void );
-extern void fgPlatformDestroyContext ( SFG_PlatformDisplay pDisplay, SFG_WindowContextType MContext );
+/* extern void fgPlatform->Initialize( const char* displayName ); */
+/* extern void fgPlatform->DeinitialiseInputDevices ( void ); */
+/* extern void fgPlatform->CloseDisplay ( void ); */
+/* extern void fgPlatform->DestroyContext ( SFG_PlatformDisplay pDisplay, SFG_WindowContextType MContext ); */
 
 void fghParseCommandLineArguments ( int* pargc, char** argv, char **pDisplayName, char **pGeometry )
 {
@@ -243,7 +282,7 @@
     /* If there was a menu created, destroy the rendering context */
     if( fgStructure.MenuContext )
     {
-        fgPlatformDestroyContext (fgDisplay.pDisplay, fgStructure.MenuContext->MContext );
+        fgPlatform->DestroyContext ( &fgDisplay, fgStructure.MenuContext->MContext );
         free( fgStructure.MenuContext );
         fgStructure.MenuContext = NULL;
     }
@@ -262,7 +301,7 @@
         free( timer );
     }
 
-    fgPlatformDeinitialiseInputDevices ();
+    fgPlatform->DeinitialiseInputDevices ();
 
     fgState.MouseWheelTicks = 0;
 
@@ -318,7 +357,7 @@
         fgState.ProgramName = NULL;
     }
 
-    fgPlatformCloseDisplay ();
+    fgPlatform->CloseDisplay ();
 
     fgState.Initialised = GL_FALSE;
 }
@@ -337,8 +376,14 @@
 {
     char* displayName = NULL;
     char* geometry = NULL;
-    if( fgState.Initialised )
-        fgError( "illegal glutInit() reinitialization attempt" );
+    if( fgState.Initialised ) {
+        fgWarning( "illegal glutInit() reinitialization attempt" );
+        return ;
+    }
+
+    /* loads dynamically libGL if necessary (FREEGLUT_DYNLIB_GL) */
+    if (fg_gl_lib_init() != 0)
+        fgError("cannot load GL library");
 
     if (pargc && *pargc && argv && *argv && **argv)
     {
@@ -357,7 +402,23 @@
      * in the program arguments, we will use the DISPLAY environment
      * variable for opening the X display (see code above):
      */
-    fgPlatformInitialize( displayName );
+    for (unsigned int i = 0; i < sizeof(fgPlatforms) / sizeof(*fgPlatforms); ++i) {
+        if (fgPlatforms[i]->DisplayType == GLUT_DISPLAY_NONE)
+            continue ;
+
+        fgWarning("trying %s...", fgPlatforms[i]->name);
+        fgPlatform = fgPlatforms[i];
+
+        fgPlatforms[i]->Initialize( displayName );
+
+        if (fgState.Initialised) {
+            break ;
+        }
+        fgPlatform = NULL;
+    }
+    if (fgPlatform == NULL) {
+        fgError( "Cannot find a suitable display engine" );
+    }
 
     /*
      * Geometry parsing deferred until here because we may need the screen
--- ./src/fg_input_devices.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/fg_input_devices.c	2023-09-16 12:26:04.218001000 +0200
@@ -77,7 +77,7 @@
 extern int fg_serial_putchar ( SERIALPORT *port, unsigned char ch );
 extern void fg_serial_flush ( SERIALPORT *port );
 
-extern void fgPlatformRegisterDialDevice ( const char *dial_device );
+/* extern void fgPlatform->RegisterDialDevice ( const char *dial_device ); */
 static void send_dial_event(int dial, int value);
 static void poll_dials(int id);
 
@@ -111,7 +111,7 @@
     {
         const char *dial_device=NULL;
         dial_device = getenv ( "GLUT_DIALS_SERIAL" );
-        fgPlatformRegisterDialDevice ( dial_device );
+        fgPlatform->RegisterDialDevice ( dial_device );
 
         if ( !dial_device ) return;
         if ( !( dialbox_port = fg_serial_open ( dial_device ) ) ) return;
--- ./src/fg_internal.h.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/fg_internal.h	2023-09-19 22:25:19.596519431 +0200
@@ -55,7 +55,8 @@
 #elif defined(__posix__) || defined(unix) || defined(__unix__) || defined(__linux__) || defined(__sun)
 #   if defined(FREEGLUT_WAYLAND)
 #      define  TARGET_HOST_POSIX_WAYLAND  1
-#   else
+#   endif
+#   if defined(FREEGLUT_X11)
 #      define  TARGET_HOST_POSIX_X11  1
 #   endif
 
@@ -194,23 +195,48 @@
 # endif
 #endif
 
+/*
+ * A generic function pointer.  We should really use the GLUTproc type
+ * defined in freeglut_ext.h, but if we include that header in this file
+ * a bunch of other stuff (font-related) blows up!
+ */
+typedef void (*SFG_Proc)();
+
+
 /* Platform-specific includes */
 #if TARGET_HOST_POSIX_WAYLAND
 #include "wayland/fg_internal_wl.h"
+#define DEFINE_VAR_WAYLAND(type, var) DEFINE_VAR_HOST(type, var, WL)
 #endif
 #if TARGET_HOST_POSIX_X11
 #include "x11/fg_internal_x11.h"
+#define DEFINE_VAR_X11(type, var) DEFINE_VAR_HOST(type, var, X11)
 #endif
 #if TARGET_HOST_MS_WINDOWS
 #include "mswin/fg_internal_mswin.h"
+#define DEFINE_VAR_WIN(type, var) DEFINE_VAR_HOST(type, var, WIN)
 #endif
 #if TARGET_HOST_ANDROID
 #include "android/fg_internal_android.h"
+#define DEFINE_VAR_ANDROID(type, var) DEFINE_VAR_HOST(type, var, ANDROID)
 #endif
 #if TARGET_HOST_BLACKBERRY
 #include "blackberry/fg_internal_blackberry.h"
+#define DEFINE_VAR_BLACKBERRY(type, var) DEFINE_VAR_HOST(type, var, BLACKBERRY)
 #endif
+#include "fg_lib_defs_gl.h"
+#include "fg_lib_syms_gl.h"
 
+#define EXPAND(name) name
+#define DEFINE_VAR_HOST(type, var, host) \
+        EXPAND(type)_##host EXPAND(var)_##host;
+
+#define DEFINE_VAR_HOSTS(type, var) \
+    DEFINE_VAR_WAYLAND(type, var) \
+    DEFINE_VAR_X11(type, var) \
+    DEFINE_VAR_WINDOWS(type, var) \
+    DEFINE_VAR_ANDROID(type, var) \
+    DEFINE_VAR_BLACKBERRY(type, var)
 
 /* -- GLOBAL TYPE DEFINITIONS ---------------------------------------------- */
 
@@ -413,12 +439,31 @@
     FGCBUserData     WarningFuncData;      /* User defined warning handler user data */
 };
 
+#if 0
+typedef union {
+    DEFINE_VAR_HOSTS(SFG_PlatformDisplay, pDisplay)
+} SFG_PlatformDisplay;
+#else
+typedef union {
+#if TARGET_HOST_POSIX_WAYLAND
+      SFG_PlatformDisplay_WL pDisplay_WL;
+#endif
+#if TARGET_HOST_POSIX_X11
+      SFG_PlatformDisplay_X11 pDisplay_X11;
+#endif
+} SFG_PlatformDisplay;
+#endif
+
 /* The structure used by display initialization in fg_init.c */
 typedef struct tagSFG_Display SFG_Display;
 struct tagSFG_Display
 {
     SFG_PlatformDisplay pDisplay;
 
+#ifdef EGL_VERSION_1_0
+    struct tagSFG_PlatformDisplayEGL egl;
+#endif
+
     int             ScreenWidth;        /* The screen's width in pixels      */
     int             ScreenHeight;       /* The screen's height in pixels     */
     int             ScreenWidthMM;      /* The screen's width in milimeters  */
@@ -441,16 +486,60 @@
  * A window and its OpenGL context. The contents of this structure
  * are highly dependent on the target operating system we aim at...
  */
+//typedef void * SFG_WindowHandleType;
+
+typedef union {
+#if TARGET_HOST_POSIX_WAYLAND || defined(EGL_VERSION_1_0)
+        SFG_WindowContextType_EGL Context_EGL;    /* The window's OpenGL/WGL context     */
+#endif
+#if TARGET_HOST_POSIX_X11
+        SFG_WindowContextType_X11 Context_X11;          /* The window's OpenGL/WGL context     */
+#endif
+} SFG_WindowContextType;
+
+typedef union {
+#if TARGET_HOST_POSIX_WAYLAND || defined(EGL_VERSION_1_0)
+        SFG_WindowHandleType_EGL Handle_EGL;      /* The window's handle                 */
+#endif
+#if TARGET_HOST_POSIX_X11
+        SFG_WindowHandleType_X11 Handle_X11;     /* The window's handle                 */
+#endif
+    void * ptr;
+} SFG_WindowHandleType;
+
+typedef union {
+#if TARGET_HOST_POSIX_WAYLAND || defined(EGL_VERSION_1_0)
+        SFG_WindowColormapType_EGL cmap_EGL;
+#endif
+#if TARGET_HOST_POSIX_X11
+        SFG_WindowColormapType_X11 cmap_X11;            /* The window's colormap/palette */
+#endif
+} SFG_WindowColormapType;
+
+typedef union {
+      #if TARGET_HOST_POSIX_WAYLAND
+        SFG_PlatformContext_WL pContext_WL;
+      #endif
+      #if TARGET_HOST_POSIX_X11
+        SFG_PlatformContext_X11 pContext_X11;    /* The window's FBConfig (X11) or device context (Windows) */
+      #endif
+} SFG_PlatformContext;
+
 typedef struct tagSFG_Context SFG_Context;
 struct tagSFG_Context
 {
-    SFG_WindowHandleType Handle;     /* The window's handle                 */
-    SFG_WindowContextType Context;   /* The window's OpenGL/WGL context     */
-    SFG_WindowColormapType cmap;     /* The window's colormap/palette */
-	int cmap_size;                   /* colormap number of entries */
+    SFG_WindowContextType   Context;           /* The window's OpenGL/WGL context     */
+    SFG_WindowHandleType    Handle;            /* The window's handle                 */
+
+    SFG_WindowColormapType cmap;               /* The window's colormap/palette */
+    int cmap_size;                             /* colormap number of entries */
 
     SFG_PlatformContext pContext;    /* The window's FBConfig (X11) or device context (Windows) */
 
+#ifdef EGL_VERSION_1_0
+    struct tagSFG_PlatformContextEGL eglContext;
+#endif
+
     int DoubleBuffered;              /* Treat the window as double-buffered */
 
     /* When drawing geometry to vertex attribute buffers, user specifies
@@ -508,6 +597,15 @@
  *    of the upper left hand corner of the drawable area, i.e.
  *    of the client rect--which is NOT the (x,y) you specified.
  */
+typedef union {
+#if TARGET_HOST_POSIX_WAYLAND
+        SFG_PlatformWindowState_WL pWState_WL;
+#endif
+#if TARGET_HOST_POSIX_X11
+        SFG_PlatformWindowState_X11 pWState_X11;
+#endif
+} SFG_PlatformWindowState;
+
 typedef struct tagSFG_WindowState SFG_WindowState;
 struct tagSFG_WindowState   /* as per notes above, sizes always refer to the client area (thus without the window decorations) */
 {
@@ -552,14 +650,6 @@
 
 
 /*
- * A generic function pointer.  We should really use the GLUTproc type
- * defined in freeglut_ext.h, but if we include that header in this file
- * a bunch of other stuff (font-related) blows up!
- */
-typedef void (*SFG_Proc)();
-
-
-/*
  * SET_WCB() is used as:
  *
  *     SET_WCB( window, cbname, func, udata );
@@ -944,6 +1034,15 @@
  * Definition of "SFG_Joystick" structure -- based on JS's "jsJoystick" object class.
  * See "js.h" lines 80-178.
  */
+typedef union {
+#if TARGET_HOST_POSIX_WAYLAND
+        SFG_PlatformJoystick_WL pJoystick_WL;
+#endif
+#if TARGET_HOST_POSIX_X11
+        SFG_PlatformJoystick_X11 pJoystick_X11;
+#endif
+} SFG_PlatformJoystick;
+
 typedef struct tagSFG_Joystick SFG_Joystick;
 struct tagSFG_Joystick
 {
@@ -975,6 +1074,9 @@
 /* The current freeglut settings */
 extern SFG_State fgState;
 
+/* the current platform */
+typedef struct tagSFG_Platform SFG_Platform;
+extern SFG_Platform * fgPlatform;
 
 /* -- PRIVATE FUNCTION DECLARATIONS ---------------------------------------- */
 
@@ -1162,8 +1264,6 @@
 void fgError( const char *fmt, ... );
 void fgWarning( const char *fmt, ... );
 
-SFG_Proc fgPlatformGetProcAddress( const char *procName );
-
 /* pushing attribute/value pairs into an array */
 #define ATTRIB(a) attributes[where++]=(a)
 #define ATTRIB_VAL(a,v) {ATTRIB(a); ATTRIB(v);}
@@ -1173,6 +1273,75 @@
 void fghContextCreationError( void );
 int fghNumberOfAuxBuffersRequested( void );
 
+/* the type of display */
+typedef enum {
+    GLUT_DISPLAY_NONE,
+    GLUT_DISPLAY_X11,
+    GLUT_DISPLAY_EGL,
+    GLUT_DISPLAY_ANDROID,
+    GLUT_DISPLAY_WAYLAND,
+    GLUT_DISPLAY_WINDOWS,
+    GLUT_DISPLAY_BLACKBERRY
+} fgDisplayType;
+
+/*  grep fgPlatform -rI 'src/'*.c | grep 'extern ' | awk -F ':' '{ print $2 $3 $4 $5 $6 $7 $8 $9 }' | sort | uniq | sed -e 's%^extern *%%' -e 's/fgPlatform\([^[:space:](]*\)/(*\1)/' */
+struct tagSFG_Platform {
+    const char *    name;
+    fgDisplayType   DisplayType;
+
+    fg_time_t (*SystemTime) ( void );
+    GLboolean (*ChangeDisplayMode)( GLboolean haveToTest );
+    GLUTproc (*GetGLUTProcAddress)( const char *procName );
+    GLvoid (*GetGameModeVMaxExtent)( SFG_Window* window, int* x, int* y );
+    int (*GlutDeviceGet) ( GLenum eWhat );
+    int (*GlutGet) ( GLenum eWhat );
+    int *(*GlutGetModeValues)(GLenum eWhat, int *size);
+    int (*HasSpaceball)(void);
+    int (*SpaceballNumButtons)(void);
+    SFG_Proc (*GetProcAddress)( const char *procName );
+    void (*CloseDisplay) ( void );
+    void (*CloseWindow)( SFG_Window* window );
+    void (*CreateWindow) ( SFG_Window *window );
+    void (*DeinitialiseInputDevices) ( void );
+    void (*DestroyContext) ( SFG_Display * Display, SFG_WindowContextType Context );
+    void (*EnterGameMode)( void );
+    void (*GlutSetIconTitle)( const char* title );
+    void (*GlutSetWindowTitle)( const char* title );
+    void (*GlutSwapBuffers)( SFG_Display * Display, SFG_Window* CurrentWindow );
+    void (*HideWindow)( SFG_Window* window );
+    void (*Initialize)( const char* displayName );
+    void (*InitializeSpaceball)(void);
+    void (*InitWork)(SFG_Window* window);
+    void (*JoystickClose) ( int ident );
+    void (*JoystickInit)( SFG_Joystick *fgJoystick[], int ident );
+    void (*JoystickOpen)( SFG_Joystick* joy );
+    void (*JoystickRawRead)( SFG_Joystick* joy, int* buttons, float* axes );
+    void (*LeaveGameMode)( void );
+    void (*MainLoopPreliminaryWork) ( void );
+    void (*OpenWindow)( SFG_Window* window, const char* title,
+                        GLboolean positionUse, int x, int y,
+                        GLboolean sizeUse, int w, int h,
+                        GLboolean gameMode, GLboolean isSubWindow);
+    void (*PosResZordWork)(SFG_Window* window, unsigned int workMask);
+    void (*ProcessSingleEvent) ( void );
+    void (*RegisterDialDevice) ( const char *dial_device );
+    void (*RememberState)( void );
+    void (*RestoreState)( void );
+    void (*SetCursor) ( SFG_Window *window, int cursorID );
+    void (*SetWindow) ( SFG_Window *window );
+    void (*SleepForEvents)( fg_time_t msec );
+    void (*SpaceballClose)(void);
+    void (*SpaceballSetWindow)(SFG_Window *window);
+    void (*VisibilityWork)(SFG_Window* window);
+    void (*WarpPointer) ( int x, int y );
+    void (*SetColor) ( int idx, float r, float g, float b );
+    float (*GetColor) ( int idx, int comp );
+    void (*CopyColormap) ( int win );
+    void (*GetCursorPos)(const SFG_Window *window, GLboolean client, SFG_XYUse *mouse_pos);
+};
+
+extern SFG_Platform * fgPlaforms[];
+
 #endif /* FREEGLUT_INTERNAL_H */
 
 /*** END OF FILE ***/
--- ./src/fg_joystick.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/fg_joystick.c	2023-09-16 12:29:44.650001000 +0200
@@ -62,10 +62,10 @@
 
 
 /* External function declarations (mostly platform-specific) */
-extern void fgPlatformJoystickRawRead( SFG_Joystick* joy, int* buttons, float* axes );
-extern void fgPlatformJoystickOpen( SFG_Joystick* joy );
-extern void fgPlatformJoystickInit( SFG_Joystick *fgJoystick[], int ident );
-extern void fgPlatformJoystickClose ( int ident );
+/* extern void fgPlatform->JoystickRawRead( SFG_Joystick* joy, int* buttons, float* axes ); */
+/* extern void fgPlatform->JoystickOpen( SFG_Joystick* joy ); */
+/* extern void fgPlatform->JoystickInit( SFG_Joystick *fgJoystick[], int ident ); */
+/* extern void fgPlatform->JoystickClose ( int ident ); */
 
 /*
  * The static joystick structure pointer
@@ -91,7 +91,7 @@
     if( joy->error )
         return;
 
-    fgPlatformJoystickRawRead ( joy, buttons, axes );
+    fgPlatform->JoystickRawRead ( joy, buttons, axes );
 }
 
 /*
@@ -315,7 +315,7 @@
  */
 
 #if TARGET_HOST_MACINTOSH
-void fgPlatformJoystickRawRead( SFG_Joystick* joy, int* buttons, float* axes )
+void fgPlatformJoystickRawRead_MAC( SFG_Joystick* joy, int* buttons, float* axes )
 {
     int i;
 
@@ -347,7 +347,7 @@
 }
 
 
-void fgPlatformJoystickOpen( SFG_Joystick* joy )
+void fgPlatformJoystickOpen_MAC( SFG_Joystick* joy )
 {
     int i = 0;
     OSStatus err;
@@ -452,7 +452,7 @@
 }
 
 
-void fgPlatformJoystickInit( SFG_Joystick *fgJoystick[], int ident )
+void fgPlatformJoystickInit_MAC( SFG_Joystick *fgJoystick[], int ident )
 {
     fgJoystick[ ident ]->id = ident;
     snprintf( fgJoystick[ ident ]->pJoystick.fname, sizeof(fgJoystick[ ident ]->pJoystick.fname), "/dev/js%d", ident ); /* FIXME */
@@ -460,7 +460,7 @@
 }
 
 
-void fgPlatformJoystickClose ( int ident )
+void fgPlatformJoystickClose_MAC ( int ident )
 {
     ISpSuspend( );
     ISpStop( );
@@ -469,7 +469,7 @@
 #endif
 
 #if TARGET_HOST_MAC_OSX
-void fgPlatformJoystickRawRead( SFG_Joystick* joy, int* buttons, float* axes )
+void fgPlatformJoystickRawRead_MAC( SFG_Joystick* joy, int* buttons, float* axes )
 {
     int i;
 
@@ -498,7 +498,7 @@
 }
 
 
-void fgPlatformJoystickOpen( SFG_Joystick* joy )
+void fgPlatformJoystickOpen_MAC( SFG_Joystick* joy )
 {
     IOReturn rv;
     SInt32 score;
@@ -559,7 +559,7 @@
 }
 
 
-void fgPlatformJoystickInit( SFG_Joystick *fgJoystick[], int ident )
+void fgPlatformJoystickInit_MAC( SFG_Joystick *fgJoystick[], int ident )
 {
     fgJoystick[ ident ]->id = ident;
     fgJoystick[ ident ]->error = GL_FALSE;
@@ -604,7 +604,7 @@
 }
 
 
-void fgPlatformJoystickClose ( int ident )
+void fgPlatformJoystickClose_MAC ( int ident )
 {
     ( *( fgJoystick[ ident ]->pJoystick.hidDev ) )->
         close( fgJoystick[ ident ]->pJoystick.hidDev );
@@ -624,7 +624,7 @@
     joy->num_axes = joy->num_buttons = 0;
     joy->name[ 0 ] = '\0';
 
-    fgPlatformJoystickOpen ( joy );
+    fgPlatform->JoystickOpen ( joy );
 
 }
 
@@ -646,7 +646,7 @@
     fgJoystick[ ident ]->num_axes = fgJoystick[ ident ]->num_buttons = 0;
     fgJoystick[ ident ]->error = GL_TRUE;
 
-    fgPlatformJoystickInit( fgJoystick, ident );
+    fgPlatform->JoystickInit( fgJoystick, ident );
 
     fghJoystickOpen( fgJoystick[ ident  ] );
 }
@@ -674,7 +674,7 @@
     {
         if( fgJoystick[ ident ] )
         {
-            fgPlatformJoystickClose ( ident );
+            fgPlatform->JoystickClose ( ident );
 
             free( fgJoystick[ ident ] );
             fgJoystick[ ident ] = NULL;
--- ./src/fg_lib_defs_gl.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./src/fg_lib_defs_gl.h	2023-09-20 16:07:43.908000000 +0200
@@ -0,0 +1,44 @@
+/* GENERATED FILE: fg_lib_defs_gl.h */
+#ifndef FREEGLUT_LIB_DEFS_GL_H
+#define FREEGLUT_LIB_DEFS_GL_H
+
+#ifndef FG_GL_SO_NAME
+#else
+
+#define glBegin                              (*fg_glBegin)
+#define glBitmap                             (*fg_glBitmap)
+#define glColor4f                            (*fg_glColor4f)
+#define glColor4fv                           (*fg_glColor4fv)
+#define glDisable                            (*fg_glDisable)
+#define glDisableClientState                 (*fg_glDisableClientState)
+#define glDrawArrays                         (*fg_glDrawArrays)
+#define glDrawElements                       (*fg_glDrawElements)
+#define glEnableClientState                  (*fg_glEnableClientState)
+#define glEnd                                (*fg_glEnd)
+#define glFlush                              (*fg_glFlush)
+#define glGetError                           (*fg_glGetError)
+#define glGetFloatv                          (*fg_glGetFloatv)
+#define glGetIntegerv                        (*fg_glGetIntegerv)
+#define glGetString                          (*fg_glGetString)
+#define glLoadIdentity                       (*fg_glLoadIdentity)
+#define glMatrixMode                         (*fg_glMatrixMode)
+#define glNormalPointer                      (*fg_glNormalPointer)
+#define glOrtho                              (*fg_glOrtho)
+#define glPixelStorei                        (*fg_glPixelStorei)
+#define glPopAttrib                          (*fg_glPopAttrib)
+#define glPopClientAttrib                    (*fg_glPopClientAttrib)
+#define glPopMatrix                          (*fg_glPopMatrix)
+#define glPushAttrib                         (*fg_glPushAttrib)
+#define glPushClientAttrib                   (*fg_glPushClientAttrib)
+#define glPushMatrix                         (*fg_glPushMatrix)
+#define glRasterPos2i                        (*fg_glRasterPos2i)
+#define glTexCoordPointer                    (*fg_glTexCoordPointer)
+#define glTranslatef                         (*fg_glTranslatef)
+#define glVertex2f                           (*fg_glVertex2f)
+#define glVertex2i                           (*fg_glVertex2i)
+#define glVertexPointer                      (*fg_glVertexPointer)
+#define glViewport                           (*fg_glViewport)
+
+#endif /* ! ifndef FG_GL_SO_NAME */
+#endif /* ! ifndef FREEGLUT_LIB_DEFS_GL_H */
+
--- ./src/fg_lib_gl.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./src/fg_lib_gl.c	2023-09-20 17:26:43.244000000 +0200
@@ -0,0 +1,211 @@
+/* GENERATED FILE: fg_lib_gl.c */
+#include "fg_lib_syms_gl.h"
+
+#ifndef FG_GL_SO_NAME
+int  fg_gl_lib_init() { return 0; }
+void fg_gl_lib_destroy() { }
+#else
+
+#include <dlfcn.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+fg_glBegin_fun                          fg_glBegin = NULL;
+fg_glBitmap_fun                         fg_glBitmap = NULL;
+fg_glColor4f_fun                        fg_glColor4f = NULL;
+fg_glColor4fv_fun                       fg_glColor4fv = NULL;
+fg_glDisable_fun                        fg_glDisable = NULL;
+fg_glDisableClientState_fun             fg_glDisableClientState = NULL;
+fg_glDrawArrays_fun                     fg_glDrawArrays = NULL;
+fg_glDrawElements_fun                   fg_glDrawElements = NULL;
+fg_glEnableClientState_fun              fg_glEnableClientState = NULL;
+fg_glEnd_fun                            fg_glEnd = NULL;
+fg_glFlush_fun                          fg_glFlush = NULL;
+fg_glGetError_fun                       fg_glGetError = NULL;
+fg_glGetFloatv_fun                      fg_glGetFloatv = NULL;
+fg_glGetIntegerv_fun                    fg_glGetIntegerv = NULL;
+fg_glGetString_fun                      fg_glGetString = NULL;
+fg_glLoadIdentity_fun                   fg_glLoadIdentity = NULL;
+fg_glMatrixMode_fun                     fg_glMatrixMode = NULL;
+fg_glNormalPointer_fun                  fg_glNormalPointer = NULL;
+fg_glOrtho_fun                          fg_glOrtho = NULL;
+fg_glPixelStorei_fun                    fg_glPixelStorei = NULL;
+fg_glPopAttrib_fun                      fg_glPopAttrib = NULL;
+fg_glPopClientAttrib_fun                fg_glPopClientAttrib = NULL;
+fg_glPopMatrix_fun                      fg_glPopMatrix = NULL;
+fg_glPushAttrib_fun                     fg_glPushAttrib = NULL;
+fg_glPushClientAttrib_fun               fg_glPushClientAttrib = NULL;
+fg_glPushMatrix_fun                     fg_glPushMatrix = NULL;
+fg_glRasterPos2i_fun                    fg_glRasterPos2i = NULL;
+fg_glTexCoordPointer_fun                fg_glTexCoordPointer = NULL;
+fg_glTranslatef_fun                     fg_glTranslatef = NULL;
+fg_glVertex2f_fun                       fg_glVertex2f = NULL;
+fg_glVertex2i_fun                       fg_glVertex2i = NULL;
+fg_glVertexPointer_fun                  fg_glVertexPointer = NULL;
+fg_glViewport_fun                       fg_glViewport = NULL;
+
+static const char * fg_gl_lib_names[] = {
+    FG_GL_SO_NAME, NULL
+};
+static void * fg_gl_lib[sizeof(fg_gl_lib_names)/sizeof(*fg_gl_lib_names)] = { NULL, };
+
+static void * fg_gl_dlopen(const char * name, int flags) {
+    void * lib;
+    if ((lib = dlopen(name, flags)) == NULL) {
+        size_t len = strlen(name);
+        char * path = len ? strdup(name) : NULL;
+        const char * ext;
+        if (!path) return NULL;
+        if (len > 3 && !strcasecmp((ext = name + len - 3), ".so"))
+            len -= 3;
+        else if (len > 6 && !strcasecmp((ext = name + len - 6), ".dylib"))
+            len -= 6;
+        else
+            ext = NULL;
+        while (len > 0 && (isdigit(path[len-1]) || path[len-1] == '.' || (ext && path[len-1] == '-')))
+            --len; /* loop */
+        while (ext && isdigit(path[len])) ++len;
+        path[len] = 0;
+        if (ext != NULL)
+            strcpy(path + len, ext);
+        lib = dlopen(path, flags);
+        free(path);
+    }
+    return lib;
+}
+
+void * fg_gl_findsymbol(const char * name) {
+    void * sym;
+    for (void ** lib = fg_gl_lib; *lib != NULL; ++lib) {
+        if ((sym = dlsym(*lib, name)) != NULL)
+            return sym;
+    }
+    return NULL;
+}
+
+int fg_gl_lib_init() {
+    int ret = 0, i = 0;
+    if (*fg_gl_lib != NULL)
+        return 0;
+    for (const char ** name = fg_gl_lib_names; *name != NULL; ++name, ++i) {
+        if (**name == 0) { --i; continue; }
+        if ((fg_gl_lib[i] = fg_gl_dlopen(*name, RTLD_LOCAL|RTLD_NOW)) == NULL) {
+            return -1;
+        }
+    }
+    fg_gl_lib[i] = NULL;
+    if ((fg_glBegin = fg_gl_findsymbol("glBegin")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glBegin");
+    if ((fg_glBitmap = fg_gl_findsymbol("glBitmap")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glBitmap");
+    if ((fg_glColor4f = fg_gl_findsymbol("glColor4f")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glColor4f");
+    if ((fg_glColor4fv = fg_gl_findsymbol("glColor4fv")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glColor4fv");
+    if ((fg_glDisable = fg_gl_findsymbol("glDisable")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glDisable");
+    if ((fg_glDisableClientState = fg_gl_findsymbol("glDisableClientState")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glDisableClientState");
+    if ((fg_glDrawArrays = fg_gl_findsymbol("glDrawArrays")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glDrawArrays");
+    if ((fg_glDrawElements = fg_gl_findsymbol("glDrawElements")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glDrawElements");
+    if ((fg_glEnableClientState = fg_gl_findsymbol("glEnableClientState")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glEnableClientState");
+    if ((fg_glEnd = fg_gl_findsymbol("glEnd")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glEnd");
+    if ((fg_glFlush = fg_gl_findsymbol("glFlush")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glFlush");
+    if ((fg_glGetError = fg_gl_findsymbol("glGetError")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glGetError");
+    if ((fg_glGetFloatv = fg_gl_findsymbol("glGetFloatv")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glGetFloatv");
+    if ((fg_glGetIntegerv = fg_gl_findsymbol("glGetIntegerv")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glGetIntegerv");
+    if ((fg_glGetString = fg_gl_findsymbol("glGetString")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glGetString");
+    if ((fg_glLoadIdentity = fg_gl_findsymbol("glLoadIdentity")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glLoadIdentity");
+    if ((fg_glMatrixMode = fg_gl_findsymbol("glMatrixMode")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glMatrixMode");
+    if ((fg_glNormalPointer = fg_gl_findsymbol("glNormalPointer")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glNormalPointer");
+    if ((fg_glOrtho = fg_gl_findsymbol("glOrtho")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glOrtho");
+    if ((fg_glPixelStorei = fg_gl_findsymbol("glPixelStorei")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glPixelStorei");
+    if ((fg_glPopAttrib = fg_gl_findsymbol("glPopAttrib")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glPopAttrib");
+    if ((fg_glPopClientAttrib = fg_gl_findsymbol("glPopClientAttrib")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glPopClientAttrib");
+    if ((fg_glPopMatrix = fg_gl_findsymbol("glPopMatrix")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glPopMatrix");
+    if ((fg_glPushAttrib = fg_gl_findsymbol("glPushAttrib")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glPushAttrib");
+    if ((fg_glPushClientAttrib = fg_gl_findsymbol("glPushClientAttrib")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glPushClientAttrib");
+    if ((fg_glPushMatrix = fg_gl_findsymbol("glPushMatrix")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glPushMatrix");
+    if ((fg_glRasterPos2i = fg_gl_findsymbol("glRasterPos2i")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glRasterPos2i");
+    if ((fg_glTexCoordPointer = fg_gl_findsymbol("glTexCoordPointer")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glTexCoordPointer");
+    if ((fg_glTranslatef = fg_gl_findsymbol("glTranslatef")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glTranslatef");
+    if ((fg_glVertex2f = fg_gl_findsymbol("glVertex2f")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glVertex2f");
+    if ((fg_glVertex2i = fg_gl_findsymbol("glVertex2i")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glVertex2i");
+    if ((fg_glVertexPointer = fg_gl_findsymbol("glVertexPointer")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glVertexPointer");
+    if ((fg_glViewport = fg_gl_findsymbol("glViewport")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glViewport");
+    return ret;
+}
+
+void fg_gl_lib_destroy() {
+    if (*fg_gl_lib == NULL)
+        return ;
+    for (void ** lib = fg_gl_lib; *lib; ++lib) {
+        dlclose(*lib);
+        *lib = NULL;
+    }
+    fg_glBegin = NULL;
+    fg_glBitmap = NULL;
+    fg_glColor4f = NULL;
+    fg_glColor4fv = NULL;
+    fg_glDisable = NULL;
+    fg_glDisableClientState = NULL;
+    fg_glDrawArrays = NULL;
+    fg_glDrawElements = NULL;
+    fg_glEnableClientState = NULL;
+    fg_glEnd = NULL;
+    fg_glFlush = NULL;
+    fg_glGetError = NULL;
+    fg_glGetFloatv = NULL;
+    fg_glGetIntegerv = NULL;
+    fg_glGetString = NULL;
+    fg_glLoadIdentity = NULL;
+    fg_glMatrixMode = NULL;
+    fg_glNormalPointer = NULL;
+    fg_glOrtho = NULL;
+    fg_glPixelStorei = NULL;
+    fg_glPopAttrib = NULL;
+    fg_glPopClientAttrib = NULL;
+    fg_glPopMatrix = NULL;
+    fg_glPushAttrib = NULL;
+    fg_glPushClientAttrib = NULL;
+    fg_glPushMatrix = NULL;
+    fg_glRasterPos2i = NULL;
+    fg_glTexCoordPointer = NULL;
+    fg_glTranslatef = NULL;
+    fg_glVertex2f = NULL;
+    fg_glVertex2i = NULL;
+    fg_glVertexPointer = NULL;
+    fg_glViewport = NULL;
+    return ;
+}
+
+#endif /* ! ifdef FG_GL_SO_NAME */
+
--- ./src/fg_lib_syms_gl.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./src/fg_lib_syms_gl.h	2023-09-19 22:21:33.527541423 +0200
@@ -0,0 +1,97 @@
+/* GENERATED FILE: fg_lib_syms_gl.h */
+#ifndef FREEGLUT_LIB_SYMS_GL_H
+#define FREEGLUT_LIB_SYMS_GL_H
+
+#include "config.h"
+#ifndef FG_GL_SO_NAME
+int fg_gl_lib_init();
+void fg_gl_lib_destroy();
+#else
+
+#define FREEGLUT_BUILDING_LIB
+#include <GL/freeglut.h>
+#include "fg_internal.h"
+
+typedef         void     (*fg_glBegin_fun)( GLenum mode );
+typedef    void          (*fg_glBitmap_fun)( GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap );
+typedef   void           (*fg_glColor4f_fun)( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha );
+typedef   void           (*fg_glColor4fv_fun)( const GLfloat *v );
+typedef    void          (*fg_glDisable_fun)( GLenum cap );
+typedef    void          (*fg_glDisableClientState_fun)( GLenum cap );
+typedef    void          (*fg_glDrawArrays_fun)( GLenum mode, GLint first, GLsizei count );
+typedef    void          (*fg_glDrawElements_fun)( GLenum mode, GLsizei count, GLenum type, const GLvoid *indices );
+typedef     void         (*fg_glEnableClientState_fun)( GLenum cap );
+typedef    void          (*fg_glEnd_fun)( void );
+typedef    void          (*fg_glFlush_fun)( void );
+typedef    GLenum        (*fg_glGetError_fun)( void );
+typedef    void          (*fg_glGetFloatv_fun)( GLenum pname, GLfloat *params );
+typedef    void          (*fg_glGetIntegerv_fun)( GLenum pname, GLint *params );
+typedef    const GLubyte * (*fg_glGetString_fun)( GLenum name );
+typedef    void          (*fg_glLoadIdentity_fun)( void );
+typedef         void     (*fg_glMatrixMode_fun)( GLenum mode );
+typedef    void          (*fg_glNormalPointer_fun)( GLenum type, GLsizei stride, const GLvoid *ptr );
+typedef    void          (*fg_glOrtho_fun)( GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val );
+typedef   void           (*fg_glPixelStorei_fun)( GLenum pname, GLint param );
+typedef    void          (*fg_glPopAttrib_fun)( void );
+typedef    void          (*fg_glPopClientAttrib_fun)( void );
+typedef    void          (*fg_glPopMatrix_fun)( void );
+typedef     void         (*fg_glPushAttrib_fun)( GLbitfield mask );
+typedef     void         (*fg_glPushClientAttrib_fun)( GLbitfield mask );
+typedef    void          (*fg_glPushMatrix_fun)( void );
+typedef   void           (*fg_glRasterPos2i_fun)( GLint x, GLint y );
+typedef    void          (*fg_glTexCoordPointer_fun)( GLint size, GLenum type, GLsizei stride, const GLvoid *ptr );
+typedef   void           (*fg_glTranslatef_fun)( GLfloat x, GLfloat y, GLfloat z );
+typedef   void           (*fg_glVertex2f_fun)( GLfloat x, GLfloat y );
+typedef   void           (*fg_glVertex2i_fun)( GLint x, GLint y );
+typedef         void     (*fg_glVertexPointer_fun)( GLint size, GLenum type, GLsizei stride, const GLvoid *ptr );
+typedef    void          (*fg_glViewport_fun)( GLint x, GLint y, GLsizei width, GLsizei height );
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern fg_glBegin_fun                       fg_glBegin;
+extern fg_glBitmap_fun                      fg_glBitmap;
+extern fg_glColor4f_fun                     fg_glColor4f;
+extern fg_glColor4fv_fun                    fg_glColor4fv;
+extern fg_glDisable_fun                     fg_glDisable;
+extern fg_glDisableClientState_fun          fg_glDisableClientState;
+extern fg_glDrawArrays_fun                  fg_glDrawArrays;
+extern fg_glDrawElements_fun                fg_glDrawElements;
+extern fg_glEnableClientState_fun           fg_glEnableClientState;
+extern fg_glEnd_fun                         fg_glEnd;
+extern fg_glFlush_fun                       fg_glFlush;
+extern fg_glGetError_fun                    fg_glGetError;
+extern fg_glGetFloatv_fun                   fg_glGetFloatv;
+extern fg_glGetIntegerv_fun                 fg_glGetIntegerv;
+extern fg_glGetString_fun                   fg_glGetString;
+extern fg_glLoadIdentity_fun                fg_glLoadIdentity;
+extern fg_glMatrixMode_fun                  fg_glMatrixMode;
+extern fg_glNormalPointer_fun               fg_glNormalPointer;
+extern fg_glOrtho_fun                       fg_glOrtho;
+extern fg_glPixelStorei_fun                 fg_glPixelStorei;
+extern fg_glPopAttrib_fun                   fg_glPopAttrib;
+extern fg_glPopClientAttrib_fun             fg_glPopClientAttrib;
+extern fg_glPopMatrix_fun                   fg_glPopMatrix;
+extern fg_glPushAttrib_fun                  fg_glPushAttrib;
+extern fg_glPushClientAttrib_fun            fg_glPushClientAttrib;
+extern fg_glPushMatrix_fun                  fg_glPushMatrix;
+extern fg_glRasterPos2i_fun                 fg_glRasterPos2i;
+extern fg_glTexCoordPointer_fun             fg_glTexCoordPointer;
+extern fg_glTranslatef_fun                  fg_glTranslatef;
+extern fg_glVertex2f_fun                    fg_glVertex2f;
+extern fg_glVertex2i_fun                    fg_glVertex2i;
+extern fg_glVertexPointer_fun               fg_glVertexPointer;
+extern fg_glViewport_fun                    fg_glViewport;
+
+int     fg_gl_lib_init();
+void    fg_gl_lib_destroy();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ! ifdef FG_GL_SO_NAME */
+#endif /* ! ifdef FREEGLUT_LIB_SYMS_GL_H */
+
--- ./src/fg_main.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/fg_main.c	2023-09-16 12:30:52.474001000 +0200
@@ -46,14 +46,14 @@
 #endif
 
 extern void fgProcessWork   ( SFG_Window *window );
-extern fg_time_t fgPlatformSystemTime ( void );
-extern void fgPlatformSleepForEvents( fg_time_t msec );
-extern void fgPlatformProcessSingleEvent ( void );
-extern void fgPlatformMainLoopPreliminaryWork ( void );
-
-extern void fgPlatformInitWork(SFG_Window* window);
-extern void fgPlatformPosResZordWork(SFG_Window* window, unsigned int workMask);
-extern void fgPlatformVisibilityWork(SFG_Window* window);
+/* extern fg_time_t fgPlatform->SystemTime ( void ); */
+/* extern void fgPlatform->SleepForEvents( fg_time_t msec ); */
+/* extern void fgPlatform->ProcessSingleEvent ( void ); */
+/* extern void fgPlatform->MainLoopPreliminaryWork ( void ); */
+
+/* extern void fgPlatform->InitWork(SFG_Window* window); */
+/* extern void fgPlatform->PosResZordWork(SFG_Window* window, unsigned int workMask); */
+/* extern void fgPlatform->VisibilityWork(SFG_Window* window); */
 
 
 /* -- PRIVATE FUNCTIONS ---------------------------------------------------- */
@@ -246,7 +246,7 @@
  */
 fg_time_t fgSystemTime(void)
 {
-    return fgPlatformSystemTime();
+    return fgPlatform->SystemTime();
 }
 
 /*
@@ -379,7 +379,7 @@
     if( fgState.NumActiveJoysticks>0 && ( msec > 10 ) )
         msec = 10;
 
-    fgPlatformSleepForEvents ( msec );
+    fgPlatform->SleepForEvents ( msec );
 }
 
 
@@ -397,7 +397,7 @@
             /* This is before the first display callback: if needed for the platform,
              * call a few callbacks to inform user of window size, position, etc
              */
-            fgPlatformInitWork(window);
+            fgPlatform->InitWork(window);
 
             /* Call init context callback */
             INVOKE_WCB( *window, InitContext, ( ) );
@@ -414,12 +414,12 @@
         /* On windows we can position, resize and change z order at the same time */
         if (workMask & (GLUT_POSITION_WORK|GLUT_SIZE_WORK|GLUT_ZORDER_WORK|GLUT_FULL_SCREEN_WORK))
         {
-            fgPlatformPosResZordWork(window,workMask);
+            fgPlatform->PosResZordWork(window,workMask);
         }
 
         if (workMask & GLUT_VISIBILITY_WORK)
         {
-            fgPlatformVisibilityWork(window);
+            fgPlatform->VisibilityWork(window);
         }
     }
 
@@ -446,7 +446,7 @@
 void FGAPIENTRY glutMainLoopEvent( void )
 {
     /* Process input */
-    fgPlatformProcessSingleEvent ();
+    fgPlatform->ProcessSingleEvent ();
 
     if( fgState.Timers.First )
         fghCheckTimers( );
@@ -479,7 +479,7 @@
     if (!fgStructure.Windows.First)
         fgError(" ERROR:  glutMainLoop called with no windows created.");
 
-    fgPlatformMainLoopPreliminaryWork ();
+    fgPlatform->MainLoopPreliminaryWork ();
 
     fgState.ExecState = GLUT_EXEC_STATE_RUNNING ;
     for(;;)
--- ./src/fg_menu.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/fg_menu.c	2023-09-17 21:24:21.848930003 +0200
@@ -75,10 +75,10 @@
 static float menu_pen_hback [4] = FREEGLUT_MENU_PEN_HBACK_COLORS;
 
 
-extern GLvoid fgPlatformGetGameModeVMaxExtent( SFG_Window* window, int* x, int* y );
-extern void fghPlatformGetCursorPos(const SFG_Window *window, GLboolean client, SFG_XYUse *mouse_pos);
+/* extern GLvoid fgPlatform->GetGameModeVMaxExtent( SFG_Window* window, int* x, int* y ); */
+//extern void fghPlatformGetCursorPos(const SFG_Window *window, GLboolean client, SFG_XYUse *mouse_pos);
 extern SFG_Font* fghFontByID( void* font );
-extern void fgPlatformHideWindow( SFG_Window* window );
+/* extern void fgPlatform->HideWindow( SFG_Window* window ); */
 
 /* -- PRIVATE FUNCTIONS ---------------------------------------------------- */
 
@@ -109,7 +109,7 @@
 {
     SFG_MenuEntry *subMenuIter;
     /* Hide the present menu's window */
-    fgPlatformHideWindow( menuEntry->SubMenu->Window );
+    fgPlatform->HideWindow( menuEntry->SubMenu->Window );
 
     /* Forget about having that menu active anymore, now: */
     menuEntry->SubMenu->Window->ActiveMenu = NULL;
@@ -135,7 +135,7 @@
 static GLvoid fghGetVMaxExtent( SFG_Window* window, int* x, int* y )
 {
     if( fgStructure.GameModeWindow )
-        fgPlatformGetGameModeVMaxExtent ( window, x, y );
+        fgPlatform->GetGameModeVMaxExtent ( window, x, y );
     else
     {
         *x = fgDisplay.ScreenWidth;
@@ -503,7 +503,7 @@
      * origin when looking at a child window
      * for parent windows: window->State.MouseX + glutGet( GLUT_WINDOW_X ) == mouse_pos.X
      */
-    fghPlatformGetCursorPos(NULL, GL_FALSE, &mouse_pos);
+    fgPlatform->GetCursorPos(NULL, GL_FALSE, &mouse_pos);
     menu->X = mouse_pos.X;
     menu->Y = mouse_pos.Y;
 
@@ -623,7 +623,7 @@
              * Outside the menu, deactivate if it's a downclick
              *
              * A downclick outside of the interior of our freeglut windows
-             * is dealt with in the WM_KILLFOCUS handler of fgPlatformWindowProc
+             * is dealt with in the WM_KILLFOCUS handler of fgPlatform->WindowProc
              */
         {
             fgDeactivateMenu( window->ActiveMenu->ParentWindow );
@@ -687,7 +687,7 @@
     parent_window = menu->ParentWindow;
 
     /* Hide the present menu's window */
-    fgPlatformHideWindow( menu->Window );
+    fgPlatform->HideWindow( menu->Window );
 
     /* Forget about having that menu active anymore, now: */
     menu->Window->ActiveMenu = NULL;
@@ -723,7 +723,7 @@
         {
             /* Get cursor position relative to parent_window's client area */
             SFG_XYUse mouse_pos;
-            fghPlatformGetCursorPos(parent_window, GL_TRUE, &mouse_pos);
+            fgPlatform->GetCursorPos(parent_window, GL_TRUE, &mouse_pos);
 
             fgState.MenuStatusCallback(GLUT_MENU_NOT_IN_USE, mouse_pos.X, mouse_pos.Y, fgState.MenuStatusCallbackData);
         }
--- ./src/fg_misc.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/fg_misc.c	2023-09-16 12:32:36.706001000 +0200
@@ -30,9 +30,9 @@
 
 
 /* platform-specific colormap functions */
-void fgPlatformSetColor(int idx, float r, float g, float b);
-float fgPlatformGetColor(int idx, int comp);
-void fgPlatformCopyColormap(int win);
+/* void fgPlatform->SetColor(int idx, float r, float g, float b);*/
+/* float fgPlatform->GetColor(int idx, int comp); */
+/* void fgPlatform->CopyColormap(int win); */
 
 
 /* -- INTERFACE FUNCTIONS -------------------------------------------------- */
@@ -176,7 +176,7 @@
 void FGAPIENTRY glutSetColor(int idx, GLfloat r, GLfloat g, GLfloat b)
 {
 	FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutSetColor" );
-	fgPlatformSetColor(idx, r, g, b);
+	fgPlatform->SetColor(idx, r, g, b);
 }
 
 /*
@@ -185,7 +185,7 @@
 GLfloat FGAPIENTRY glutGetColor(int idx, int component)
 {
 	FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutGetColor" );
-	return fgPlatformGetColor(idx, component);
+	return fgPlatform->GetColor(idx, component);
 }
 
 /*
@@ -194,7 +194,7 @@
 void FGAPIENTRY glutCopyColormap(int window)
 {
 	FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutCopyColormap" );
-	fgPlatformCopyColormap(window);
+	fgPlatform->CopyColormap(window);
 }
 
 /*** END OF FILE ***/
--- ./src/fg_spaceball.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/fg_spaceball.c	2023-09-16 12:33:37.286001000 +0200
@@ -15,11 +15,11 @@
 
 /* -- PRIVATE FUNCTIONS --------------------------------------------------- */
 
-extern void fgPlatformInitializeSpaceball(void);
-extern void fgPlatformSpaceballClose(void);
-extern int fgPlatformHasSpaceball(void);
-extern int fgPlatformSpaceballNumButtons(void);
-extern void fgPlatformSpaceballSetWindow(SFG_Window *window);
+/* extern void fgPlatform->InitializeSpaceball(void); */
+/* extern void fgPlatform->SpaceballClose(void); */
+/* extern int fgPlatform->HasSpaceball(void); */
+/* extern int fgPlatform->SpaceballNumButtons(void); */
+/* extern void fgPlatform->SpaceballSetWindow(SFG_Window *window); */
 
 
 int fg_sball_initialized = 0;
@@ -30,12 +30,12 @@
         return;
     }
 
-    fgPlatformInitializeSpaceball();
+    fgPlatform->InitializeSpaceball();
 }
 
 void fgSpaceballClose(void)
 {
-    fgPlatformSpaceballClose();
+    fgPlatform->SpaceballClose();
 }
 
 int fgHasSpaceball(void)
@@ -48,7 +48,7 @@
         }
     }
 
-    return fgPlatformHasSpaceball();
+    return fgPlatform->HasSpaceball();
 }
 
 int fgSpaceballNumButtons(void)
@@ -61,7 +61,7 @@
         }
     }
 
-    return fgPlatformSpaceballNumButtons();
+    return fgPlatform->SpaceballNumButtons();
 }
 
 void fgSpaceballSetWindow(SFG_Window *window)
@@ -73,7 +73,7 @@
         }
     }
 
-    fgPlatformSpaceballSetWindow(window);
+    fgPlatform->SpaceballSetWindow(window);
 }
 
 #else
--- ./src/fg_state.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/fg_state.c	2023-09-16 12:34:01.054001000 +0200
@@ -41,9 +41,9 @@
  * The fail-on-call policy will help adding the most needed things imho.
  */
 
-extern int fgPlatformGlutGet ( GLenum eWhat );
-extern int fgPlatformGlutDeviceGet ( GLenum eWhat );
-extern int *fgPlatformGlutGetModeValues(GLenum eWhat, int *size);
+/* extern int fgPlatform->GlutGet ( GLenum eWhat ); */
+/* extern int fgPlatform->GlutDeviceGet ( GLenum eWhat ); */
+/* extern int *fgPlatform->GlutGetModeValues(GLenum eWhat, int *size); */
 extern SFG_Font* fghFontByID( void* font );
 
 
@@ -233,7 +233,7 @@
         return fgState.AllowNegativeWindowPosition;
 
     default:
-        return fgPlatformGlutGet ( eWhat );
+        return fgPlatform->GlutGet ( eWhat );
         break;
     }
 }
@@ -293,7 +293,7 @@
         return fgState.KeyRepeat;
 
     default:
-        return fgPlatformGlutDeviceGet ( eWhat );
+        return fgPlatform->GlutDeviceGet ( eWhat );
     }
 }
 
@@ -368,7 +368,7 @@
   FREEGLUT_EXIT_IF_NOT_INITIALISED("glutGetModeValues");
 
   *size = 0;
-  array = fgPlatformGlutGetModeValues ( eWhat, size );
+  array = fgPlatform->GlutGetModeValues ( eWhat, size );
 
   return array;
 }
--- ./src/fg_structure.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/fg_structure.c	2023-09-17 19:05:37.680926006 +0200
@@ -48,7 +48,7 @@
 
 /* -- PRIVATE FUNCTIONS ---------------------------------------------------- */
 
-extern void fgPlatformCreateWindow ( SFG_Window *window );
+/* extern void fgPlatform->CreateWindow ( SFG_Window *window ); */
 extern void fghDefaultReshape(int width, int height, FGCBUserData userData);
 
 static void fghClearCallBacks( SFG_Window *window )
@@ -83,7 +83,7 @@
         fgError( "Out of memory. Could not create window." );
     }
 
-    fgPlatformCreateWindow ( window );
+    fgPlatform->CreateWindow ( window );
 
     fghClearCallBacks( window );
     SET_WCB( *window, Reshape, fghDefaultReshape, NULL);
@@ -465,7 +465,8 @@
         return;
 
     /* Check the window's handle. Hope this works. Looks ugly. That's for sure. */
-    if( window->Window.Handle == (SFG_WindowHandleType) (enumerator->data) )
+    //if( window->Window.Handle == (SFG_WindowHandleType) (enumerator->data) )
+    if( window->Window.Handle.ptr == (enumerator->data) )
     {
         enumerator->found = GL_TRUE;
         enumerator->data = window;
@@ -488,7 +489,8 @@
 
     /* This is easy and makes use of the windows enumeration defined above */
     enumerator.found = GL_FALSE;
-    enumerator.data = (void *)hWindow;
+    //enumerator.data = (void *)hWindow;
+    enumerator.data = hWindow.ptr;
     fgEnumWindows( fghcbWindowByHandle, &enumerator );
 
     if( enumerator.found )
--- ./src/fg_window.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/fg_window.c	2023-09-16 15:20:35.246001000 +0200
@@ -50,14 +50,14 @@
  */
 
 
-extern void fgPlatformSetWindow ( SFG_Window *window );
-extern void fgPlatformOpenWindow( SFG_Window* window, const char* title,
+/* extern void fgPlatform->SetWindow ( SFG_Window *window ); */
+/* extern void fgPlatform->OpenWindow( SFG_Window* window, const char* title,
                                   GLboolean positionUse, int x, int y,
                                   GLboolean sizeUse, int w, int h,
-                                  GLboolean gameMode, GLboolean isSubWindow );
-extern void fgPlatformCloseWindow( SFG_Window* window );
-extern void fgPlatformGlutSetWindowTitle( const char* title );
-extern void fgPlatformGlutSetIconTitle( const char* title );
+                                  GLboolean gameMode, GLboolean isSubWindow );*/
+/* extern void fgPlatform->CloseWindow( SFG_Window* window ); */
+/* extern void fgPlatform->GlutSetWindowTitle( const char* title ); */
+/* extern void fgPlatform->GlutSetIconTitle( const char* title ); */
 
 
 /* -- PRIVATE FUNCTIONS ---------------------------------------------------- */
@@ -112,7 +112,7 @@
  */
 void fgSetWindow ( SFG_Window *window )
 {
-    fgPlatformSetWindow ( window );
+    fgPlatform->SetWindow ( window );
 
     fgStructure.CurrentWindow = window;
 }
@@ -126,7 +126,7 @@
                    GLboolean sizeUse, int w, int h,
                    GLboolean gameMode, GLboolean isSubWindow )
 {
-    fgPlatformOpenWindow( window, title,
+    fgPlatform->OpenWindow( window, title,
                           positionUse, x, y,
                           sizeUse, w, h,
                           gameMode, isSubWindow );
@@ -168,7 +168,7 @@
     if (fgStructure.GameModeWindow != NULL && fgStructure.GameModeWindow->ID==window->ID)
         glutLeaveGameMode();
 
-    fgPlatformCloseWindow ( window );
+    fgPlatform->CloseWindow ( window );
 }
 
 
@@ -187,7 +187,7 @@
      */
     FREEGLUT_EXIT_IF_NOT_INITIALISED ( "glutCreateWindow" );
 
-    return fgCreateWindow( NULL, title, 
+    return fgCreateWindow( NULL, title,
                            fgState.Position.Use, fgState.Position.X, fgState.Position.Y,
                            fgState.Size.Use, fgState.Size.X, fgState.Size.Y,
                            GL_FALSE, GL_FALSE )->ID;
@@ -246,9 +246,9 @@
         }
     }
 
-    window = fgCreateWindow( parent, "", 
-                             GL_TRUE, x, y, 
-                             GL_TRUE, w, h, 
+    window = fgCreateWindow( parent, "",
+                             GL_TRUE, x, y,
+                             GL_TRUE, w, h,
                              GL_FALSE, GL_FALSE );
     ret = window->ID;
 
@@ -363,7 +363,7 @@
     FREEGLUT_EXIT_IF_NO_WINDOW ( "glutSetWindowTitle" );
     if( ! fgStructure.CurrentWindow->Parent )
     {
-        fgPlatformGlutSetWindowTitle ( title );
+        fgPlatform->GlutSetWindowTitle ( title );
     }
 }
 
@@ -377,7 +377,7 @@
 
     if( ! fgStructure.CurrentWindow->Parent )
     {
-        fgPlatformGlutSetIconTitle ( title );
+        fgPlatform->GlutSetIconTitle ( title );
     }
 }
 
--- ./src/wayland/fg_cursor_wl.c.orig	2023-09-27 13:31:29.754000000 +0200
+++ ./src/wayland/fg_cursor_wl.c	2023-09-18 16:13:21.306158281 +0200
@@ -28,6 +28,7 @@
 #include <string.h>
 #include <GL/freeglut.h>
 #include "../fg_internal.h"
+#include "fg_private_wl.h"
 
 /*
  * Note: The arrangement of the table below depends on the fact that
@@ -56,7 +57,7 @@
     "bottom_left_corner"    /* GLUT_CURSOR_BOTTOM_LEFT_CORNER */
 };
 
-void fgPlatformSetCursor ( SFG_Window *window, int cursorID )
+void fgPlatformSetCursor_WL ( SFG_Window *window, int cursorID )
 {
     /*
      * XXX FULL_CROSSHAIR demotes to plain CROSSHAIR. Old GLUT allows
@@ -111,13 +112,17 @@
 }
 
 
-void fgPlatformWarpPointer ( int x, int y )
+void fgPlatformWarpPointer_WL ( int x, int y )
 {
+    static int warned = 0;
     /* unsupported under Wayland */
-    fgWarning( "glutWarpPointer(): function unsupported under Wayland" );
+    if (!warned) {
+        fgWarning( "glutWarpPointer(): function unsupported under Wayland" );
+        warned = 1;
+    }
 }
 
-void fghPlatformGetCursorPos(const SFG_Window *window, GLboolean client, SFG_XYUse *mouse_pos)
+void fghPlatformGetCursorPos_WL(const SFG_Window *window, GLboolean client, SFG_XYUse *mouse_pos)
 {
     /* Get current pointer location relative to top-left of client area of window (if client is true and window is not NULL)
      * We cannot get current pointer location in screen coordinates under Wayland, so inform the user and return -1 is this case
--- ./src/wayland/fg_ext_wl.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/wayland/fg_ext_wl.c	2023-09-16 12:54:46.094001000 +0200
@@ -29,7 +29,7 @@
 #include <GL/freeglut.h>
 #include "../fg_internal.h"
 
-GLUTproc fgPlatformGetGLUTProcAddress( const char* procName )
+GLUTproc fgPlatformGetGLUTProcAddress_WL( const char* procName )
 {
     /* optimization: quick initial check */
     if( strncmp( procName, "glut", 4 ) != 0 )
--- ./src/wayland/fg_gamemode_wl.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/wayland/fg_gamemode_wl.c	2023-09-21 01:13:19.707000000 +0200
@@ -27,6 +27,7 @@
 
 #include <GL/freeglut.h>
 #include "../fg_internal.h"
+#include "fg_private_wl.h"
 
 /* Pointer locking is a Weston-specific WIP protocol (for now)
  *
@@ -60,13 +61,13 @@
  * static void fghLockedLocked( void* data, struct _wl_locked_pointer
  *                              pointer, uint32_t serial )
  * {
- *     fgPlatformRememberState();
- *     fgPlatformSetCursor( win, GLUT_CURSOR_NONE ):
+ *     fgPlatformRememberState_WL();
+ *     fgPlatformSetCursor_WL( win, GLUT_CURSOR_NONE ):
  * }
  * static void fghLockedUnlocked( void* data, struct _wl_locked_pointer
  *                                pointer )
  * {
- *     fgPlatformRestoreState();
+ *     fgPlatformRestoreState_WL();
  * }
  * static const struct _wl_locked_pointer_listener
  *                                 fghLockedListener =
@@ -77,31 +78,33 @@
  */
 
 
-static struct wl_cursor* saved_cursor;
+static struct wl_cursor* saved_cursor = NULL;
 
 /*
  * Remembers the current visual settings, so that
  * we can change them and restore later...
  */
-void fgPlatformRememberState( void )
+void fgPlatformRememberState_WL( void )
 {
     SFG_Window* win = fgStructure.CurrentWindow;
-    saved_cursor = win->Window.pContext.cursor;
+    if (win)
+      saved_cursor = win->Window.pContext.cursor;
 }
 
 /*
  * Restores the previously remembered visual settings
  */
-void fgPlatformRestoreState( void )
+void fgPlatformRestoreState_WL( void )
 {
     SFG_Window* win = fgStructure.CurrentWindow;
-    win->Window.pContext.cursor = saved_cursor;
+    if (win)
+      win->Window.pContext.cursor = saved_cursor;
 }
 
 /*
  *  * Private function to get the virtual maximum screen extent
  *   */
-GLvoid fgPlatformGetGameModeVMaxExtent( SFG_Window* window, int* x, int* y )
+GLvoid fgPlatformGetGameModeVMaxExtent_WL( SFG_Window* window, int* x, int* y )
 {
     /*
      * under Wayland, just return the size of the window,
@@ -114,14 +117,16 @@
 /*
  * Changes the current display mode to match user's settings
  */
-GLboolean fgPlatformChangeDisplayMode( GLboolean haveToTest )
+GLboolean fgPlatformChangeDisplayMode_WL( GLboolean haveToTest )
 {
     /* Such a protocol is being studied in Wayland */
-    return GL_FALSE;
+    //return GL_FALSE;
+    // ok, in the mean time i'll return true because results are better
+    return GL_TRUE;
 }
 
 
-void fgPlatformEnterGameMode( void )
+void fgPlatformEnterGameMode_WL( void )
 {
     SFG_Window* win = fgStructure.CurrentWindow;
     struct wl_region* region;
@@ -131,6 +136,7 @@
     wl_region_add( region, 0, 0,
                    win->State.Width,
                    win->State.Height );
+
    /*
     * relative_pointer =
     *      _wl_relative_pointer_manager_get_relative_pointer (
@@ -148,12 +154,17 @@
     *                                  &fghLockedListener,
     *                                  NULL );
     */
+
+    wl_shell_surface_set_fullscreen( win->Window.pContext.shsurface,
+                                       WL_SHELL_SURFACE_FULLSCREEN_METHOD_DEFAULT,
+                                       0, NULL );
+
     wl_region_destroy( region );
 }
 
-void fgPlatformLeaveGameMode( void )
+void fgPlatformLeaveGameMode_WL( void )
 {
-   /* 
+   /*
     * _wl_locked_pointer_destroy( locked_pointer );
     * _wl_relative_pointer_release( relative_pointer );
     */
--- ./src/wayland/fg_init_wl.c.orig	2023-09-27 13:31:29.754000000 +0200
+++ ./src/wayland/fg_init_wl.c	2023-09-21 17:42:07.328514000 +0200
@@ -30,10 +30,117 @@
 #include <GL/freeglut.h>
 #include "fg_internal.h"
 #include "egl/fg_init_egl.h"
+#include "fg_private_wl.h"
+#include "fg_lib_syms_wl.h"
+#include "fg_lib_syms_xkb.h"
+
+void fgPlatformInitialiseInputDevices_WL( void );
+void fgPlatformCloseInputDevices_WL( void );
+extern fg_time_t fgPlatformSystemTime_WL ( void );
+extern GLboolean fgPlatformChangeDisplayMode_WL ( GLboolean haveToTest );
+extern GLUTproc fgPlatformGetGLUTProcAddress_WL ( const char *procName );
+extern GLvoid fgPlatformGetGameModeVMaxExtent_WL ( SFG_Window* window, int* x, int* y );
+extern int fgPlatformGlutDeviceGet_WL ( GLenum eWhat );
+extern int fgPlatformGlutGet_WL ( GLenum eWhat );
+extern int *fgPlatformGlutGetModeValues_EGL (GLenum eWhat, int *size);
+extern int fgPlatformHasSpaceball_WL (void);
+extern int fgPlatformSpaceballNumButtons_WL (void);
+extern SFG_Proc fgPlatformGetProcAddress_EGL ( const char *procName );
+extern void fgPlatformCloseDisplay_WL ( void );
+extern void fgPlatformCloseWindow_WL ( SFG_Window* window );
+extern void fgPlatformCreateWindow_WL ( SFG_Window *window );
+extern void fgPlatformDeinitialiseInputDevices_WL ( void );
+extern void fgPlatformDestroyContext_EGL ( SFG_Display * Display, SFG_WindowContextType context );
+extern void fgPlatformEnterGameMode_WL ( void );
+extern void fgPlatformGlutSetIconTitle_WL ( const char* title );
+extern void fgPlatformGlutSetWindowTitle_WL ( const char* title );
+extern void fgPlatformGlutSwapBuffers_EGL ( SFG_Display * Display, SFG_Window* CurrentWindow );
+extern void fgPlatformHideWindow_WL ( SFG_Window* window );
+extern void fgPlatformInitialize_WL ( const char* displayName );
+extern void fgPlatformInitializeSpaceball_WL (void);
+extern void fgPlatformInitWork_WL (SFG_Window* window);
+extern void fgPlatformJoystickClose_X11 ( int ident );
+extern void fgPlatformJoystickInit_X11 ( SFG_Joystick *fgJoystick[], int ident );
+extern void fgPlatformJoystickOpen_X11 ( SFG_Joystick* joy );
+extern void fgPlatformJoystickRawRead_X11 ( SFG_Joystick* joy, int* buttons, float* axes );
+extern void fgPlatformLeaveGameMode_WL ( void );
+extern void fgPlatformMainLoopPreliminaryWork_WL ( void );
+extern void fgPlatformOpenWindow_WL ( SFG_Window* window, const char* title,
+                                      GLboolean positionUse, int x, int y,
+                                      GLboolean sizeUse, int w, int h,
+                                      GLboolean gameMode, GLboolean isSubWindow);
+extern void fgPlatformPosResZordWork_WL (SFG_Window* window, unsigned int workMask);
+extern void fgPlatformProcessSingleEvent_WL ( void );
+extern void fgPlatformRegisterDialDevice_X11 ( const char *dial_device );
+extern void fgPlatformRememberState_WL ( void );
+extern void fgPlatformRestoreState_WL ( void );
+extern void fgPlatformSetCursor_WL ( SFG_Window *window, int cursorID );
+extern void fgPlatformSetWindow_EGL ( SFG_Window *window );
+extern void fgPlatformSleepForEvents_WL ( fg_time_t msec );
+extern void fgPlatformSpaceballClose_WL (void);
+extern void fgPlatformSpaceballSetWindow_WL (SFG_Window *window);
+extern void fgPlatformVisibilityWork_WL (SFG_Window* window);
+extern void fgPlatformWarpPointer_WL ( int x, int y );
+extern void fgPlatformSetColor_WL ( int idx, float r, float g, float b );
+extern float fgPlatformGetColor_WL ( int idx, int comp );
+extern void fgPlatformCopyColormap_WL ( int win );
+extern void fghPlatformGetCursorPos_WL(const SFG_Window *window, GLboolean client, SFG_XYUse *mouse_pos);
+extern int fghPlatformChooseConfig_EGL(void * vdata);
+
+SFG_Platform fgPlatform_WL = {
+    "wayland",
+    GLUT_DISPLAY_WAYLAND,
+
+    fgPlatformSystemTime_WL,
+    fgPlatformChangeDisplayMode_WL,
+    fgPlatformGetGLUTProcAddress_WL,
+    fgPlatformGetGameModeVMaxExtent_WL,
+    fgPlatformGlutDeviceGet_WL,
+    fgPlatformGlutGet_WL,
+    fgPlatformGlutGetModeValues_EGL,
+    fgPlatformHasSpaceball_WL,
+    fgPlatformSpaceballNumButtons_WL,
+    fgPlatformGetProcAddress_EGL,
+    fgPlatformCloseDisplay_WL,
+    fgPlatformCloseWindow_WL,
+    fgPlatformCreateWindow_WL,
+    fgPlatformDeinitialiseInputDevices_WL,
+    fgPlatformDestroyContext_EGL,
+    fgPlatformEnterGameMode_WL,
+    fgPlatformGlutSetIconTitle_WL,
+    fgPlatformGlutSetWindowTitle_WL,
+    fgPlatformGlutSwapBuffers_EGL,
+    fgPlatformHideWindow_WL,
+    fgPlatformInitialize_WL,
+    fgPlatformInitializeSpaceball_WL,
+    fgPlatformInitWork_WL,
+    fgPlatformJoystickClose_X11,
+    fgPlatformJoystickInit_X11,
+    fgPlatformJoystickOpen_X11,
+    fgPlatformJoystickRawRead_X11,
+    fgPlatformLeaveGameMode_WL,
+    fgPlatformMainLoopPreliminaryWork_WL,
+    fgPlatformOpenWindow_WL,
+    fgPlatformPosResZordWork_WL,
+    fgPlatformProcessSingleEvent_WL,
+    fgPlatformRegisterDialDevice_X11,
+    fgPlatformRememberState_WL,
+    fgPlatformRestoreState_WL,
+    fgPlatformSetCursor_WL,
+    fgPlatformSetWindow_EGL,
+    fgPlatformSleepForEvents_WL,
+    fgPlatformSpaceballClose_WL,
+    fgPlatformSpaceballSetWindow_WL,
+    fgPlatformVisibilityWork_WL,
+    fgPlatformWarpPointer_WL,
+    fgPlatformSetColor_WL,
+    fgPlatformGetColor_WL,
+    fgPlatformCopyColormap_WL,
+    fghPlatformGetCursorPos_WL,
+};
 
-void fgPlatformInitialiseInputDevices( void );
-void fgPlatformCloseInputDevices( void );
 
+#define MIN(a,b) ((b) < (a) ? (b) : (a))
 
 static void fghRegistryGlobal( void* data,
                                struct wl_registry* registry,
@@ -41,20 +148,20 @@
                                const char* interface,
                                uint32_t version )
 {
-    SFG_PlatformDisplay* pDisplay = data;
+    SFG_PlatformDisplay * display = data;
 
     if ( ! strcmp( interface, "wl_compositor" ) )
-      pDisplay->compositor = wl_registry_bind ( registry, id,
-                                                &wl_compositor_interface, 1 );
+      display->compositor = wl_registry_bind ( registry, id,
+                                               &wl_compositor_interface, 1 );
     else if ( ! strcmp( interface, "wl_shell" ) )
-      pDisplay->shell = wl_registry_bind ( registry, id,
-                                           &wl_shell_interface, 1 );
+      display->shell = wl_registry_bind ( registry, id,
+                                          &wl_shell_interface, 1 );
     else if ( ! strcmp( interface, "wl_seat" ) )
-      pDisplay->seat = wl_registry_bind ( registry, id,
-                                          &wl_seat_interface, 1 );
+      display->seat = wl_registry_bind ( registry, id,
+                                         &wl_seat_interface, 1); //MIN(version, 4)); //1 );
     else if ( ! strcmp( interface, "wl_shm" ) )
-      pDisplay->shm = wl_registry_bind ( registry, id,
-                                         &wl_shm_interface, 1 );
+      display->shm = wl_registry_bind ( registry, id,
+                                        &wl_shm_interface, 1 );
 }
 static void fghRegistryGlobalRemove( void* data,
                                      struct wl_registry* registry,
@@ -77,29 +184,49 @@
         fgError( "Failed to load wl cursor theme" );
 };
 
-void fgPlatformInitialize( const char* displayName )
+void fgPlatformInitialize_WL( const char* displayName )
 {
+    if (fg_wl_lib_init() != 0 || fg_xkb_lib_init() != 0) {
+        fgWarning( "cannot load wayland library" );
+        return ;
+    }
+
     fgDisplay.pDisplay.display = wl_display_connect( NULL );
 
-    if( fgDisplay.pDisplay.display == NULL )
-        fgError( "failed to connect to a Wayland compositor" );
+    if( fgDisplay.pDisplay.display == NULL ) {
+        fgWarning( "failed to connect to a Wayland compositor" );
+        return ;
+    }
+
+    fgDisplay.pDisplay.cursor_theme = NULL;
+    fgDisplay.pDisplay.compositor = NULL;
+    fgDisplay.pDisplay.shell = NULL;
+    fgDisplay.pDisplay.seat = NULL;
+    fgDisplay.pDisplay.shm = NULL;
 
     fgDisplay.pDisplay.registry = wl_display_get_registry(
                                     fgDisplay.pDisplay.display );
-    wl_registry_add_listener( fgDisplay.pDisplay.registry,
-                              &fghRegistryListener,
-                              &fgDisplay.pDisplay );
-    wl_display_roundtrip( fgDisplay.pDisplay.display );
+    if (fgDisplay.pDisplay.registry) {
+      wl_registry_add_listener( fgDisplay.pDisplay.registry,
+                                &fghRegistryListener,
+                                &fgDisplay.pDisplay );
+      wl_display_roundtrip( fgDisplay.pDisplay.display );
+    }
 
     if( fgDisplay.pDisplay.compositor == NULL ||
         fgDisplay.pDisplay.shell == NULL ||
         fgDisplay.pDisplay.seat == NULL ||
-        fgDisplay.pDisplay.shm == NULL )
-          fgError( "failed to discover all needed compositor interfaces" );
-
+        fgDisplay.pDisplay.shm == NULL ) {
+          fgWarning( "failed to discover all needed compositor interfaces" );
+          fgPlatformCloseDisplay_WL();
+          return ;
+    }
     fghInitialiseCursorTheme();
 
-    fghPlatformInitializeEGL();
+    if (fghPlatformInitializeEGL((EGLNativeDisplayType)fgDisplay.pDisplay.display) < 0) {
+        fgPlatformCloseDisplay_WL();
+        return ;
+    }
 
     /* Get start time */
     fgState.Time = fgSystemTime();
@@ -109,28 +236,35 @@
     atexit(fgDeinitialize);
 
     /* InputDevice uses GlutTimerFunc(), so fgState.Initialised must be TRUE */
-    fgPlatformInitialiseInputDevices();
+    fgPlatformInitialiseInputDevices_WL();
 }
 
 
-void fgPlatformDeinitialiseInputDevices ( void )
+void fgPlatformDeinitialiseInputDevices_WL ( void )
 {
-    fgPlatformCloseInputDevices();
+    fgPlatformCloseInputDevices_WL();
 
     fgState.InputDevsInitialised = GL_FALSE;
 }
 
 
-void fgPlatformCloseDisplay ( void )
+void fgPlatformCloseDisplay_WL ( void )
 {
-    wl_cursor_theme_destroy( fgDisplay.pDisplay.cursor_theme );
+    if (fgDisplay.pDisplay.cursor_theme)
+      wl_cursor_theme_destroy( fgDisplay.pDisplay.cursor_theme );
 
-    wl_shm_destroy( fgDisplay.pDisplay.shm );
-    wl_seat_destroy( fgDisplay.pDisplay.seat );
-    wl_shell_destroy( fgDisplay.pDisplay.shell );
-    wl_compositor_destroy( fgDisplay.pDisplay.compositor );
-    wl_registry_destroy( fgDisplay.pDisplay.registry );
+    if (fgDisplay.pDisplay.shm)
+        wl_shm_destroy( fgDisplay.pDisplay.shm );
+    if (fgDisplay.pDisplay.seat)
+      wl_seat_destroy( fgDisplay.pDisplay.seat );
+    if (fgDisplay.pDisplay.shell)
+      wl_shell_destroy( fgDisplay.pDisplay.shell );
+    if (fgDisplay.pDisplay.compositor)
+      wl_compositor_destroy( fgDisplay.pDisplay.compositor );
+    if (fgDisplay.pDisplay.registry)
+      wl_registry_destroy( fgDisplay.pDisplay.registry );
 
-    wl_display_disconnect( fgDisplay.pDisplay.display );
+    if (fgDisplay.pDisplay.display)
+      wl_display_disconnect( fgDisplay.pDisplay.display );
 }
 
--- ./src/wayland/fg_input_devices_wl.c.orig	2023-09-27 13:31:29.758000000 +0200
+++ ./src/wayland/fg_input_devices_wl.c	2023-09-26 19:18:10.815005000 +0200
@@ -36,6 +36,7 @@
 #include <sys/mman.h>
 #include <GL/freeglut.h>
 #include "../fg_internal.h"
+#include "fg_private_wl.h"
 
 unsigned int fgPlatformGetModifiers_WL() {
     unsigned int mods = 0;
@@ -542,7 +543,7 @@
 /*
  * Try closing the input device(s)
  */
-void fgPlatformCloseInputDevices( void )
+void fgPlatformCloseInputDevices_WL( void )
 {
     if( fgDisplay.pDisplay.touch )
       wl_touch_destroy( fgDisplay.pDisplay.touch );
@@ -560,20 +561,20 @@
 /*
  * Wayland backend will not be implementing spaceball at all
  */
-void fgPlatformInitializeSpaceball( void )
+void fgPlatformInitializeSpaceball_WL( void )
 {
 }
-void fgPlatformSpaceballClose( void )
+void fgPlatformSpaceballClose_WL( void )
 {
 }
-void fgPlatformSpaceballSetWindow( SFG_Window *window )
+void fgPlatformSpaceballSetWindow_WL( SFG_Window *window )
 {
 }
-int fgPlatformHasSpaceball( void )
+int fgPlatformHasSpaceball_WL( void )
 {
     return 0;
 }
-int fgPlatformSpaceballNumButtons( void )
+int fgPlatformSpaceballNumButtons_WL( void )
 {
     return 0;
 }
--- ./src/wayland/fg_internal_wl.h.orig	2023-09-27 13:31:29.758000000 +0200
+++ ./src/wayland/fg_internal_wl.h	2023-09-21 17:46:42.834197998 +0200
@@ -30,6 +30,9 @@
 
 
 /* -- PLATFORM-SPECIFIC INCLUDES ------------------------------------------- */
+#include "fg_lib_defs_wl.h"
+#include "fg_lib_defs_xkb.h"
+#include "egl/fg_lib_defs_egl.h"
 #include "egl/fg_internal_egl.h"
 #include <wayland-egl.h>
 #include <wayland-client.h>
@@ -52,11 +55,9 @@
 
 /* -- GLOBAL TYPE DEFINITIONS ---------------------------------------------- */
 /* The structure used by display initialization in fg_init.c */
-typedef struct tagSFG_PlatformDisplay SFG_PlatformDisplay;
-struct tagSFG_PlatformDisplay
+typedef struct tagSFG_PlatformDisplay_WL SFG_PlatformDisplay_WL;
+struct tagSFG_PlatformDisplay_WL
 {
-    struct tagSFG_PlatformDisplayEGL egl;
-
     struct wl_display* display;        /* The display we are being run in    */
     struct wl_registry* registry;      /* The global interface registry      */
     struct wl_compositor* compositor;  /* The compositor                     */
@@ -77,10 +78,9 @@
 
 
 /* The structure used by window creation in fg_window.c */
-typedef struct tagSFG_PlatformContext SFG_PlatformContext;
-struct tagSFG_PlatformContext
+typedef struct tagSFG_PlatformContext_WL SFG_PlatformContext_WL;
+struct tagSFG_PlatformContext_WL
 {
-    struct tagSFG_PlatformContextEGL egl;
     GLboolean pointer_button_pressed;
 
     struct wl_surface* surface;            /* The drawing surface             */
@@ -93,8 +93,8 @@
 
 
 /* The window state description. This structure should be kept portable. */
-typedef struct tagSFG_PlatformWindowState SFG_PlatformWindowState;
-struct tagSFG_PlatformWindowState
+typedef struct tagSFG_PlatformWindowState_WL SFG_PlatformWindowState_WL;
+struct tagSFG_PlatformWindowState_WL
 {
     int OldWidth;                        /* Window width from before a resize */
     int OldHeight;                       /*   "    height  "    "    "   "    */
@@ -157,8 +157,8 @@
  * XXX axes and then dynamically allocate the arrays.
  */
 #    define _JS_MAX_AXES 16
-typedef struct tagSFG_PlatformJoystick SFG_PlatformJoystick;
-struct tagSFG_PlatformJoystick
+typedef struct tagSFG_PlatformJoystick_WL SFG_PlatformJoystick_WL;
+struct tagSFG_PlatformJoystick_WL
 {
 #   if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__)
        struct os_specific_s *os;
--- ./src/wayland/fg_lib_defs_wl.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./src/wayland/fg_lib_defs_wl.h	2023-09-19 21:19:23.035227422 +0200
@@ -0,0 +1,40 @@
+/* GENERATED FILE: fg_lib_defs_wl.h */
+#ifndef FREEGLUT_LIB_DEFS_WL_H
+#define FREEGLUT_LIB_DEFS_WL_H
+
+#ifndef FG_WL_SO_NAME
+#else
+
+#define wl_compositor_interface              (*fg_wl_compositor_interface)
+#define wl_cursor_image_get_buffer           (*fg_wl_cursor_image_get_buffer)
+#define wl_cursor_theme_destroy              (*fg_wl_cursor_theme_destroy)
+#define wl_cursor_theme_get_cursor           (*fg_wl_cursor_theme_get_cursor)
+#define wl_cursor_theme_load                 (*fg_wl_cursor_theme_load)
+#define wl_display_connect                   (*fg_wl_display_connect)
+#define wl_display_disconnect                (*fg_wl_display_disconnect)
+#define wl_display_dispatch_pending          (*fg_wl_display_dispatch_pending)
+#define wl_display_flush                     (*fg_wl_display_flush)
+#define wl_display_get_fd                    (*fg_wl_display_get_fd)
+#define wl_display_roundtrip                 (*fg_wl_display_roundtrip)
+#define wl_egl_window_create                 (*fg_wl_egl_window_create)
+#define wl_egl_window_destroy                (*fg_wl_egl_window_destroy)
+#define wl_egl_window_resize                 (*fg_wl_egl_window_resize)
+#define wl_keyboard_interface                (*fg_wl_keyboard_interface)
+#define wl_pointer_interface                 (*fg_wl_pointer_interface)
+#define wl_proxy_add_listener                (*fg_wl_proxy_add_listener)
+#define wl_proxy_destroy                     (*fg_wl_proxy_destroy)
+#define wl_proxy_marshal                     (*fg_wl_proxy_marshal)
+#define wl_proxy_marshal_constructor         (*fg_wl_proxy_marshal_constructor)
+#define wl_proxy_marshal_constructor_versioned (*fg_wl_proxy_marshal_constructor_versioned)
+#define wl_region_interface                  (*fg_wl_region_interface)
+#define wl_registry_interface                (*fg_wl_registry_interface)
+#define wl_seat_interface                    (*fg_wl_seat_interface)
+#define wl_shell_interface                   (*fg_wl_shell_interface)
+#define wl_shell_surface_interface           (*fg_wl_shell_surface_interface)
+#define wl_shm_interface                     (*fg_wl_shm_interface)
+#define wl_surface_interface                 (*fg_wl_surface_interface)
+#define wl_touch_interface                   (*fg_wl_touch_interface)
+
+#endif /* ! ifndef FG_WL_SO_NAME */
+#endif /* ! ifndef FREEGLUT_LIB_DEFS_WL_H */
+
--- ./src/wayland/fg_lib_defs_xkb.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./src/wayland/fg_lib_defs_xkb.h	2023-09-19 21:19:29.450433423 +0200
@@ -0,0 +1,21 @@
+/* GENERATED FILE: fg_lib_defs_xkb.h */
+#ifndef FREEGLUT_LIB_DEFS_XKB_H
+#define FREEGLUT_LIB_DEFS_XKB_H
+
+#ifndef FG_XKB_SO_NAME
+#else
+
+#define xkb_context_new                      (*fg_xkb_context_new)
+#define xkb_context_unref                    (*fg_xkb_context_unref)
+#define xkb_keymap_mod_get_index             (*fg_xkb_keymap_mod_get_index)
+#define xkb_keymap_new_from_string           (*fg_xkb_keymap_new_from_string)
+#define xkb_keysym_to_utf8                   (*fg_xkb_keysym_to_utf8)
+#define xkb_state_key_get_syms               (*fg_xkb_state_key_get_syms)
+#define xkb_state_mod_index_is_active        (*fg_xkb_state_mod_index_is_active)
+#define xkb_state_new                        (*fg_xkb_state_new)
+#define xkb_state_unref                      (*fg_xkb_state_unref)
+#define xkb_state_update_mask                (*fg_xkb_state_update_mask)
+
+#endif /* ! ifndef FG_XKB_SO_NAME */
+#endif /* ! ifndef FREEGLUT_LIB_DEFS_XKB_H */
+
--- ./src/wayland/fg_lib_syms_wl.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./src/wayland/fg_lib_syms_wl.h	2023-09-19 21:19:27.785601422 +0200
@@ -0,0 +1,89 @@
+/* GENERATED FILE: fg_lib_syms_wl.h */
+#ifndef FREEGLUT_LIB_SYMS_WL_H
+#define FREEGLUT_LIB_SYMS_WL_H
+
+#include "config.h"
+#ifndef FG_WL_SO_NAME
+int fg_wl_lib_init();
+void fg_wl_lib_destroy();
+#else
+
+#define FREEGLUT_BUILDING_LIB
+#include <GL/freeglut.h>
+#include "fg_internal.h"
+
+typedef  const struct wl_interface * fg_wl_compositor_interface_fun;
+typedef   struct wl_buffer * (*fg_wl_cursor_image_get_buffer_fun)(struct wl_cursor_image *image);
+typedef   void           (*fg_wl_cursor_theme_destroy_fun)(struct wl_cursor_theme *theme);
+typedef   struct wl_cursor * (*fg_wl_cursor_theme_get_cursor_fun)(struct wl_cursor_theme *theme, const char *name);
+typedef   struct wl_cursor_theme * (*fg_wl_cursor_theme_load_fun)(const char *name, int size, struct wl_shm *shm);
+typedef   struct wl_display * (*fg_wl_display_connect_fun)(const char *name);
+typedef   void           (*fg_wl_display_disconnect_fun)(struct wl_display *display);
+typedef   int            (*fg_wl_display_dispatch_pending_fun)(struct wl_display *display);
+typedef   int            (*fg_wl_display_flush_fun)(struct wl_display *display);
+typedef   int            (*fg_wl_display_get_fd_fun)(struct wl_display *display);
+typedef   int            (*fg_wl_display_roundtrip_fun)(struct wl_display *display);
+typedef   struct wl_egl_window * (*fg_wl_egl_window_create_fun)(struct wl_surface *surface, int width, int height);
+typedef   void           (*fg_wl_egl_window_destroy_fun)(struct wl_egl_window *egl_window);
+typedef   void           (*fg_wl_egl_window_resize_fun)(struct wl_egl_window *egl_window, int width, int height, int dx, int dy);
+typedef  const struct wl_interface * fg_wl_keyboard_interface_fun;
+typedef  const struct wl_interface * fg_wl_pointer_interface_fun;
+typedef   int            (*fg_wl_proxy_add_listener_fun)(struct wl_proxy *proxy, void (**implementation)(void), void *data);
+typedef   void           (*fg_wl_proxy_destroy_fun)(struct wl_proxy *proxy);
+typedef   void           (*fg_wl_proxy_marshal_fun)(struct wl_proxy *p, uint32_t opcode, ...);
+typedef   struct wl_proxy * (*fg_wl_proxy_marshal_constructor_fun)(struct wl_proxy *proxy, uint32_t opcode, const struct wl_interface *interface, ...);
+typedef   struct wl_proxy * (*fg_wl_proxy_marshal_constructor_versioned_fun)(struct wl_proxy *proxy, uint32_t opcode, const struct wl_interface *interface, uint32_t version, ...);
+typedef  const struct wl_interface * fg_wl_region_interface_fun;
+typedef  const struct wl_interface * fg_wl_registry_interface_fun;
+typedef  const struct wl_interface * fg_wl_seat_interface_fun;
+typedef  const struct wl_interface * fg_wl_shell_interface_fun;
+typedef  const struct wl_interface * fg_wl_shell_surface_interface_fun;
+typedef  const struct wl_interface * fg_wl_shm_interface_fun;
+typedef  const struct wl_interface * fg_wl_surface_interface_fun;
+typedef  const struct wl_interface * fg_wl_touch_interface_fun;
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern fg_wl_compositor_interface_fun       fg_wl_compositor_interface;
+extern fg_wl_cursor_image_get_buffer_fun    fg_wl_cursor_image_get_buffer;
+extern fg_wl_cursor_theme_destroy_fun       fg_wl_cursor_theme_destroy;
+extern fg_wl_cursor_theme_get_cursor_fun    fg_wl_cursor_theme_get_cursor;
+extern fg_wl_cursor_theme_load_fun          fg_wl_cursor_theme_load;
+extern fg_wl_display_connect_fun            fg_wl_display_connect;
+extern fg_wl_display_disconnect_fun         fg_wl_display_disconnect;
+extern fg_wl_display_dispatch_pending_fun   fg_wl_display_dispatch_pending;
+extern fg_wl_display_flush_fun              fg_wl_display_flush;
+extern fg_wl_display_get_fd_fun             fg_wl_display_get_fd;
+extern fg_wl_display_roundtrip_fun          fg_wl_display_roundtrip;
+extern fg_wl_egl_window_create_fun          fg_wl_egl_window_create;
+extern fg_wl_egl_window_destroy_fun         fg_wl_egl_window_destroy;
+extern fg_wl_egl_window_resize_fun          fg_wl_egl_window_resize;
+extern fg_wl_keyboard_interface_fun         fg_wl_keyboard_interface;
+extern fg_wl_pointer_interface_fun          fg_wl_pointer_interface;
+extern fg_wl_proxy_add_listener_fun         fg_wl_proxy_add_listener;
+extern fg_wl_proxy_destroy_fun              fg_wl_proxy_destroy;
+extern fg_wl_proxy_marshal_fun              fg_wl_proxy_marshal;
+extern fg_wl_proxy_marshal_constructor_fun  fg_wl_proxy_marshal_constructor;
+extern fg_wl_proxy_marshal_constructor_versioned_fun fg_wl_proxy_marshal_constructor_versioned;
+extern fg_wl_region_interface_fun           fg_wl_region_interface;
+extern fg_wl_registry_interface_fun         fg_wl_registry_interface;
+extern fg_wl_seat_interface_fun             fg_wl_seat_interface;
+extern fg_wl_shell_interface_fun            fg_wl_shell_interface;
+extern fg_wl_shell_surface_interface_fun    fg_wl_shell_surface_interface;
+extern fg_wl_shm_interface_fun              fg_wl_shm_interface;
+extern fg_wl_surface_interface_fun          fg_wl_surface_interface;
+extern fg_wl_touch_interface_fun            fg_wl_touch_interface;
+
+int     fg_wl_lib_init();
+void    fg_wl_lib_destroy();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ! ifdef FG_WL_SO_NAME */
+#endif /* ! ifdef FREEGLUT_LIB_SYMS_WL_H */
+
--- ./src/wayland/fg_lib_syms_xkb.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./src/wayland/fg_lib_syms_xkb.h	2023-09-19 21:19:31.023219422 +0200
@@ -0,0 +1,51 @@
+/* GENERATED FILE: fg_lib_syms_xkb.h */
+#ifndef FREEGLUT_LIB_SYMS_XKB_H
+#define FREEGLUT_LIB_SYMS_XKB_H
+
+#include "config.h"
+#ifndef FG_XKB_SO_NAME
+int fg_xkb_lib_init();
+void fg_xkb_lib_destroy();
+#else
+
+#define FREEGLUT_BUILDING_LIB
+#include <GL/freeglut.h>
+#include "fg_internal.h"
+
+typedef  struct xkb_context * (*fg_xkb_context_new_fun)(enum xkb_context_flags flags);
+typedef  void            (*fg_xkb_context_unref_fun)(struct xkb_context *context);
+typedef  xkb_mod_index_t (*fg_xkb_keymap_mod_get_index_fun)(struct xkb_keymap *keymap, const char *name);
+typedef  struct xkb_keymap * (*fg_xkb_keymap_new_from_string_fun)(struct xkb_context *context, const char *string, enum xkb_keymap_format format, enum xkb_keymap_compile_flags flags);
+typedef  int             (*fg_xkb_keysym_to_utf8_fun)(xkb_keysym_t keysym, char *buffer, size_t size);
+typedef  int             (*fg_xkb_state_key_get_syms_fun)(struct xkb_state *state, xkb_keycode_t key, const xkb_keysym_t **syms_out);
+typedef  int             (*fg_xkb_state_mod_index_is_active_fun)(struct xkb_state *state, xkb_mod_index_t idx, enum xkb_state_component type);
+typedef  struct xkb_state * (*fg_xkb_state_new_fun)(struct xkb_keymap *keymap);
+typedef  void            (*fg_xkb_state_unref_fun)(struct xkb_state *state);
+typedef  enum xkb_state_component (*fg_xkb_state_update_mask_fun)(struct xkb_state *state, xkb_mod_mask_t depressed_mods, xkb_mod_mask_t latched_mods, xkb_mod_mask_t locked_mods, xkb_layout_index_t depressed_layout, xkb_layout_index_t latched_layout, xkb_layout_index_t locked_layout);
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern fg_xkb_context_new_fun               fg_xkb_context_new;
+extern fg_xkb_context_unref_fun             fg_xkb_context_unref;
+extern fg_xkb_keymap_mod_get_index_fun      fg_xkb_keymap_mod_get_index;
+extern fg_xkb_keymap_new_from_string_fun    fg_xkb_keymap_new_from_string;
+extern fg_xkb_keysym_to_utf8_fun            fg_xkb_keysym_to_utf8;
+extern fg_xkb_state_key_get_syms_fun        fg_xkb_state_key_get_syms;
+extern fg_xkb_state_mod_index_is_active_fun fg_xkb_state_mod_index_is_active;
+extern fg_xkb_state_new_fun                 fg_xkb_state_new;
+extern fg_xkb_state_unref_fun               fg_xkb_state_unref;
+extern fg_xkb_state_update_mask_fun         fg_xkb_state_update_mask;
+
+int     fg_xkb_lib_init();
+void    fg_xkb_lib_destroy();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ! ifdef FG_XKB_SO_NAME */
+#endif /* ! ifdef FREEGLUT_LIB_SYMS_XKB_H */
+
--- ./src/wayland/fg_lib_wl.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./src/wayland/fg_lib_wl.c	2023-09-20 17:26:50.996000000 +0200
@@ -0,0 +1,195 @@
+/* GENERATED FILE: fg_lib_wl.c */
+#include "fg_lib_syms_wl.h"
+
+#ifndef FG_WL_SO_NAME
+int  fg_wl_lib_init() { return 0; }
+void fg_wl_lib_destroy() { }
+#else
+
+#include <dlfcn.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+fg_wl_compositor_interface_fun          fg_wl_compositor_interface = NULL;
+fg_wl_cursor_image_get_buffer_fun       fg_wl_cursor_image_get_buffer = NULL;
+fg_wl_cursor_theme_destroy_fun          fg_wl_cursor_theme_destroy = NULL;
+fg_wl_cursor_theme_get_cursor_fun       fg_wl_cursor_theme_get_cursor = NULL;
+fg_wl_cursor_theme_load_fun             fg_wl_cursor_theme_load = NULL;
+fg_wl_display_connect_fun               fg_wl_display_connect = NULL;
+fg_wl_display_disconnect_fun            fg_wl_display_disconnect = NULL;
+fg_wl_display_dispatch_pending_fun      fg_wl_display_dispatch_pending = NULL;
+fg_wl_display_flush_fun                 fg_wl_display_flush = NULL;
+fg_wl_display_get_fd_fun                fg_wl_display_get_fd = NULL;
+fg_wl_display_roundtrip_fun             fg_wl_display_roundtrip = NULL;
+fg_wl_egl_window_create_fun             fg_wl_egl_window_create = NULL;
+fg_wl_egl_window_destroy_fun            fg_wl_egl_window_destroy = NULL;
+fg_wl_egl_window_resize_fun             fg_wl_egl_window_resize = NULL;
+fg_wl_keyboard_interface_fun            fg_wl_keyboard_interface = NULL;
+fg_wl_pointer_interface_fun             fg_wl_pointer_interface = NULL;
+fg_wl_proxy_add_listener_fun            fg_wl_proxy_add_listener = NULL;
+fg_wl_proxy_destroy_fun                 fg_wl_proxy_destroy = NULL;
+fg_wl_proxy_marshal_fun                 fg_wl_proxy_marshal = NULL;
+fg_wl_proxy_marshal_constructor_fun     fg_wl_proxy_marshal_constructor = NULL;
+fg_wl_proxy_marshal_constructor_versioned_fun fg_wl_proxy_marshal_constructor_versioned = NULL;
+fg_wl_region_interface_fun              fg_wl_region_interface = NULL;
+fg_wl_registry_interface_fun            fg_wl_registry_interface = NULL;
+fg_wl_seat_interface_fun                fg_wl_seat_interface = NULL;
+fg_wl_shell_interface_fun               fg_wl_shell_interface = NULL;
+fg_wl_shell_surface_interface_fun       fg_wl_shell_surface_interface = NULL;
+fg_wl_shm_interface_fun                 fg_wl_shm_interface = NULL;
+fg_wl_surface_interface_fun             fg_wl_surface_interface = NULL;
+fg_wl_touch_interface_fun               fg_wl_touch_interface = NULL;
+
+static const char * fg_wl_lib_names[] = {
+    FG_WL_SO_NAME, NULL
+};
+static void * fg_wl_lib[sizeof(fg_wl_lib_names)/sizeof(*fg_wl_lib_names)] = { NULL, };
+
+static void * fg_wl_dlopen(const char * name, int flags) {
+    void * lib;
+    if ((lib = dlopen(name, flags)) == NULL) {
+        size_t len = strlen(name);
+        char * path = len ? strdup(name) : NULL;
+        const char * ext;
+        if (!path) return NULL;
+        if (len > 3 && !strcasecmp((ext = name + len - 3), ".so"))
+            len -= 3;
+        else if (len > 6 && !strcasecmp((ext = name + len - 6), ".dylib"))
+            len -= 6;
+        else
+            ext = NULL;
+        while (len > 0 && (isdigit(path[len-1]) || path[len-1] == '.' || (ext && path[len-1] == '-')))
+            --len; /* loop */
+        while (ext && isdigit(path[len])) ++len;
+        path[len] = 0;
+        if (ext != NULL)
+            strcpy(path + len, ext);
+        lib = dlopen(path, flags);
+        free(path);
+    }
+    return lib;
+}
+
+void * fg_wl_findsymbol(const char * name) {
+    void * sym;
+    for (void ** lib = fg_wl_lib; *lib != NULL; ++lib) {
+        if ((sym = dlsym(*lib, name)) != NULL)
+            return sym;
+    }
+    return NULL;
+}
+
+int fg_wl_lib_init() {
+    int ret = 0, i = 0;
+    if (*fg_wl_lib != NULL)
+        return 0;
+    for (const char ** name = fg_wl_lib_names; *name != NULL; ++name, ++i) {
+        if (**name == 0) { --i; continue; }
+        if ((fg_wl_lib[i] = fg_wl_dlopen(*name, RTLD_LOCAL|RTLD_NOW)) == NULL) {
+            return -1;
+        }
+    }
+    fg_wl_lib[i] = NULL;
+    if ((fg_wl_compositor_interface = fg_wl_findsymbol("wl_compositor_interface")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_compositor_interface");
+    if ((fg_wl_cursor_image_get_buffer = fg_wl_findsymbol("wl_cursor_image_get_buffer")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_cursor_image_get_buffer");
+    if ((fg_wl_cursor_theme_destroy = fg_wl_findsymbol("wl_cursor_theme_destroy")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_cursor_theme_destroy");
+    if ((fg_wl_cursor_theme_get_cursor = fg_wl_findsymbol("wl_cursor_theme_get_cursor")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_cursor_theme_get_cursor");
+    if ((fg_wl_cursor_theme_load = fg_wl_findsymbol("wl_cursor_theme_load")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_cursor_theme_load");
+    if ((fg_wl_display_connect = fg_wl_findsymbol("wl_display_connect")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_display_connect");
+    if ((fg_wl_display_disconnect = fg_wl_findsymbol("wl_display_disconnect")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_display_disconnect");
+    if ((fg_wl_display_dispatch_pending = fg_wl_findsymbol("wl_display_dispatch_pending")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_display_dispatch_pending");
+    if ((fg_wl_display_flush = fg_wl_findsymbol("wl_display_flush")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_display_flush");
+    if ((fg_wl_display_get_fd = fg_wl_findsymbol("wl_display_get_fd")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_display_get_fd");
+    if ((fg_wl_display_roundtrip = fg_wl_findsymbol("wl_display_roundtrip")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_display_roundtrip");
+    if ((fg_wl_egl_window_create = fg_wl_findsymbol("wl_egl_window_create")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_egl_window_create");
+    if ((fg_wl_egl_window_destroy = fg_wl_findsymbol("wl_egl_window_destroy")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_egl_window_destroy");
+    if ((fg_wl_egl_window_resize = fg_wl_findsymbol("wl_egl_window_resize")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_egl_window_resize");
+    if ((fg_wl_keyboard_interface = fg_wl_findsymbol("wl_keyboard_interface")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_keyboard_interface");
+    if ((fg_wl_pointer_interface = fg_wl_findsymbol("wl_pointer_interface")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_pointer_interface");
+    if ((fg_wl_proxy_add_listener = fg_wl_findsymbol("wl_proxy_add_listener")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_proxy_add_listener");
+    if ((fg_wl_proxy_destroy = fg_wl_findsymbol("wl_proxy_destroy")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_proxy_destroy");
+    if ((fg_wl_proxy_marshal = fg_wl_findsymbol("wl_proxy_marshal")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_proxy_marshal");
+    if ((fg_wl_proxy_marshal_constructor = fg_wl_findsymbol("wl_proxy_marshal_constructor")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_proxy_marshal_constructor");
+    if ((fg_wl_proxy_marshal_constructor_versioned = fg_wl_findsymbol("wl_proxy_marshal_constructor_versioned")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_proxy_marshal_constructor_versioned");
+    if ((fg_wl_region_interface = fg_wl_findsymbol("wl_region_interface")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_region_interface");
+    if ((fg_wl_registry_interface = fg_wl_findsymbol("wl_registry_interface")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_registry_interface");
+    if ((fg_wl_seat_interface = fg_wl_findsymbol("wl_seat_interface")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_seat_interface");
+    if ((fg_wl_shell_interface = fg_wl_findsymbol("wl_shell_interface")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_shell_interface");
+    if ((fg_wl_shell_surface_interface = fg_wl_findsymbol("wl_shell_surface_interface")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_shell_surface_interface");
+    if ((fg_wl_shm_interface = fg_wl_findsymbol("wl_shm_interface")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_shm_interface");
+    if ((fg_wl_surface_interface = fg_wl_findsymbol("wl_surface_interface")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_surface_interface");
+    if ((fg_wl_touch_interface = fg_wl_findsymbol("wl_touch_interface")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "wl_touch_interface");
+    return ret;
+}
+
+void fg_wl_lib_destroy() {
+    if (*fg_wl_lib == NULL)
+        return ;
+    for (void ** lib = fg_wl_lib; *lib; ++lib) {
+        dlclose(*lib);
+        *lib = NULL;
+    }
+    fg_wl_compositor_interface = NULL;
+    fg_wl_cursor_image_get_buffer = NULL;
+    fg_wl_cursor_theme_destroy = NULL;
+    fg_wl_cursor_theme_get_cursor = NULL;
+    fg_wl_cursor_theme_load = NULL;
+    fg_wl_display_connect = NULL;
+    fg_wl_display_disconnect = NULL;
+    fg_wl_display_dispatch_pending = NULL;
+    fg_wl_display_flush = NULL;
+    fg_wl_display_get_fd = NULL;
+    fg_wl_display_roundtrip = NULL;
+    fg_wl_egl_window_create = NULL;
+    fg_wl_egl_window_destroy = NULL;
+    fg_wl_egl_window_resize = NULL;
+    fg_wl_keyboard_interface = NULL;
+    fg_wl_pointer_interface = NULL;
+    fg_wl_proxy_add_listener = NULL;
+    fg_wl_proxy_destroy = NULL;
+    fg_wl_proxy_marshal = NULL;
+    fg_wl_proxy_marshal_constructor = NULL;
+    fg_wl_proxy_marshal_constructor_versioned = NULL;
+    fg_wl_region_interface = NULL;
+    fg_wl_registry_interface = NULL;
+    fg_wl_seat_interface = NULL;
+    fg_wl_shell_interface = NULL;
+    fg_wl_shell_surface_interface = NULL;
+    fg_wl_shm_interface = NULL;
+    fg_wl_surface_interface = NULL;
+    fg_wl_touch_interface = NULL;
+    return ;
+}
+
+#endif /* ! ifdef FG_WL_SO_NAME */
+
--- ./src/wayland/fg_lib_xkb.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./src/wayland/fg_lib_xkb.c	2023-09-20 17:26:59.164000000 +0200
@@ -0,0 +1,119 @@
+/* GENERATED FILE: fg_lib_xkb.c */
+#include "fg_lib_syms_xkb.h"
+
+#ifndef FG_XKB_SO_NAME
+int  fg_xkb_lib_init() { return 0; }
+void fg_xkb_lib_destroy() { }
+#else
+
+#include <dlfcn.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+fg_xkb_context_new_fun                  fg_xkb_context_new = NULL;
+fg_xkb_context_unref_fun                fg_xkb_context_unref = NULL;
+fg_xkb_keymap_mod_get_index_fun         fg_xkb_keymap_mod_get_index = NULL;
+fg_xkb_keymap_new_from_string_fun       fg_xkb_keymap_new_from_string = NULL;
+fg_xkb_keysym_to_utf8_fun               fg_xkb_keysym_to_utf8 = NULL;
+fg_xkb_state_key_get_syms_fun           fg_xkb_state_key_get_syms = NULL;
+fg_xkb_state_mod_index_is_active_fun    fg_xkb_state_mod_index_is_active = NULL;
+fg_xkb_state_new_fun                    fg_xkb_state_new = NULL;
+fg_xkb_state_unref_fun                  fg_xkb_state_unref = NULL;
+fg_xkb_state_update_mask_fun            fg_xkb_state_update_mask = NULL;
+
+static const char * fg_xkb_lib_names[] = {
+    FG_XKB_SO_NAME, NULL
+};
+static void * fg_xkb_lib[sizeof(fg_xkb_lib_names)/sizeof(*fg_xkb_lib_names)] = { NULL, };
+
+static void * fg_xkb_dlopen(const char * name, int flags) {
+    void * lib;
+    if ((lib = dlopen(name, flags)) == NULL) {
+        size_t len = strlen(name);
+        char * path = len ? strdup(name) : NULL;
+        const char * ext;
+        if (!path) return NULL;
+        if (len > 3 && !strcasecmp((ext = name + len - 3), ".so"))
+            len -= 3;
+        else if (len > 6 && !strcasecmp((ext = name + len - 6), ".dylib"))
+            len -= 6;
+        else
+            ext = NULL;
+        while (len > 0 && (isdigit(path[len-1]) || path[len-1] == '.' || (ext && path[len-1] == '-')))
+            --len; /* loop */
+        while (ext && isdigit(path[len])) ++len;
+        path[len] = 0;
+        if (ext != NULL)
+            strcpy(path + len, ext);
+        lib = dlopen(path, flags);
+        free(path);
+    }
+    return lib;
+}
+
+void * fg_xkb_findsymbol(const char * name) {
+    void * sym;
+    for (void ** lib = fg_xkb_lib; *lib != NULL; ++lib) {
+        if ((sym = dlsym(*lib, name)) != NULL)
+            return sym;
+    }
+    return NULL;
+}
+
+int fg_xkb_lib_init() {
+    int ret = 0, i = 0;
+    if (*fg_xkb_lib != NULL)
+        return 0;
+    for (const char ** name = fg_xkb_lib_names; *name != NULL; ++name, ++i) {
+        if (**name == 0) { --i; continue; }
+        if ((fg_xkb_lib[i] = fg_xkb_dlopen(*name, RTLD_LOCAL|RTLD_NOW)) == NULL) {
+            return -1;
+        }
+    }
+    fg_xkb_lib[i] = NULL;
+    if ((fg_xkb_context_new = fg_xkb_findsymbol("xkb_context_new")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "xkb_context_new");
+    if ((fg_xkb_context_unref = fg_xkb_findsymbol("xkb_context_unref")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "xkb_context_unref");
+    if ((fg_xkb_keymap_mod_get_index = fg_xkb_findsymbol("xkb_keymap_mod_get_index")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "xkb_keymap_mod_get_index");
+    if ((fg_xkb_keymap_new_from_string = fg_xkb_findsymbol("xkb_keymap_new_from_string")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "xkb_keymap_new_from_string");
+    if ((fg_xkb_keysym_to_utf8 = fg_xkb_findsymbol("xkb_keysym_to_utf8")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "xkb_keysym_to_utf8");
+    if ((fg_xkb_state_key_get_syms = fg_xkb_findsymbol("xkb_state_key_get_syms")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "xkb_state_key_get_syms");
+    if ((fg_xkb_state_mod_index_is_active = fg_xkb_findsymbol("xkb_state_mod_index_is_active")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "xkb_state_mod_index_is_active");
+    if ((fg_xkb_state_new = fg_xkb_findsymbol("xkb_state_new")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "xkb_state_new");
+    if ((fg_xkb_state_unref = fg_xkb_findsymbol("xkb_state_unref")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "xkb_state_unref");
+    if ((fg_xkb_state_update_mask = fg_xkb_findsymbol("xkb_state_update_mask")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "xkb_state_update_mask");
+    return ret;
+}
+
+void fg_xkb_lib_destroy() {
+    if (*fg_xkb_lib == NULL)
+        return ;
+    for (void ** lib = fg_xkb_lib; *lib; ++lib) {
+        dlclose(*lib);
+        *lib = NULL;
+    }
+    fg_xkb_context_new = NULL;
+    fg_xkb_context_unref = NULL;
+    fg_xkb_keymap_mod_get_index = NULL;
+    fg_xkb_keymap_new_from_string = NULL;
+    fg_xkb_keysym_to_utf8 = NULL;
+    fg_xkb_state_key_get_syms = NULL;
+    fg_xkb_state_mod_index_is_active = NULL;
+    fg_xkb_state_new = NULL;
+    fg_xkb_state_unref = NULL;
+    fg_xkb_state_update_mask = NULL;
+    return ;
+}
+
+#endif /* ! ifdef FG_XKB_SO_NAME */
+
--- ./src/wayland/fg_main_wl.c.orig	2023-09-27 13:31:29.758000000 +0200
+++ ./src/wayland/fg_main_wl.c	2023-09-26 17:46:20.199005000 +0200
@@ -29,19 +29,20 @@
 #include "../fg_internal.h"
 #include <errno.h>
 #include <poll.h>
+#include "fg_private_wl.h"
 
-void fgPlatformFullScreenToggle( SFG_Window *win );
-void fgPlatformPositionWindow( SFG_Window *window, int x, int y );
-void fgPlatformReshapeWindow( SFG_Window *window, int width, int height );
-void fgPlatformPushWindow( SFG_Window *window );
-void fgPlatformPopWindow( SFG_Window *window );
-void fgPlatformHideWindow( SFG_Window *window );
-void fgPlatformIconifyWindow( SFG_Window *window );
-void fgPlatformShowWindow( SFG_Window *window );
+void fgPlatformFullScreenToggle_WL( SFG_Window *win );
+void fgPlatformPositionWindow_WL( SFG_Window *window, int x, int y );
+void fgPlatformReshapeWindow_WL( SFG_Window *window, int width, int height );
+void fgPlatformPushWindow_WL( SFG_Window *window );
+void fgPlatformPopWindow_WL( SFG_Window *window );
+void fgPlatformHideWindow_WL( SFG_Window *window );
+void fgPlatformIconifyWindow_WL( SFG_Window *window );
+void fgPlatformShowWindow_WL( SFG_Window *window );
 void fghPlatformHandleKeyRepeat_WL(SFG_Window * window, uint32_t time);
 
 
-fg_time_t fgPlatformSystemTime( void )
+fg_time_t fgPlatformSystemTime_WL( void )
 {
 #ifdef CLOCK_MONOTONIC
     struct timespec now;
@@ -54,7 +55,7 @@
 #endif
 }
 
-void fgPlatformSleepForEvents( fg_time_t msec )
+void fgPlatformSleepForEvents_WL( fg_time_t msec )
 {
     struct pollfd pfd;
     int err;
@@ -73,7 +74,7 @@
 }
 
 
-void fgPlatformProcessSingleEvent( void )
+void fgPlatformProcessSingleEvent_WL( void )
 {
     SFG_Window *win = fgStructure.CurrentWindow;
 
@@ -84,67 +85,67 @@
     INVOKE_WCB( *win, Display, ( ) );
 }
 
-void fgPlatformMainLoopPreliminaryWork( void )
+void fgPlatformMainLoopPreliminaryWork_WL( void )
 {
     /* Under Wayland, this is a no-op */
 }
 
-void fgPlatformInitWork( SFG_Window* window )
+void fgPlatformInitWork_WL( SFG_Window* window )
 {
     /* Under Wayland, all events happen relative to input handlers
      * -> this is a no-op
      */
-     return;
+    return;
 }
 
-void fgPlatformPosResZordWork( SFG_Window* window, unsigned int workMask )
+void fgPlatformPosResZordWork_WL( SFG_Window* window, unsigned int workMask )
 {
     if( workMask & GLUT_FULL_SCREEN_WORK )
-        fgPlatformFullScreenToggle( window );
+        fgPlatformFullScreenToggle_WL( window );
     if( workMask & GLUT_POSITION_WORK )
-        fgPlatformPositionWindow( window, window->State.DesiredXpos, window->State.DesiredYpos );
+        fgPlatformPositionWindow_WL( window, window->State.DesiredXpos, window->State.DesiredYpos );
     if( workMask & GLUT_SIZE_WORK )
-        fgPlatformReshapeWindow ( window, window->State.DesiredWidth, window->State.DesiredHeight );
+        fgPlatformReshapeWindow_WL ( window, window->State.DesiredWidth, window->State.DesiredHeight );
     if( workMask & GLUT_ZORDER_WORK )
     {
         if( window->State.DesiredZOrder < 0 )
-            fgPlatformPushWindow( window );
+            fgPlatformPushWindow_WL( window );
         else
-            fgPlatformPopWindow( window );
+            fgPlatformPopWindow_WL( window );
     }
 }
 
-void fgPlatformVisibilityWork( SFG_Window* window )
+void fgPlatformVisibilityWork_WL( SFG_Window* window )
 {
-    /* Visibility status of window gets updated in the window message handlers above 
+    /* Visibility status of window gets updated in the window message handlers above
      */
     SFG_Window *win = window;
     switch (window->State.DesiredVisibility)
     {
     case DesireHiddenState:
-        fgPlatformHideWindow( window );
+        fgPlatformHideWindow_WL( window );
         break;
     case DesireIconicState:
         /* Call on top-level window */
         while (win->Parent)
             win = win->Parent;
-        fgPlatformIconifyWindow( win );
+        fgPlatformIconifyWindow_WL( win );
         break;
     case DesireNormalState:
-        fgPlatformShowWindow( window );
+        fgPlatformShowWindow_WL( window );
         break;
     }
 }
 
 /* dummy functions, not applicable on wayland */
-void fgPlatformSetColor(int idx, float r, float g, float b)
+void fgPlatformSetColor_WL(int idx, float r, float g, float b)
 {
 }
 
-float fgPlatformGetColor(int idx, int comp)
+float fgPlatformGetColor_WL(int idx, int comp)
 {
 }
 
-void fgPlatformCopyColormap(int win)
+void fgPlatformCopyColormap_WL(int win)
 {
 }
--- ./src/wayland/fg_private_wl.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./src/wayland/fg_private_wl.h	2023-09-17 20:42:17.143207998 +0200
@@ -0,0 +1,15 @@
+#ifndef FREEGLUT_WAYLAND_FG_PRIVATE_WL
+#define FREEGLUT_WAYLAND_FG_PRIVATE_WL
+
+#define Handle      Handle.Handle_EGL
+#define Context     Context.Context_EGL
+#define MContext    MContext.Context_EGL
+#define cmap        cmap.cmap_EGL
+#define pContext    pContext.pContext_WL
+#define pDisplay    pDisplay.pDisplay_WL
+#define pWState     pWState.pWState_WL
+#define pJoystick   pJoystick.pJoystick_X11
+
+#define SFG_PlatformDisplay SFG_PlatformDisplay_WL
+
+#endif // ! ifndef FREEGLUT_WAYLAND_FG_PRIVATE_WL
--- ./src/wayland/fg_state_wl.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/wayland/fg_state_wl.c	2023-09-17 19:15:39.069469997 +0200
@@ -28,8 +28,9 @@
 #include <GL/freeglut.h>
 #include "fg_internal.h"
 #include "egl/fg_state_egl.h"
+#include "fg_private_wl.h"
 
-int fgPlatformGlutDeviceGet ( GLenum eWhat )
+int fgPlatformGlutDeviceGet_WL ( GLenum eWhat )
 {
     switch( eWhat )
     {
@@ -70,7 +71,7 @@
 }
 
 
-int fgPlatformGlutGet ( GLenum eWhat )
+int fgPlatformGlutGet_WL ( GLenum eWhat )
 {
     switch( eWhat )
     {
@@ -134,8 +135,8 @@
         else
         {
             int result = 0;
-	    if ( ! eglGetConfigAttrib( fgDisplay.pDisplay.egl.Display,
-                     fgStructure.CurrentWindow->Window.pContext.egl.Config,
+	    if ( ! eglGetConfigAttrib( fgDisplay.egl.Display,
+                     fgStructure.CurrentWindow->Window.eglContext.Config,
                      EGL_BUFFER_SIZE, &result ) )
 	      fgError( "eglGetConfigAttrib(EGL_BUFFER_SIZE) failed" );
 
--- ./src/wayland/fg_structure_wl.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/wayland/fg_structure_wl.c	2023-09-16 15:43:00.018001000 +0200
@@ -28,10 +28,11 @@
 #include <GL/freeglut.h>
 #include "fg_internal.h"
 #include "egl/fg_structure_egl.h"
+#include "fg_private_wl.h"
 
 extern SFG_Structure fgStructure;
 
-void fgPlatformCreateWindow( SFG_Window *window )
+void fgPlatformCreateWindow_WL( SFG_Window *window )
 {
     fghPlatformCreateWindowEGL( window );
 
--- ./src/wayland/fg_window_wl.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/wayland/fg_window_wl.c	2023-09-21 00:54:40.367000000 +0200
@@ -29,11 +29,13 @@
 #include <GL/freeglut.h>
 #include "../fg_internal.h"
 #include "egl/fg_window_egl.h"
+#include "fg_private_wl.h"
+
 #define fghCreateNewContext fghCreateNewContextEGL
 
 extern void fghOnReshapeNotify( SFG_Window *window, int width, int height, GLboolean forceNotify );
-void fgPlatformReshapeWindow( SFG_Window *window, int width, int height );
-void fgPlatformIconifyWindow( SFG_Window *window );
+void fgPlatformReshapeWindow_WL( SFG_Window *window, int width, int height );
+void fgPlatformIconifyWindow_WL( SFG_Window *window );
 
 
 static void fghShSurfacePing( void* data,
@@ -48,7 +50,7 @@
                                 int32_t width, int32_t height )
 {
     SFG_Window* window = data;
-    fgPlatformReshapeWindow( window, width, height );
+    fgPlatformReshapeWindow_WL( window, width, height );
 }
 static const struct wl_shell_surface_listener fghShSurfaceListener =
 {
@@ -72,7 +74,7 @@
     }
     else
     {
-      fgPlatformReshapeWindow( win, win->State.pWState.OldWidth,
+      fgPlatformReshapeWindow_WL( win, win->State.pWState.OldWidth,
                                     win->State.pWState.OldHeight );
       wl_shell_surface_set_toplevel( win->Window.pContext.shsurface );
     }
@@ -80,7 +82,7 @@
     return 0;
 }
 
-void fgPlatformOpenWindow( SFG_Window* window, const char* title,
+void fgPlatformOpenWindow_WL( SFG_Window* window, const char* title,
                            GLboolean positionUse, int x, int y,
                            GLboolean sizeUse, int w, int h,
                            GLboolean gameMode, GLboolean isSubWindow )
@@ -89,9 +91,9 @@
     if( window->IsMenu && ( ! fgStructure.MenuContext ) )
         fgState.DisplayMode = GLUT_DOUBLE | GLUT_RGB ;
 
-    fghChooseConfig( &window->Window.pContext.egl.Config );
+    fghChooseConfig_EGL( &window->Window.eglContext.Config );
 
-    if( ! window->Window.pContext.egl.Config )
+    if( ! window->Window.eglContext.Config )
     {
         /*
          * The "fghChooseConfig" returned a null meaning that the visual
@@ -101,12 +103,12 @@
         if( fgState.DisplayMode & GLUT_MULTISAMPLE )
         {
             fgState.DisplayMode &= ~GLUT_MULTISAMPLE ;
-            fghChooseConfig( &window->Window.pContext.egl.Config );
+            fghChooseConfig_EGL( &window->Window.eglContext.Config );
             fgState.DisplayMode |= GLUT_MULTISAMPLE;
         }
     }
 
-    FREEGLUT_INTERNAL_ERROR_EXIT( window->Window.pContext.egl.Config != NULL,
+    FREEGLUT_INTERNAL_ERROR_EXIT( window->Window.eglContext.Config != NULL,
                                   "EGL configuration with necessary capabilities "
                                   "not found", "fgOpenWindow" );
 
@@ -118,7 +120,7 @@
     /*  Create the cursor  */
    window->Window.pContext.cursor = wl_cursor_theme_get_cursor(
                                       fgDisplay.pDisplay.cursor_theme,
-                                      "left_ptr" ); 
+                                      "left_ptr" );
    window->Window.pContext.cursor_surface = wl_compositor_create_surface(
                                               fgDisplay.pDisplay.compositor );
 
@@ -156,16 +158,16 @@
 
     /*  Create the Wl_EGL_Window  */
     window->Window.Context = fghCreateNewContext( window );
-    window->Window.pContext.egl_window = wl_egl_window_create( 
+    window->Window.pContext.egl_window = wl_egl_window_create(
                                            window->Window.pContext.surface,
                                            w, h);
-    window->Window.pContext.egl.Surface = eglCreateWindowSurface( 
-                              fgDisplay.pDisplay.egl.Display,
-                              window->Window.pContext.egl.Config,
+    window->Window.eglContext.Surface = eglCreateWindowSurface(
+                              fgDisplay.egl.Display,
+                              window->Window.eglContext.Config,
                               (EGLNativeWindowType)window->Window.pContext.egl_window,
                               NULL );
-    eglMakeCurrent( fgDisplay.pDisplay.egl.Display, window->Window.pContext.egl.Surface,
-                    window->Window.pContext.egl.Surface, window->Window.Context );
+    eglMakeCurrent( fgDisplay.egl.Display, window->Window.eglContext.Surface,
+                    window->Window.eglContext.Surface, window->Window.Context );
 
    window->Window.pContext.pointer_button_pressed = GL_FALSE;
 }
@@ -174,7 +176,7 @@
 /*
  * Request a window resize
  */
-void fgPlatformReshapeWindow( SFG_Window *window, int width, int height )
+void fgPlatformReshapeWindow_WL( SFG_Window *window, int width, int height )
 {
     fghOnReshapeNotify(window, width, height, GL_FALSE);
 
@@ -187,7 +189,7 @@
 /*
  * Closes a window, destroying the frame and OpenGL context
  */
-void fgPlatformCloseWindow( SFG_Window* window )
+void fgPlatformCloseWindow_WL( SFG_Window* window )
 {
     fghPlatformCloseWindowEGL(window);
 
@@ -206,20 +208,20 @@
  * This function re-creates the window assets if they
  * have been destroyed
  */
-void fgPlatformShowWindow( SFG_Window *window )
+void fgPlatformShowWindow_WL( SFG_Window *window )
 {
     if ( ! window->Window.pContext.egl_window ||
          ! window->Window.pContext.shsurface ||
          ! window->Window.pContext.surface)
     {
-        fgPlatformCloseWindow( window );
-        fgPlatformOpenWindow( window, "", /* TODO : save the title for further use */
+        fgPlatformCloseWindow_WL( window );
+        fgPlatformOpenWindow_WL( window, "", /* TODO : save the title for further use */
                               GL_TRUE, window->State.Xpos, window->State.Ypos,
                               GL_TRUE, window->State.Width, window->State.Height,
                               (GLboolean)(window->State.IsFullscreen ? GL_TRUE : GL_FALSE),
                               (GLboolean)(window->Parent ? GL_TRUE : GL_FALSE) );
     }
-    else 
+    else
     {
     /*     TODO : support this once we start using xdg-shell
      *
@@ -235,15 +237,15 @@
 /*
  * This function hides the specified window
  */
-void fgPlatformHideWindow( SFG_Window *window )
+void fgPlatformHideWindow_WL( SFG_Window *window )
 {
-    fgPlatformIconifyWindow( window );
+    fgPlatformIconifyWindow_WL( window );
 }
 
 /*
  * Iconify the specified window (top-level windows only)
  */
-void fgPlatformIconifyWindow( SFG_Window *window )
+void fgPlatformIconifyWindow_WL( SFG_Window *window )
 {
     /* TODO : support this once we start using xdg-shell
      *
@@ -257,7 +259,7 @@
 /*
  * Set the current window's title
  */
-void fgPlatformGlutSetWindowTitle( const char* title )
+void fgPlatformGlutSetWindowTitle_WL( const char* title )
 {
     SFG_Window* win = fgStructure.CurrentWindow;
     wl_shell_surface_set_title( win->Window.pContext.shsurface, title );
@@ -266,15 +268,15 @@
 /*
  * Set the current window's iconified title
  */
-void fgPlatformGlutSetIconTitle( const char* title )
+void fgPlatformGlutSetIconTitle_WL( const char* title )
 {
-    fgPlatformGlutSetWindowTitle( title );
+    fgPlatformGlutSetWindowTitle_WL( title );
 }
 
 /*
  * Change the specified window's position
  */
-void fgPlatformPositionWindow( SFG_Window *window, int x, int y )
+void fgPlatformPositionWindow_WL( SFG_Window *window, int x, int y )
 {
     /* pointless under Wayland */
     fgWarning( "glutPositionWindow(): function unsupported under Wayland" );
@@ -283,7 +285,7 @@
 /*
  * Lowers the specified window (by Z order change)
  */
-void fgPlatformPushWindow( SFG_Window *window )
+void fgPlatformPushWindow_WL( SFG_Window *window )
 {
     /* pointless under Wayland */
     fgWarning( "glutPushWindow(): function unsupported under Wayland" );
@@ -292,7 +294,7 @@
 /*
  * Raises the specified window (by Z order change)
  */
-void fgPlatformPopWindow( SFG_Window *window )
+void fgPlatformPopWindow_WL( SFG_Window *window )
 {
     /* pointless under Wayland */
     fgWarning( "glutPopWindow(): function unsupported under Wayland" );
@@ -301,7 +303,7 @@
 /*
  * Toggle the window's full screen state.
  */
-void fgPlatformFullScreenToggle( SFG_Window *win )
+void fgPlatformFullScreenToggle_WL( SFG_Window *win )
 {
     if(fghToggleFullscreen() != -1) {
         win->State.IsFullscreen = !win->State.IsFullscreen;
--- ./src/x11/fg_cmap_x11.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/x11/fg_cmap_x11.c	2023-09-17 20:53:12.166556001 +0200
@@ -24,11 +24,12 @@
  */
 #include <GL/freeglut.h>
 #include "../fg_internal.h"
+#include "fg_private_x11.h"
 
-void fgPlatformSetColor(int idx, float r, float g, float b)
+void fgPlatformSetColor_X11(int idx, float r, float g, float b)
 {
 	Display *dpy = fgDisplay.pDisplay.Display;
-	Colormap cmap = fgStructure.CurrentWindow->Window.cmap;
+	Colormap cmap_ = fgStructure.CurrentWindow->Window.cmap;
 	int cmap_size = fgStructure.CurrentWindow->Window.cmap_size;
 	XColor color;
 
@@ -38,14 +39,14 @@
 		color.green = (unsigned short)(g * 65535.0f);
 		color.blue = (unsigned short)(b * 65535.0f);
 		color.flags = DoRed | DoGreen | DoBlue;
-		XStoreColor(dpy, cmap, &color);
+		XStoreColor(dpy, cmap_, &color);
 	}
 }
 
-float fgPlatformGetColor(int idx, int comp)
+float fgPlatformGetColor_X11(int idx, int comp)
 {
 	Display *dpy = fgDisplay.pDisplay.Display;
-	Colormap cmap = fgStructure.CurrentWindow->Window.cmap;
+	Colormap cmap_ = fgStructure.CurrentWindow->Window.cmap;
 	int cmap_size = fgStructure.CurrentWindow->Window.cmap_size;
 	XColor color;
 
@@ -54,7 +55,7 @@
 	}
 
 	color.pixel = idx;
-	XQueryColor(dpy, cmap, &color);
+	XQueryColor(dpy, cmap_, &color);
 	switch(comp) {
 	case GLUT_RED:
 		return color.red / 65535.0f;
@@ -68,7 +69,7 @@
 	return -1.0f;
 }
 
-void fgPlatformCopyColormap(int win)
+void fgPlatformCopyColormap_X11(int win)
 {
 	/* TODO */
 	fgWarning("glutCopyColormap not implemented yet on X11");
--- ./src/x11/fg_cursor_x11.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/x11/fg_cursor_x11.c	2023-09-20 01:41:59.493519423 +0200
@@ -27,6 +27,7 @@
 
 #include <GL/freeglut.h>
 #include "../fg_internal.h"
+#include "fg_private_x11.h"
 
 /* This code is for Posix/X11, Solaris, and OSX */
 #include <X11/cursorfont.h>
@@ -67,7 +68,7 @@
 /*
  * Note: The arrangement of the table below depends on the fact that
  * the "normal" GLUT_CURSOR_* values start a 0 and are consecutive.
- */ 
+ */
 static cursorCacheEntry cursorCache[] = {
     { XC_arrow,               None, 0 }, /* GLUT_CURSOR_RIGHT_ARROW */
     { XC_top_left_arrow,      None, 0 }, /* GLUT_CURSOR_LEFT_ARROW */
@@ -91,7 +92,7 @@
     { XC_bottom_left_corner,  None, 0 }  /* GLUT_CURSOR_BOTTOM_LEFT_CORNER */
 };
 
-void fgPlatformSetCursor ( SFG_Window *window, int cursorID )
+void fgPlatformSetCursor_X11 ( SFG_Window *window, int cursorID )
 {
     Cursor cursor;
     /*
@@ -145,7 +146,7 @@
 }
 
 
-void fgPlatformWarpPointer ( int x, int y )
+void fgPlatformWarpPointer_X11 ( int x, int y )
 {
     XWarpPointer(
         fgDisplay.pDisplay.Display,
@@ -158,7 +159,7 @@
     XFlush( fgDisplay.pDisplay.Display );
 }
 
-void fghPlatformGetCursorPos(const SFG_Window *window, GLboolean client, SFG_XYUse *mouse_pos)
+void fghPlatformGetCursorPos_X11(const SFG_Window *window, GLboolean client, SFG_XYUse *mouse_pos)
 {
     /* Get current pointer location in screen coordinates (if client is false or window is NULL), else
      * Get current pointer location relative to top-left of client area of window (if client is true and window is not NULL)
--- ./src/x11/fg_display_x11_glx.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/x11/fg_display_x11_glx.c	2023-09-17 20:54:23.306108000 +0200
@@ -28,9 +28,10 @@
 
 #include <GL/freeglut.h>
 #include "../fg_internal.h"
+#include "fg_private_x11.h"
 
-void fgPlatformGlutSwapBuffers( SFG_PlatformDisplay *pDisplayPtr, SFG_Window* CurrentWindow )
+void fgPlatformGlutSwapBuffers_X11( SFG_Display *pDisplayPtr, SFG_Window* CurrentWindow )
 {
-    glXSwapBuffers( pDisplayPtr->Display, CurrentWindow->Window.Handle );
+    glXSwapBuffers( fgDisplay.pDisplay.Display, CurrentWindow->Window.Handle );
 }
 
--- ./src/x11/fg_ext_x11.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/x11/fg_ext_x11.c	2023-09-17 20:21:25.461680000 +0200
@@ -29,8 +29,9 @@
 #define GLX_GLXEXT_PROTOTYPES
 #include <GL/freeglut.h>
 #include "../fg_internal.h"
+#include "fg_private_x11.h"
 
-GLUTproc fgPlatformGetGLUTProcAddress( const char* procName )
+GLUTproc fgPlatformGetGLUTProcAddress_X11( const char* procName )
 {
     /* optimization: quick initial check */
     if( strncmp( procName, "glut", 4 ) != 0 )
@@ -50,7 +51,7 @@
 
 
 #ifndef EGL_VERSION_1_0
-SFG_Proc fgPlatformGetProcAddress( const char *procName )
+SFG_Proc fgPlatformGetProcAddress_X11( const char *procName )
 {
 #if defined( GLX_ARB_get_proc_address )
     return (SFG_Proc)glXGetProcAddressARB( ( const GLubyte * )procName );
--- ./src/x11/fg_gamemode_x11.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/x11/fg_gamemode_x11.c	2023-09-17 20:21:32.389142001 +0200
@@ -28,6 +28,7 @@
 #include <time.h>
 #include <GL/freeglut.h>
 #include "../fg_internal.h"
+#include "fg_private_x11.h"
 
 /* we'll try to use XR&R if it's available at compile-time, and at runtime, and the user
  * hasn't explicitly disabled it by setting the FREEGLUT_NO_XRANDR env-var.
@@ -181,7 +182,7 @@
  * Remembers the current visual settings, so that
  * we can change them and restore later...
  */
-void fgPlatformRememberState( void )
+void fgPlatformRememberState_X11( void )
 {
     /*
      * Remember the current pointer location before going fullscreen
@@ -260,7 +261,7 @@
 /*
  * Restores the previously remembered visual settings
  */
-void fgPlatformRestoreState( void )
+void fgPlatformRestoreState_X11( void )
 {
     /* Restore the remembered pointer position: */
     XWarpPointer(
@@ -405,7 +406,7 @@
 /*
  * Changes the current display mode to match user's settings
  */
-GLboolean fgPlatformChangeDisplayMode( GLboolean haveToTest )
+GLboolean fgPlatformChangeDisplayMode_X11( GLboolean haveToTest )
 {
     GLboolean success = GL_FALSE;
 #ifdef HAVE_X11_EXTENSIONS_XRANDR_H
@@ -509,7 +510,7 @@
 }
 
 
-void fgPlatformEnterGameMode( void )
+void fgPlatformEnterGameMode_X11( void )
 {
 
     /*
@@ -604,7 +605,7 @@
 
 }
 
-void fgPlatformLeaveGameMode( void )
+void fgPlatformLeaveGameMode_X11( void )
 {
     XUngrabPointer( fgDisplay.pDisplay.Display, CurrentTime );
     XUngrabKeyboard( fgDisplay.pDisplay.Display, CurrentTime );
--- ./src/x11/fg_glutfont_definitions_x11.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/x11/fg_glutfont_definitions_x11.c	2023-09-17 20:21:42.077983996 +0200
@@ -71,7 +71,9 @@
 #undef glutBitmapHelvetica12
 #undef glutBitmapHelvetica18
 
+#include <GL/freeglut_ext.h>
 #include "../fg_internal.h"
+#include "fg_private_x11.h"
 
 struct freeglutStrokeFont
 {
--- ./src/x11/fg_init_x11.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/x11/fg_init_x11.c	2023-09-19 23:10:34.061073423 +0200
@@ -32,6 +32,141 @@
 #include "fg_internal.h"
 #include "fg_init.h"
 #include "egl/fg_init_egl.h"
+#include "fg_private_x11.h"
+#include "fg_lib_syms_X.h"
+#ifndef EGL_VERSION_1_0
+#include "fg_lib_syms_glx.h"
+#endif
+
+void fgPlatformInitialiseInputDevices_X11( void );
+void fgPlatformCloseInputDevices_X11( void );
+extern fg_time_t fgPlatformSystemTime_X11 ( void );
+extern GLboolean fgPlatformChangeDisplayMode_X11 ( GLboolean haveToTest );
+extern GLUTproc fgPlatformGetGLUTProcAddress_X11 ( const char *procName );
+extern GLvoid fgPlatformGetGameModeVMaxExtent_X11 ( SFG_Window* window, int* x, int* y );
+extern int fgPlatformGlutDeviceGet_X11 ( GLenum eWhat );
+extern int fgPlatformGlutGet_X11 ( GLenum eWhat );
+extern int *fgPlatformGlutGetModeValues_EGL (GLenum eWhat, int *size);
+extern int *fgPlatformGlutGetModeValues_X11 (GLenum eWhat, int *size);
+extern int fgPlatformHasSpaceball_X11 (void);
+extern int fgPlatformSpaceballNumButtons_X11 (void);
+extern SFG_Proc fgPlatformGetProcAddress_X11 ( const char *procName );
+extern void fgPlatformCloseDisplay_X11 ( void );
+extern void fgPlatformCloseWindow_X11 ( SFG_Window* window );
+extern void fgPlatformCreateWindow_X11 ( SFG_Window *window );
+extern void fgPlatformDeinitialiseInputDevices_X11 ( void );
+extern void fgPlatformDestroyContext_EGL ( SFG_Display * Display, SFG_WindowContextType context );
+extern void fgPlatformDestroyContext_X11 ( SFG_Display * Display, SFG_WindowContextType context );
+extern void fgPlatformEnterGameMode_X11 ( void );
+extern void fgPlatformGlutSetIconTitle_X11 ( const char* title );
+extern void fgPlatformGlutSetWindowTitle_X11 ( const char* title );
+extern void fgPlatformGlutSwapBuffers_X11 ( SFG_Display * Display, SFG_Window* CurrentWindow );
+extern void fgPlatformGlutSwapBuffers_EGL ( SFG_Display * Display, SFG_Window* CurrentWindow );
+extern void fgPlatformHideWindow_X11 ( SFG_Window* window );
+extern void fgPlatformInitialize_X11 ( const char* displayName );
+extern void fgPlatformInitializeSpaceball_X11 (void);
+extern void fgPlatformInitWork_X11 (SFG_Window* window);
+extern void fgPlatformJoystickClose_X11 ( int ident );
+extern void fgPlatformJoystickInit_X11 ( SFG_Joystick *fgJoystick[], int ident );
+extern void fgPlatformJoystickOpen_X11 ( SFG_Joystick* joy );
+extern void fgPlatformJoystickRawRead_X11 ( SFG_Joystick* joy, int* buttons, float* axes );
+extern void fgPlatformLeaveGameMode_X11 ( void );
+extern void fgPlatformMainLoopPreliminaryWork_X11 ( void );
+extern void fgPlatformOpenWindow_X11 ( SFG_Window* window, const char* title,
+                                      GLboolean positionUse, int x, int y,
+                                      GLboolean sizeUse, int w, int h,
+                                      GLboolean gameMode, GLboolean isSubWindow);
+extern void fgPlatformPosResZordWork_X11 (SFG_Window* window, unsigned int workMask);
+extern void fgPlatformProcessSingleEvent_X11 ( void );
+extern void fgPlatformRegisterDialDevice_X11 ( const char *dial_device );
+extern void fgPlatformRememberState_X11 ( void );
+extern void fgPlatformRestoreState_X11 ( void );
+extern void fgPlatformSetCursor_X11 ( SFG_Window *window, int cursorID );
+extern void fgPlatformSetWindow_EGL ( SFG_Window *window );
+extern void fgPlatformSetWindow_X11 ( SFG_Window *window );
+extern void fgPlatformSleepForEvents_X11 ( fg_time_t msec );
+extern void fgPlatformSpaceballClose_X11 (void);
+extern void fgPlatformSpaceballSetWindow_X11 (SFG_Window *window);
+extern void fgPlatformVisibilityWork_X11 (SFG_Window* window);
+extern void fgPlatformWarpPointer_X11 ( int x, int y );
+extern void fgPlatformSetColor_X11 ( int idx, float r, float g, float b );
+extern float fgPlatformGetColor_X11 ( int idx, int comp );
+extern void fgPlatformCopyColormap_X11 ( int win );
+extern void fghPlatformGetCursorPos_X11(const SFG_Window *window, GLboolean client, SFG_XYUse *mouse_pos);
+extern int fghPlatformChooseConfig_X11(void * vdata);
+
+SFG_Platform fgPlatform_X11 = {
+    "x11",
+    GLUT_DISPLAY_X11,
+
+    fgPlatformSystemTime_X11,
+    fgPlatformChangeDisplayMode_X11,
+    fgPlatformGetGLUTProcAddress_X11,
+    fgPlatformGetGameModeVMaxExtent_X11,
+    fgPlatformGlutDeviceGet_X11,
+    fgPlatformGlutGet_X11,
+#if defined(EGL_VERSION_1_0) && defined(FREEGLUT_GLES)
+    fgPlatformGlutGetModeValues_EGL,
+#else
+    fgPlatformGlutGetModeValues_X11,
+#endif
+    fgPlatformHasSpaceball_X11,
+    fgPlatformSpaceballNumButtons_X11,
+#if defined(EGL_VERSION_1_0) && defined(FREEGLUT_GLES)
+    fgPlatformGetProcAddress_EGL,
+#else
+    fgPlatformGetProcAddress_X11,
+#endif
+    fgPlatformCloseDisplay_X11,
+    fgPlatformCloseWindow_X11,
+    fgPlatformCreateWindow_X11,
+    fgPlatformDeinitialiseInputDevices_X11,
+#if defined(EGL_VERSION_1_0) && defined(FREEGLUT_GLES)
+    fgPlatformDestroyContext_EGL,
+#else
+    fgPlatformDestroyContext_X11,
+#endif
+    fgPlatformEnterGameMode_X11,
+    fgPlatformGlutSetIconTitle_X11,
+    fgPlatformGlutSetWindowTitle_X11,
+#if defined(EGL_VERSION_1_0) && defined(FREEGLUT_GLES)
+    fgPlatformGlutSwapBuffers_EGL,
+#else
+    fgPlatformGlutSwapBuffers_X11,
+#endif
+    fgPlatformHideWindow_X11,
+    fgPlatformInitialize_X11,
+    fgPlatformInitializeSpaceball_X11,
+    fgPlatformInitWork_X11,
+    fgPlatformJoystickClose_X11,
+    fgPlatformJoystickInit_X11,
+    fgPlatformJoystickOpen_X11,
+    fgPlatformJoystickRawRead_X11,
+    fgPlatformLeaveGameMode_X11,
+    fgPlatformMainLoopPreliminaryWork_X11,
+    fgPlatformOpenWindow_X11,
+    fgPlatformPosResZordWork_X11,
+    fgPlatformProcessSingleEvent_X11,
+    fgPlatformRegisterDialDevice_X11,
+    fgPlatformRememberState_X11,
+    fgPlatformRestoreState_X11,
+    fgPlatformSetCursor_X11,
+#if defined(EGL_VERSION_1_0) && defined(FREEGLUT_GLES)
+    fgPlatformSetWindow_EGL,
+#else
+    fgPlatformSetWindow_X11,
+#endif
+    fgPlatformSleepForEvents_X11,
+    fgPlatformSpaceballClose_X11,
+    fgPlatformSpaceballSetWindow_X11,
+    fgPlatformVisibilityWork_X11,
+    fgPlatformWarpPointer_X11,
+    fgPlatformSetColor_X11,
+    fgPlatformGetColor_X11,
+    fgPlatformCopyColormap_X11,
+    fghPlatformGetCursorPos_X11,
+};
+
 
 /* Return the atom associated with "name". */
 static Atom fghGetAtom(const char * name)
@@ -140,7 +275,7 @@
 }
 
 /*  Check if "hint" is present in "property" for "window". */
-int fgHintPresent(Window window, Atom property, Atom hint)
+int fgHintPresent_X11(Window window, Atom property, Atom hint)
 {
   Atom *atoms;
   int number_of_atoms;
@@ -169,23 +304,41 @@
 /*
  * A call to this function should initialize all the display stuff...
  */
-void fgPlatformInitialize( const char* displayName )
+void fgPlatformInitialize_X11( const char* displayName )
 {
+    if (fg_X_lib_init() != 0) {
+        fgWarning("cannot load X library");
+        return ;
+    }
+#ifndef EGL_VERSION_1_0
+    if (fg_glx_lib_init() != 0) {
+        fgWarning("cannot load GLX library");
+        return ;
+    }
+#endif
+
     fgDisplay.pDisplay.Display = XOpenDisplay( displayName );
 
-    if( fgDisplay.pDisplay.Display == NULL )
-        fgError( "failed to open display '%s'", XDisplayName( displayName ) );
+    if( fgDisplay.pDisplay.Display == NULL ) {
+        fgWarning( "failed to open display '%s'", XDisplayName( displayName ) );
+        return ;
+    }
 
     if ( fgState.XSyncSwitch )
         XSynchronize(fgDisplay.pDisplay.Display, True);
 
 #ifdef EGL_VERSION_1_0
-    fghPlatformInitializeEGL();
+    if (fghPlatformInitializeEGL(EGL_DEFAULT_DISPLAY) < 0) {
+        fgPlatformCloseDisplay_X11();
+        return ;
+    }
 #else
-    if( !glXQueryExtension( fgDisplay.pDisplay.Display, NULL, NULL ) )
-        fgError( "OpenGL GLX extension not supported by display '%s'",
+    if( !glXQueryExtension( fgDisplay.pDisplay.Display, NULL, NULL ) ) {
+        fgWarning( "OpenGL GLX extension not supported by display '%s'",
             XDisplayName( displayName ) );
-
+        fgPlatformCloseDisplay_X11();
+        return ;
+    }
     /* This forces AMD Catalyst drivers to initialize and register a shutdown
      * function, which must be done before our own call to atexit to prevent
      * a crash if glutMainLoop is not called or is not exited cleanly.
@@ -236,17 +389,17 @@
     {
       const Atom supported = fghGetAtom("_NET_SUPPORTED");
       const Atom state     = fghGetAtom("_NET_WM_STATE");
-      
+
       /* Check if the state hint is supported. */
-      if (fgHintPresent(fgDisplay.pDisplay.RootWindow, supported, state))
+      if (fgHintPresent_X11(fgDisplay.pDisplay.RootWindow, supported, state))
       {
         const Atom full_screen = fghGetAtom("_NET_WM_STATE_FULLSCREEN");
-        
+
         fgDisplay.pDisplay.State = state;
-        
+
         /* Check if the window manager supports full screen. */
         /**  Check "_NET_WM_ALLOWED_ACTIONS" on our window instead? **/
-        if (fgHintPresent(fgDisplay.pDisplay.RootWindow, supported, full_screen))
+        if (fgHintPresent_X11(fgDisplay.pDisplay.RootWindow, supported, full_screen))
         {
           fgDisplay.pDisplay.StateFullScreen = full_screen;
         }
@@ -258,7 +411,7 @@
 
     /* Get start time */
     fgState.Time = fgSystemTime();
-    
+
 
     fgState.Initialised = GL_TRUE;
 
@@ -268,7 +421,7 @@
     fgInitialiseInputDevices();
 }
 
-void fgPlatformDeinitialiseInputDevices ( void )
+void fgPlatformDeinitialiseInputDevices_X11 ( void )
 {
 	fghCloseInputDevices ();
 
@@ -277,8 +430,10 @@
 }
 
 
-void fgPlatformCloseDisplay ( void )
+void fgPlatformCloseDisplay_X11 ( void )
 {
+    // fghPlatformCloseDisplayEGL(&fgDisplay.egl); ???
+
     /*
      * Make sure all X-client data we have created will be destroyed on
      * display closing
@@ -293,10 +448,10 @@
 }
 
 
-#ifndef EGL_VERSION_1_0
-void fgPlatformDestroyContext ( SFG_PlatformDisplay pDisplay, SFG_WindowContextType MContext )
+
+void fgPlatformDestroyContext_X11 ( SFG_Display * Display, SFG_WindowContextType context )
 {
     /* Note that the MVisualInfo is not owned by the MenuContext! */
-    glXDestroyContext( pDisplay.Display, MContext );
+    glXDestroyContext( fgDisplay.pDisplay.Display, context.Context_X11 );
 }
-#endif
+
--- ./src/x11/fg_input_devices_x11.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/x11/fg_input_devices_x11.c	2023-09-17 20:21:59.118500005 +0200
@@ -40,6 +40,7 @@
 #include <string.h>
 #include <termios.h>
 #include <fcntl.h>
+#include "fg_private_x11.h"
 
 struct _serialport {
    int fd;
@@ -55,7 +56,7 @@
 /*
  * Try initializing the input device(s)
  */
-void fgPlatformRegisterDialDevice ( const char *dial_device )
+void fgPlatformRegisterDialDevice_X11 ( const char *dial_device )
 {
 }
 
--- ./src/x11/fg_internal_x11.h.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/x11/fg_internal_x11.h	2023-09-19 23:01:21.016689425 +0200
@@ -30,9 +30,12 @@
 
 
 /* -- PLATFORM-SPECIFIC INCLUDES ------------------------------------------- */
-#ifdef EGL_VERSION_1_0
+#include "fg_lib_defs_X.h"
+#if defined(EGL_VERSION_1_0) && defined(FREEGLUT_GLES)
+#include "fg_lib_defs_egl.h"
 #include "egl/fg_internal_egl.h"
 #else
+#include "fg_lib_defs_glx.h"
 #include "x11/fg_internal_x11_glx.h"
 #endif
 #include <X11/Xlib.h>
@@ -47,11 +50,16 @@
 #    include <X11/extensions/Xrandr.h>
 #endif
 
+#ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
+//#include <errno.h>
+//#include <stdarg.h>
+#include <X11/extensions/XInput2.h>
+#endif
 
 /* -- GLOBAL TYPE DEFINITIONS ---------------------------------------------- */
 /* The structure used by display initialization in fg_init.c */
-typedef struct tagSFG_PlatformDisplay SFG_PlatformDisplay;
-struct tagSFG_PlatformDisplay
+typedef struct tagSFG_PlatformDisplay_X11 SFG_PlatformDisplay_X11;
+struct tagSFG_PlatformDisplay_X11
 {
     Display*        Display;            /* The display we are being run in.  */
     int             Screen;             /* The screen we are about to use.   */
@@ -82,10 +90,6 @@
     int             DisplayViewPortY;   /* saved Y location of the viewport  */
 #endif /* HAVE_X11_EXTENSIONS_XF86VMODE_H */
 
-#ifdef EGL_VERSION_1_0
-    struct tagSFG_PlatformDisplayEGL egl;
-#endif
-
     int             DisplayPointerX;    /* saved X location of the pointer   */
     int             DisplayPointerY;    /* saved Y location of the pointer   */
 };
@@ -95,34 +99,32 @@
  * Make "freeglut" window handle and context types so that we don't need so
  * much conditionally-compiled code later in the library.
  */
-#ifndef EGL_VERSION_1_0
-typedef Window     SFG_WindowHandleType;
-typedef GLXContext SFG_WindowContextType;
-typedef Colormap SFG_WindowColormapType;
+#if !defined(EGL_VERSION_1_0) || !defined(FREEGLUT_GLES)
+typedef Window     SFG_WindowHandleType_X11;
+typedef GLXContext SFG_WindowContextType_X11;
+typedef Colormap SFG_WindowColormapType_X11;
 #endif
 
-typedef struct tagSFG_PlatformContext SFG_PlatformContext;
-struct tagSFG_PlatformContext
+typedef struct tagSFG_PlatformContext_X11 SFG_PlatformContext_X11;
+struct tagSFG_PlatformContext_X11
 {
-#ifdef EGL_VERSION_1_0
-    struct tagSFG_PlatformContextEGL egl;
-#else
-#ifdef USE_FBCONFIG
+#if !defined(EGL_VERSION_1_0) || !defined(FREEGLUT_GLES)
+# ifdef USE_FBCONFIG
     GLXFBConfig    FBConfig;        /* The window's FBConfig               */
-#else
+# else
 	XVisualInfo *visinf;			/* for older GLX keep the visual info */
-#endif	/* !def GLX_VERSION_1_3 */
+# endif	/* !def GLX_VERSION_1_3 */
 #endif	/* !def EGL_VERSION_1_0 */
 };
 
 
 /* Window's state description. This structure should be kept portable. */
-typedef struct tagSFG_PlatformWindowState SFG_PlatformWindowState;
-struct tagSFG_PlatformWindowState
+typedef struct tagSFG_PlatformWindowState_X11 SFG_PlatformWindowState_X11;
+struct tagSFG_PlatformWindowState_X11
 {
     int             OldWidth;           /* Window width from before a resize */
     int             OldHeight;          /*   "    height  "    "    "   "    */
-    GLboolean       KeyRepeating;       /* Currently in repeat mode?         */    
+    GLboolean       KeyRepeating;       /* Currently in repeat mode?         */
 };
 
 /* -- JOYSTICK-SPECIFIC STRUCTURES AND TYPES ------------------------------- */
@@ -180,8 +182,8 @@
  * XXX axes and then dynamically allocate the arrays.
  */
 #    define _JS_MAX_AXES 16
-typedef struct tagSFG_PlatformJoystick SFG_PlatformJoystick;
-struct tagSFG_PlatformJoystick
+typedef struct tagSFG_PlatformJoystick_X11 SFG_PlatformJoystick_X11;
+struct tagSFG_PlatformJoystick_X11
 {
 #   if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__)
        struct os_specific_s *os;
@@ -213,13 +215,15 @@
 
 /* -- PRIVATE FUNCTION DECLARATIONS ---------------------------------------- */
 /* spaceball device functions, defined in fg_spaceball.c */
-int fgIsSpaceballXEvent(const XEvent *ev);
-void fgSpaceballHandleXEvent(const XEvent *ev);
+int fgIsSpaceballXEvent_X11(const XEvent *ev);
+void fgSpaceballHandleXEvent_X11(const XEvent *ev);
+
+SFG_Proc fgPlatformGetProcAddress_X11( const char *procName );
 
 /*
  * Check if "hint" is present in "property" for "window".  See fg_init.c
  */
-int fgHintPresent(Window window, Atom property, Atom hint);
+int fgHintPresent_X11(Window window, Atom property, Atom hint);
 
 /* Handler for X extension Events */
 #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
--- ./src/x11/fg_joystick_x11.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/x11/fg_joystick_x11.c	2023-09-17 20:08:59.765018000 +0200
@@ -41,6 +41,7 @@
 
 #include <fcntl.h>
 
+#include "fg_private_x11.h"
 
 /* BSD defines from "jsBSD.cxx" around lines 42-270 */
 
@@ -75,6 +76,7 @@
 #        endif
 #    endif
 
+
 struct os_specific_s {
   char             fname [128 ];
   int              fd;
@@ -294,7 +296,7 @@
 #define MAX_NUM_JOYSTICKS  2
 extern SFG_Joystick *fgJoystick [ MAX_NUM_JOYSTICKS ];
 
-void fgPlatformJoystickRawRead( SFG_Joystick* joy, int* buttons, float* axes )
+void fgPlatformJoystickRawRead_X11( SFG_Joystick* joy, int* buttons, float* axes )
 {
     int status;
 
@@ -461,7 +463,7 @@
 }
 
 
-void fgPlatformJoystickOpen( SFG_Joystick* joy )
+void fgPlatformJoystickOpen_X11( SFG_Joystick* joy )
 {
 #if defined( __FreeBSD__ ) || defined(__FreeBSD_kernel__)
     int i = 0;
@@ -655,7 +657,7 @@
 }
 
 
-void fgPlatformJoystickInit( SFG_Joystick *fgJoystick[], int ident )
+void fgPlatformJoystickInit_X11( SFG_Joystick *fgJoystick[], int ident )
 {
 #if defined( __FreeBSD__ ) || defined(__FreeBSD_kernel__)
     fgJoystick[ ident ]->id = ident;
@@ -682,7 +684,7 @@
 }
 
 
-void fgPlatformJoystickClose ( int ident )
+void fgPlatformJoystickClose_X11 ( int ident )
 {
 #if defined( __FreeBSD__ ) || defined(__FreeBSD_kernel__)
     if( fgJoystick[ident]->pJoystick.os )
--- ./src/x11/fg_lib_defs_glx.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./src/x11/fg_lib_defs_glx.h	2023-09-19 22:57:40.922697423 +0200
@@ -0,0 +1,23 @@
+/* GENERATED FILE: fg_lib_defs_glx.h */
+#ifndef FREEGLUT_LIB_DEFS_GLX_H
+#define FREEGLUT_LIB_DEFS_GLX_H
+
+#ifndef FG_GLX_SO_NAME
+#else
+
+#define glXChooseFBConfig                    (*fg_glXChooseFBConfig)
+#define glXCreateNewContext                  (*fg_glXCreateNewContext)
+#define glXDestroyContext                    (*fg_glXDestroyContext)
+#define glXGetCurrentContext                 (*fg_glXGetCurrentContext)
+#define glXGetFBConfigAttrib                 (*fg_glXGetFBConfigAttrib)
+#define glXGetProcAddressARB                 (*fg_glXGetProcAddressARB)
+#define glXGetVisualFromFBConfig             (*fg_glXGetVisualFromFBConfig)
+#define glXIsDirect                          (*fg_glXIsDirect)
+#define glXMakeContextCurrent                (*fg_glXMakeContextCurrent)
+#define glXQueryExtension                    (*fg_glXQueryExtension)
+#define glXQueryExtensionsString             (*fg_glXQueryExtensionsString)
+#define glXSwapBuffers                       (*fg_glXSwapBuffers)
+
+#endif /* ! ifndef FG_GLX_SO_NAME */
+#endif /* ! ifndef FREEGLUT_LIB_DEFS_GLX_H */
+
--- ./src/x11/fg_lib_defs_X.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./src/x11/fg_lib_defs_X.h	2023-09-19 21:40:47.253015422 +0200
@@ -0,0 +1,91 @@
+/* GENERATED FILE: fg_lib_defs_X.h */
+#ifndef FREEGLUT_LIB_DEFS_X_H
+#define FREEGLUT_LIB_DEFS_X_H
+
+#ifndef FG_X_SO_NAME
+#else
+
+#define XChangeProperty                      (*fg_XChangeProperty)
+#define XCheckIfEvent                        (*fg_XCheckIfEvent)
+#define XCloseDisplay                        (*fg_XCloseDisplay)
+#define XCreateBitmapFromData                (*fg_XCreateBitmapFromData)
+#define XCreateColormap                      (*fg_XCreateColormap)
+#define XCreateFontCursor                    (*fg_XCreateFontCursor)
+#define XCreatePixmapCursor                  (*fg_XCreatePixmapCursor)
+#define XCreateWindow                        (*fg_XCreateWindow)
+#define XDefineCursor                        (*fg_XDefineCursor)
+#define XDestroyWindow                       (*fg_XDestroyWindow)
+#define XDisplayName                         (*fg_XDisplayName)
+#define XF86VidModeGetAllModeLines           (*fg_XF86VidModeGetAllModeLines)
+#define XF86VidModeGetModeLine               (*fg_XF86VidModeGetModeLine)
+#define XF86VidModeGetViewPort               (*fg_XF86VidModeGetViewPort)
+#define XF86VidModeQueryExtension            (*fg_XF86VidModeQueryExtension)
+#define XF86VidModeSetViewPort               (*fg_XF86VidModeSetViewPort)
+#define XF86VidModeSwitchToMode              (*fg_XF86VidModeSwitchToMode)
+#define XFlush                               (*fg_XFlush)
+#define XFree                                (*fg_XFree)
+#define XFreeEventData                       (*fg_XFreeEventData)
+#define XFreePixmap                          (*fg_XFreePixmap)
+#define XGetErrorText                        (*fg_XGetErrorText)
+#define XGetEventData                        (*fg_XGetEventData)
+#define XGetPointerMapping                   (*fg_XGetPointerMapping)
+#define XGetWindowAttributes                 (*fg_XGetWindowAttributes)
+#define XGetWindowProperty                   (*fg_XGetWindowProperty)
+#define XGetWMName                           (*fg_XGetWMName)
+#define XGrabKeyboard                        (*fg_XGrabKeyboard)
+#define XGrabPointer                         (*fg_XGrabPointer)
+#define XIconifyWindow                       (*fg_XIconifyWindow)
+#define XInternAtom                          (*fg_XInternAtom)
+#define XISelectEvents                       (*fg_XISelectEvents)
+#define XLookupString                        (*fg_XLookupString)
+#define XLowerWindow                         (*fg_XLowerWindow)
+#define XMapWindow                           (*fg_XMapWindow)
+#define XMoveResizeWindow                    (*fg_XMoveResizeWindow)
+#define XMoveWindow                          (*fg_XMoveWindow)
+#define XNextEvent                           (*fg_XNextEvent)
+#define XOpenDisplay                         (*fg_XOpenDisplay)
+//#define XParseGeometry                       (*fg_XParseGeometry)
+#define XPeekIfEvent                         (*fg_XPeekIfEvent)
+#define XPending                             (*fg_XPending)
+#define XPutBackEvent                        (*fg_XPutBackEvent)
+#define XQueryColor                          (*fg_XQueryColor)
+#define XQueryExtension                      (*fg_XQueryExtension)
+#define XQueryKeymap                         (*fg_XQueryKeymap)
+#define XQueryPointer                        (*fg_XQueryPointer)
+#define XRaiseWindow                         (*fg_XRaiseWindow)
+#define XRefreshKeyboardMapping              (*fg_XRefreshKeyboardMapping)
+#define XResizeWindow                        (*fg_XResizeWindow)
+#define XRRConfigCurrentConfiguration        (*fg_XRRConfigCurrentConfiguration)
+#define XRRConfigCurrentRate                 (*fg_XRRConfigCurrentRate)
+#define XRRConfigRates                       (*fg_XRRConfigRates)
+#define XRRConfigSizes                       (*fg_XRRConfigSizes)
+#define XRRConfigTimes                       (*fg_XRRConfigTimes)
+#define XRRFreeScreenConfigInfo              (*fg_XRRFreeScreenConfigInfo)
+#define XRRGetScreenInfo                     (*fg_XRRGetScreenInfo)
+#define XRRQueryExtension                    (*fg_XRRQueryExtension)
+#define XRRQueryVersion                      (*fg_XRRQueryVersion)
+#define XRRSetScreenConfig                   (*fg_XRRSetScreenConfig)
+#define XRRSetScreenConfigAndRate            (*fg_XRRSetScreenConfigAndRate)
+#define XSendEvent                           (*fg_XSendEvent)
+#define XSetCloseDownMode                    (*fg_XSetCloseDownMode)
+#define XSetErrorHandler                     (*fg_XSetErrorHandler)
+#define XSetInputFocus                       (*fg_XSetInputFocus)
+#define XSetWMIconName                       (*fg_XSetWMIconName)
+#define XSetWMName                           (*fg_XSetWMName)
+#define XSetWMProperties                     (*fg_XSetWMProperties)
+#define XSetWMProtocols                      (*fg_XSetWMProtocols)
+#define XStoreColor                          (*fg_XStoreColor)
+#define XStringListToTextProperty            (*fg_XStringListToTextProperty)
+#define XSync                                (*fg_XSync)
+#define XSynchronize                         (*fg_XSynchronize)
+#define XTranslateCoordinates                (*fg_XTranslateCoordinates)
+#define XUndefineCursor                      (*fg_XUndefineCursor)
+#define XUngrabKeyboard                      (*fg_XUngrabKeyboard)
+#define XUngrabPointer                       (*fg_XUngrabPointer)
+#define XUnmapWindow                         (*fg_XUnmapWindow)
+#define XWarpPointer                         (*fg_XWarpPointer)
+#define XWithdrawWindow                      (*fg_XWithdrawWindow)
+
+#endif /* ! ifndef FG_X_SO_NAME */
+#endif /* ! ifndef FREEGLUT_LIB_DEFS_X_H */
+
--- ./src/x11/fg_lib_glx.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./src/x11/fg_lib_glx.c	2023-09-20 17:27:11.540000000 +0200
@@ -0,0 +1,132 @@
+/* GENERATED FILE: fg_lib_glx.c */
+#include "fg_lib_syms_glx.h"
+
+#ifndef FG_GLX_SO_NAME
+int  fg_glx_lib_init() { return 0; }
+void fg_glx_lib_destroy() { }
+#else
+
+#include <dlfcn.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+fg_glXChooseFBConfig_fun                fg_glXChooseFBConfig = NULL;
+fg_glXCreateNewContext_fun              fg_glXCreateNewContext = NULL;
+fg_glXDestroyContext_fun                fg_glXDestroyContext = NULL;
+fg_glXGetCurrentContext_fun             fg_glXGetCurrentContext = NULL;
+fg_glXGetFBConfigAttrib_fun             fg_glXGetFBConfigAttrib = NULL;
+fg_glXGetProcAddressARB_fun             fg_glXGetProcAddressARB = NULL;
+fg_glXGetVisualFromFBConfig_fun         fg_glXGetVisualFromFBConfig = NULL;
+fg_glXIsDirect_fun                      fg_glXIsDirect = NULL;
+fg_glXMakeContextCurrent_fun            fg_glXMakeContextCurrent = NULL;
+fg_glXQueryExtension_fun                fg_glXQueryExtension = NULL;
+fg_glXQueryExtensionsString_fun         fg_glXQueryExtensionsString = NULL;
+fg_glXSwapBuffers_fun                   fg_glXSwapBuffers = NULL;
+
+static const char * fg_glx_lib_names[] = {
+    FG_GLX_SO_NAME, NULL
+};
+static void * fg_glx_lib[sizeof(fg_glx_lib_names)/sizeof(*fg_glx_lib_names)] = { NULL, };
+
+static void * fg_glx_dlopen(const char * name, int flags) {
+    void * lib;
+    if ((lib = dlopen(name, flags)) == NULL) {
+        size_t len = strlen(name);
+        char * path = len ? strdup(name) : NULL;
+        const char * ext;
+        if (!path) return NULL;
+        if (len > 3 && !strcasecmp((ext = name + len - 3), ".so"))
+            len -= 3;
+        else if (len > 6 && !strcasecmp((ext = name + len - 6), ".dylib"))
+            len -= 6;
+        else
+            ext = NULL;
+        while (len > 0 && (isdigit(path[len-1]) || path[len-1] == '.' || (ext && path[len-1] == '-')))
+            --len; /* loop */
+        while (ext && isdigit(path[len])) ++len;
+        path[len] = 0;
+        if (ext != NULL)
+            strcpy(path + len, ext);
+        lib = dlopen(path, flags);
+        free(path);
+    }
+    return lib;
+}
+
+#if 0
+void * fg_glx_findsymbol(const char * name) {
+    void * sym;
+    for (void ** lib = fg_glx_lib; *lib != NULL; ++lib) {
+        if ((sym = dlsym(*lib, name)) != NULL)
+            return sym;
+    }
+    return NULL;
+}
+#else
+void * fg_gl_findsymbol(const char * name);
+#define fg_glx_findsymbol(name) fg_gl_findsymbol(name)
+#endif
+
+int fg_glx_lib_init() {
+    int ret = 0, i = 0;
+    if (*fg_glx_lib != NULL)
+        return 0;
+    for (const char ** name = fg_glx_lib_names; *name != NULL; ++name, ++i) {
+        if (**name == 0) { --i; continue; }
+        if ((fg_glx_lib[i] = fg_glx_dlopen(*name, RTLD_LOCAL|RTLD_NOW)) == NULL) {
+            return -1;
+        }
+    }
+    fg_glx_lib[i] = NULL;
+    if ((fg_glXChooseFBConfig = fg_glx_findsymbol("glXChooseFBConfig")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glXChooseFBConfig");
+    if ((fg_glXCreateNewContext = fg_glx_findsymbol("glXCreateNewContext")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glXCreateNewContext");
+    if ((fg_glXDestroyContext = fg_glx_findsymbol("glXDestroyContext")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glXDestroyContext");
+    if ((fg_glXGetCurrentContext = fg_glx_findsymbol("glXGetCurrentContext")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glXGetCurrentContext");
+    if ((fg_glXGetFBConfigAttrib = fg_glx_findsymbol("glXGetFBConfigAttrib")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glXGetFBConfigAttrib");
+    if ((fg_glXGetProcAddressARB = fg_glx_findsymbol("glXGetProcAddressARB")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glXGetProcAddressARB");
+    if ((fg_glXGetVisualFromFBConfig = fg_glx_findsymbol("glXGetVisualFromFBConfig")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glXGetVisualFromFBConfig");
+    if ((fg_glXIsDirect = fg_glx_findsymbol("glXIsDirect")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glXIsDirect");
+    if ((fg_glXMakeContextCurrent = fg_glx_findsymbol("glXMakeContextCurrent")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glXMakeContextCurrent");
+    if ((fg_glXQueryExtension = fg_glx_findsymbol("glXQueryExtension")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glXQueryExtension");
+    if ((fg_glXQueryExtensionsString = fg_glx_findsymbol("glXQueryExtensionsString")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glXQueryExtensionsString");
+    if ((fg_glXSwapBuffers = fg_glx_findsymbol("glXSwapBuffers")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "glXSwapBuffers");
+    return ret;
+}
+
+void fg_glx_lib_destroy() {
+    if (*fg_glx_lib == NULL)
+        return ;
+    for (void ** lib = fg_glx_lib; *lib; ++lib) {
+        dlclose(*lib);
+        *lib = NULL;
+    }
+    fg_glXChooseFBConfig = NULL;
+    fg_glXCreateNewContext = NULL;
+    fg_glXDestroyContext = NULL;
+    fg_glXGetCurrentContext = NULL;
+    fg_glXGetFBConfigAttrib = NULL;
+    fg_glXGetProcAddressARB = NULL;
+    fg_glXGetVisualFromFBConfig = NULL;
+    fg_glXIsDirect = NULL;
+    fg_glXMakeContextCurrent = NULL;
+    fg_glXQueryExtension = NULL;
+    fg_glXQueryExtensionsString = NULL;
+    fg_glXSwapBuffers = NULL;
+    return ;
+}
+
+#endif /* ! ifdef FG_GLX_SO_NAME */
+
--- ./src/x11/fg_lib_syms_glx.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./src/x11/fg_lib_syms_glx.h	2023-09-19 23:22:12.298017421 +0200
@@ -0,0 +1,55 @@
+/* GENERATED FILE: fg_lib_syms_glx.h */
+#ifndef FREEGLUT_LIB_SYMS_GLX_H
+#define FREEGLUT_LIB_SYMS_GLX_H
+
+#include "config.h"
+#ifndef FG_GLX_SO_NAME
+int fg_glx_lib_init();
+void fg_glx_lib_destroy();
+#else
+
+#define FREEGLUT_BUILDING_LIB
+#include <GL/freeglut.h>
+#include "fg_internal.h"
+
+typedef     GLXFBConfig * (*fg_glXChooseFBConfig_fun) ( Display *dpy, int screen, const int *attribList, int *nitems );
+typedef   GLXContext     (*fg_glXCreateNewContext_fun)( Display *dpy, GLXFBConfig config, int renderType, GLXContext shareList, int direct );
+typedef   void           (*fg_glXDestroyContext_fun)( Display *dpy, GLXContext ctx );
+typedef   GLXContext     (*fg_glXGetCurrentContext_fun)( void );
+typedef   int            (*fg_glXGetFBConfigAttrib_fun)( Display *dpy, GLXFBConfig config, int attribute, int *value );
+typedef  __GLXextFuncPtr (*fg_glXGetProcAddressARB_fun) (const GLubyte *);
+typedef   XVisualInfo * (*fg_glXGetVisualFromFBConfig_fun) ( Display *dpy, GLXFBConfig config );
+typedef   int            (*fg_glXIsDirect_fun)( Display *dpy, GLXContext ctx );
+typedef   int            (*fg_glXMakeContextCurrent_fun)( Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx );
+typedef   int            (*fg_glXQueryExtension_fun)( Display *dpy, int *errorb, int *event );
+typedef      const char * (*fg_glXQueryExtensionsString_fun) ( Display *dpy, int screen );
+typedef   void           (*fg_glXSwapBuffers_fun)( Display *dpy, GLXDrawable drawable );
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern fg_glXChooseFBConfig_fun             fg_glXChooseFBConfig;
+extern fg_glXCreateNewContext_fun           fg_glXCreateNewContext;
+extern fg_glXDestroyContext_fun             fg_glXDestroyContext;
+extern fg_glXGetCurrentContext_fun          fg_glXGetCurrentContext;
+extern fg_glXGetFBConfigAttrib_fun          fg_glXGetFBConfigAttrib;
+extern fg_glXGetProcAddressARB_fun          fg_glXGetProcAddressARB;
+extern fg_glXGetVisualFromFBConfig_fun      fg_glXGetVisualFromFBConfig;
+extern fg_glXIsDirect_fun                   fg_glXIsDirect;
+extern fg_glXMakeContextCurrent_fun         fg_glXMakeContextCurrent;
+extern fg_glXQueryExtension_fun             fg_glXQueryExtension;
+extern fg_glXQueryExtensionsString_fun      fg_glXQueryExtensionsString;
+extern fg_glXSwapBuffers_fun                fg_glXSwapBuffers;
+
+int     fg_glx_lib_init();
+void    fg_glx_lib_destroy();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ! ifdef FG_GLX_SO_NAME */
+#endif /* ! ifdef FREEGLUT_LIB_SYMS_GLX_H */
+
--- ./src/x11/fg_lib_syms_X.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./src/x11/fg_lib_syms_X.h	2023-09-19 21:41:03.613191424 +0200
@@ -0,0 +1,191 @@
+/* GENERATED FILE: fg_lib_syms_X.h */
+#ifndef FREEGLUT_LIB_SYMS_X_H
+#define FREEGLUT_LIB_SYMS_X_H
+
+#include "config.h"
+#ifndef FG_X_SO_NAME
+int fg_X_lib_init();
+void fg_X_lib_destroy();
+#else
+
+#define FREEGLUT_BUILDING_LIB
+#include <GL/freeglut.h>
+#include "fg_internal.h"
+
+typedef   int            (*fg_XChangeProperty_fun)( Display* , Window , Atom , Atom , int , int , const unsigned char* , int );
+typedef   int            (*fg_XCheckIfEvent_fun)( Display* , XEvent* , int (*) ( Display* , XEvent* , XPointer ) , XPointer );
+typedef   int            (*fg_XCloseDisplay_fun)( Display* );
+typedef  Pixmap          (*fg_XCreateBitmapFromData_fun)( Display* , Drawable , const char* , unsigned int , unsigned int );
+typedef  Colormap        (*fg_XCreateColormap_fun)( Display* , Window , Visual* , int );
+typedef  Cursor          (*fg_XCreateFontCursor_fun)( Display* , unsigned int );
+typedef  Cursor          (*fg_XCreatePixmapCursor_fun)( Display* , Pixmap , Pixmap , XColor* , XColor* , unsigned int , unsigned int );
+typedef  Window          (*fg_XCreateWindow_fun)( Display* , Window , int , int , unsigned int , unsigned int , unsigned int , int , unsigned int , Visual* , unsigned long , XSetWindowAttributes* );
+typedef   int            (*fg_XDefineCursor_fun)( Display* , Window , Cursor );
+typedef   int            (*fg_XDestroyWindow_fun)( Display* , Window );
+typedef  char *          (*fg_XDisplayName_fun)( const char* );
+typedef   Bool           (*fg_XF86VidModeGetAllModeLines_fun)( Display* , int , int* , XF86VidModeModeInfo*** );
+typedef   Bool           (*fg_XF86VidModeGetModeLine_fun)( Display* , int , int* , XF86VidModeModeLine* );
+typedef   Bool           (*fg_XF86VidModeGetViewPort_fun)( Display* , int , int* , int* );
+typedef   Bool           (*fg_XF86VidModeQueryExtension_fun)( Display* , int* , int* );
+typedef   Bool           (*fg_XF86VidModeSetViewPort_fun)( Display* , int , int , int );
+typedef   Bool           (*fg_XF86VidModeSwitchToMode_fun)( Display* , int , XF86VidModeModeInfo* );
+typedef   int            (*fg_XFlush_fun)( Display* );
+typedef   int            (*fg_XFree_fun)( void* );
+typedef   void           (*fg_XFreeEventData_fun)( Display* , XGenericEventCookie* );
+typedef   int            (*fg_XFreePixmap_fun)( Display* , Pixmap );
+typedef   int            (*fg_XGetErrorText_fun)( Display* , int , char* , int );
+typedef   int            (*fg_XGetEventData_fun)( Display* , XGenericEventCookie* );
+typedef   int            (*fg_XGetPointerMapping_fun)( Display* , unsigned char* , int );
+typedef   int            (*fg_XGetWindowAttributes_fun)( Display* , Window , XWindowAttributes* );
+typedef   int            (*fg_XGetWindowProperty_fun)( Display* , Window , Atom , long , long , int , Atom , Atom* , int* , unsigned long* , unsigned long* , unsigned char** );
+typedef   int            (*fg_XGetWMName_fun)( Display* , Window , XTextProperty* );
+typedef   int            (*fg_XGrabKeyboard_fun)( Display* , Window , int , int , int , Time );
+typedef   int            (*fg_XGrabPointer_fun)( Display* , Window , int , unsigned int , int , int , Window , Cursor , Time );
+typedef  int             (*fg_XIconifyWindow_fun)( Display* , Window , int );
+typedef  Atom            (*fg_XInternAtom_fun)( Display* , const char* , int );
+typedef   int            (*fg_XISelectEvents_fun)( Display* dpy, Window win, XIEventMask *masks, int num_masks );
+typedef   int            (*fg_XLookupString_fun)( XKeyEvent* , char* , int , KeySym* , XComposeStatus* );
+typedef   int            (*fg_XLowerWindow_fun)( Display* , Window );
+typedef   int            (*fg_XMapWindow_fun)( Display* , Window );
+typedef   int            (*fg_XMoveResizeWindow_fun)( Display* , Window , int , int , unsigned int , unsigned int );
+typedef   int            (*fg_XMoveWindow_fun)( Display* , Window , int , int );
+typedef   int            (*fg_XNextEvent_fun)( Display* , XEvent* );
+typedef      Display * (*fg_XOpenDisplay_fun)    ( const char* );
+//typedef   int            (*fg_XParseGeometry_fun)( const char* , int* , int* , unsigned int* , unsigned int* );
+typedef   int            (*fg_XPeekIfEvent_fun)( Display* , XEvent* , int (*) ( Display* , XEvent* , XPointer ) , XPointer );
+typedef   int            (*fg_XPending_fun)( Display* );
+typedef    int           (*fg_XPutBackEvent_fun)( Display* , XEvent* );
+typedef   int            (*fg_XQueryColor_fun)( Display* , Colormap , XColor* );
+typedef   int            (*fg_XQueryExtension_fun)( Display* , const char* , int* , int* , int* );
+typedef   int            (*fg_XQueryKeymap_fun)( Display* , char [32] );
+typedef   int            (*fg_XQueryPointer_fun)( Display* , Window , Window* , Window* , int* , int* , int* , int* , unsigned int* );
+typedef   int            (*fg_XRaiseWindow_fun)( Display* , Window );
+typedef   int            (*fg_XRefreshKeyboardMapping_fun)( XMappingEvent* );
+typedef   int            (*fg_XResizeWindow_fun)( Display* , Window , unsigned int , unsigned int );
+typedef   SizeID         (*fg_XRRConfigCurrentConfiguration_fun) (XRRScreenConfiguration *config, Rotation *rotation);
+typedef   short          (*fg_XRRConfigCurrentRate_fun) (XRRScreenConfiguration *config);
+typedef   short * (*fg_XRRConfigRates_fun)  (XRRScreenConfiguration *config, int sizeID, int *nrates);
+typedef   XRRScreenSize * (*fg_XRRConfigSizes_fun)  (XRRScreenConfiguration *config, int *nsizes);
+typedef   Time           (*fg_XRRConfigTimes_fun) (XRRScreenConfiguration *config, Time *config_timestamp);
+typedef   void           (*fg_XRRFreeScreenConfigInfo_fun) (XRRScreenConfiguration *config);
+typedef   XRRScreenConfiguration * (*fg_XRRGetScreenInfo_fun)  (Display *dpy, Window window);
+typedef   int            (*fg_XRRQueryExtension_fun) (Display *dpy, int *event_base_return, int *error_base_return);
+typedef  int             (*fg_XRRQueryVersion_fun) (Display *dpy, int *major_version_return, int *minor_version_return);
+typedef  int             (*fg_XRRSetScreenConfig_fun) (Display *dpy, XRRScreenConfiguration *config, Drawable draw, int size_index, Rotation rotation, Time timestamp);
+typedef    int           (*fg_XRRSetScreenConfigAndRate_fun) (Display *dpy, XRRScreenConfiguration *config, Drawable draw, int size_index, Rotation rotation, short rate, Time timestamp);
+typedef   int            (*fg_XSendEvent_fun)( Display* , Window , int , long , XEvent* );
+typedef   int            (*fg_XSetCloseDownMode_fun)( Display* , int );
+typedef   XErrorHandler  (*fg_XSetErrorHandler_fun) ( XErrorHandler );
+typedef   int            (*fg_XSetInputFocus_fun)( Display* , Window , int , Time );
+typedef   void           (*fg_XSetWMIconName_fun)( Display* , Window , XTextProperty* );
+typedef   void           (*fg_XSetWMName_fun)( Display* , Window , XTextProperty* );
+typedef   void           (*fg_XSetWMProperties_fun)( Display* , Window , XTextProperty* , XTextProperty* , char** , int , XSizeHints* , XWMHints* , XClassHint* );
+typedef  int             (*fg_XSetWMProtocols_fun)( Display* , Window , Atom* , int );
+typedef   int            (*fg_XStoreColor_fun)( Display* , Colormap , XColor* );
+typedef   int            (*fg_XStringListToTextProperty_fun)( char** , int , XTextProperty* );
+typedef   int            (*fg_XSync_fun)( Display* , int );
+typedef   int (*fg_XSynchronize_fun) ( Display* , int );
+typedef   int            (*fg_XTranslateCoordinates_fun)( Display* , Window , Window , int , int , int* , int* , Window* );
+typedef   int            (*fg_XUndefineCursor_fun)( Display* , Window );
+typedef   int            (*fg_XUngrabKeyboard_fun)( Display* , Time );
+typedef   int            (*fg_XUngrabPointer_fun)( Display* , Time );
+typedef   int            (*fg_XUnmapWindow_fun)( Display* , Window );
+typedef   int            (*fg_XWarpPointer_fun)( Display* , Window , Window , int , int , unsigned int , unsigned int , int , int );
+typedef  int             (*fg_XWithdrawWindow_fun)( Display* , Window , int );
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern fg_XChangeProperty_fun               fg_XChangeProperty;
+extern fg_XCheckIfEvent_fun                 fg_XCheckIfEvent;
+extern fg_XCloseDisplay_fun                 fg_XCloseDisplay;
+extern fg_XCreateBitmapFromData_fun         fg_XCreateBitmapFromData;
+extern fg_XCreateColormap_fun               fg_XCreateColormap;
+extern fg_XCreateFontCursor_fun             fg_XCreateFontCursor;
+extern fg_XCreatePixmapCursor_fun           fg_XCreatePixmapCursor;
+extern fg_XCreateWindow_fun                 fg_XCreateWindow;
+extern fg_XDefineCursor_fun                 fg_XDefineCursor;
+extern fg_XDestroyWindow_fun                fg_XDestroyWindow;
+extern fg_XDisplayName_fun                  fg_XDisplayName;
+extern fg_XF86VidModeGetAllModeLines_fun    fg_XF86VidModeGetAllModeLines;
+extern fg_XF86VidModeGetModeLine_fun        fg_XF86VidModeGetModeLine;
+extern fg_XF86VidModeGetViewPort_fun        fg_XF86VidModeGetViewPort;
+extern fg_XF86VidModeQueryExtension_fun     fg_XF86VidModeQueryExtension;
+extern fg_XF86VidModeSetViewPort_fun        fg_XF86VidModeSetViewPort;
+extern fg_XF86VidModeSwitchToMode_fun       fg_XF86VidModeSwitchToMode;
+extern fg_XFlush_fun                        fg_XFlush;
+extern fg_XFree_fun                         fg_XFree;
+extern fg_XFreeEventData_fun                fg_XFreeEventData;
+extern fg_XFreePixmap_fun                   fg_XFreePixmap;
+extern fg_XGetErrorText_fun                 fg_XGetErrorText;
+extern fg_XGetEventData_fun                 fg_XGetEventData;
+extern fg_XGetPointerMapping_fun            fg_XGetPointerMapping;
+extern fg_XGetWindowAttributes_fun          fg_XGetWindowAttributes;
+extern fg_XGetWindowProperty_fun            fg_XGetWindowProperty;
+extern fg_XGetWMName_fun                    fg_XGetWMName;
+extern fg_XGrabKeyboard_fun                 fg_XGrabKeyboard;
+extern fg_XGrabPointer_fun                  fg_XGrabPointer;
+extern fg_XIconifyWindow_fun                fg_XIconifyWindow;
+extern fg_XInternAtom_fun                   fg_XInternAtom;
+extern fg_XISelectEvents_fun                fg_XISelectEvents;
+extern fg_XLookupString_fun                 fg_XLookupString;
+extern fg_XLowerWindow_fun                  fg_XLowerWindow;
+extern fg_XMapWindow_fun                    fg_XMapWindow;
+extern fg_XMoveResizeWindow_fun             fg_XMoveResizeWindow;
+extern fg_XMoveWindow_fun                   fg_XMoveWindow;
+extern fg_XNextEvent_fun                    fg_XNextEvent;
+extern fg_XOpenDisplay_fun                  fg_XOpenDisplay;
+//extern fg_XParseGeometry_fun                fg_XParseGeometry;
+extern fg_XPeekIfEvent_fun                  fg_XPeekIfEvent;
+extern fg_XPending_fun                      fg_XPending;
+extern fg_XPutBackEvent_fun                 fg_XPutBackEvent;
+extern fg_XQueryColor_fun                   fg_XQueryColor;
+extern fg_XQueryExtension_fun               fg_XQueryExtension;
+extern fg_XQueryKeymap_fun                  fg_XQueryKeymap;
+extern fg_XQueryPointer_fun                 fg_XQueryPointer;
+extern fg_XRaiseWindow_fun                  fg_XRaiseWindow;
+extern fg_XRefreshKeyboardMapping_fun       fg_XRefreshKeyboardMapping;
+extern fg_XResizeWindow_fun                 fg_XResizeWindow;
+extern fg_XRRConfigCurrentConfiguration_fun fg_XRRConfigCurrentConfiguration;
+extern fg_XRRConfigCurrentRate_fun          fg_XRRConfigCurrentRate;
+extern fg_XRRConfigRates_fun                fg_XRRConfigRates;
+extern fg_XRRConfigSizes_fun                fg_XRRConfigSizes;
+extern fg_XRRConfigTimes_fun                fg_XRRConfigTimes;
+extern fg_XRRFreeScreenConfigInfo_fun       fg_XRRFreeScreenConfigInfo;
+extern fg_XRRGetScreenInfo_fun              fg_XRRGetScreenInfo;
+extern fg_XRRQueryExtension_fun             fg_XRRQueryExtension;
+extern fg_XRRQueryVersion_fun               fg_XRRQueryVersion;
+extern fg_XRRSetScreenConfig_fun            fg_XRRSetScreenConfig;
+extern fg_XRRSetScreenConfigAndRate_fun     fg_XRRSetScreenConfigAndRate;
+extern fg_XSendEvent_fun                    fg_XSendEvent;
+extern fg_XSetCloseDownMode_fun             fg_XSetCloseDownMode;
+extern fg_XSetErrorHandler_fun              fg_XSetErrorHandler;
+extern fg_XSetInputFocus_fun                fg_XSetInputFocus;
+extern fg_XSetWMIconName_fun                fg_XSetWMIconName;
+extern fg_XSetWMName_fun                    fg_XSetWMName;
+extern fg_XSetWMProperties_fun              fg_XSetWMProperties;
+extern fg_XSetWMProtocols_fun               fg_XSetWMProtocols;
+extern fg_XStoreColor_fun                   fg_XStoreColor;
+extern fg_XStringListToTextProperty_fun     fg_XStringListToTextProperty;
+extern fg_XSync_fun                         fg_XSync;
+extern fg_XSynchronize_fun                  fg_XSynchronize;
+extern fg_XTranslateCoordinates_fun         fg_XTranslateCoordinates;
+extern fg_XUndefineCursor_fun               fg_XUndefineCursor;
+extern fg_XUngrabKeyboard_fun               fg_XUngrabKeyboard;
+extern fg_XUngrabPointer_fun                fg_XUngrabPointer;
+extern fg_XUnmapWindow_fun                  fg_XUnmapWindow;
+extern fg_XWarpPointer_fun                  fg_XWarpPointer;
+extern fg_XWithdrawWindow_fun               fg_XWithdrawWindow;
+
+int     fg_X_lib_init();
+void    fg_X_lib_destroy();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ! ifdef FG_X_SO_NAME */
+#endif /* ! ifdef FREEGLUT_LIB_SYMS_X_H */
+
--- ./src/x11/fg_lib_X.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./src/x11/fg_lib_X.c	2023-09-20 17:27:28.284000000 +0200
@@ -0,0 +1,399 @@
+/* GENERATED FILE: fg_lib_X.c */
+#include "fg_lib_syms_X.h"
+
+#ifndef FG_X_SO_NAME
+int  fg_X_lib_init() { return 0; }
+void fg_X_lib_destroy() { }
+#else
+
+#include <dlfcn.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+fg_XChangeProperty_fun                  fg_XChangeProperty = NULL;
+fg_XCheckIfEvent_fun                    fg_XCheckIfEvent = NULL;
+fg_XCloseDisplay_fun                    fg_XCloseDisplay = NULL;
+fg_XCreateBitmapFromData_fun            fg_XCreateBitmapFromData = NULL;
+fg_XCreateColormap_fun                  fg_XCreateColormap = NULL;
+fg_XCreateFontCursor_fun                fg_XCreateFontCursor = NULL;
+fg_XCreatePixmapCursor_fun              fg_XCreatePixmapCursor = NULL;
+fg_XCreateWindow_fun                    fg_XCreateWindow = NULL;
+fg_XDefineCursor_fun                    fg_XDefineCursor = NULL;
+fg_XDestroyWindow_fun                   fg_XDestroyWindow = NULL;
+fg_XDisplayName_fun                     fg_XDisplayName = NULL;
+fg_XF86VidModeGetAllModeLines_fun       fg_XF86VidModeGetAllModeLines = NULL;
+fg_XF86VidModeGetModeLine_fun           fg_XF86VidModeGetModeLine = NULL;
+fg_XF86VidModeGetViewPort_fun           fg_XF86VidModeGetViewPort = NULL;
+fg_XF86VidModeQueryExtension_fun        fg_XF86VidModeQueryExtension = NULL;
+fg_XF86VidModeSetViewPort_fun           fg_XF86VidModeSetViewPort = NULL;
+fg_XF86VidModeSwitchToMode_fun          fg_XF86VidModeSwitchToMode = NULL;
+fg_XFlush_fun                           fg_XFlush = NULL;
+fg_XFree_fun                            fg_XFree = NULL;
+fg_XFreeEventData_fun                   fg_XFreeEventData = NULL;
+fg_XFreePixmap_fun                      fg_XFreePixmap = NULL;
+fg_XGetErrorText_fun                    fg_XGetErrorText = NULL;
+fg_XGetEventData_fun                    fg_XGetEventData = NULL;
+fg_XGetPointerMapping_fun               fg_XGetPointerMapping = NULL;
+fg_XGetWindowAttributes_fun             fg_XGetWindowAttributes = NULL;
+fg_XGetWindowProperty_fun               fg_XGetWindowProperty = NULL;
+fg_XGetWMName_fun                       fg_XGetWMName = NULL;
+fg_XGrabKeyboard_fun                    fg_XGrabKeyboard = NULL;
+fg_XGrabPointer_fun                     fg_XGrabPointer = NULL;
+fg_XIconifyWindow_fun                   fg_XIconifyWindow = NULL;
+fg_XInternAtom_fun                      fg_XInternAtom = NULL;
+fg_XISelectEvents_fun                   fg_XISelectEvents = NULL;
+fg_XLookupString_fun                    fg_XLookupString = NULL;
+fg_XLowerWindow_fun                     fg_XLowerWindow = NULL;
+fg_XMapWindow_fun                       fg_XMapWindow = NULL;
+fg_XMoveResizeWindow_fun                fg_XMoveResizeWindow = NULL;
+fg_XMoveWindow_fun                      fg_XMoveWindow = NULL;
+fg_XNextEvent_fun                       fg_XNextEvent = NULL;
+fg_XOpenDisplay_fun                     fg_XOpenDisplay = NULL;
+//fg_XParseGeometry_fun                   fg_XParseGeometry = NULL;
+fg_XPeekIfEvent_fun                     fg_XPeekIfEvent = NULL;
+fg_XPending_fun                         fg_XPending = NULL;
+fg_XPutBackEvent_fun                    fg_XPutBackEvent = NULL;
+fg_XQueryColor_fun                      fg_XQueryColor = NULL;
+fg_XQueryExtension_fun                  fg_XQueryExtension = NULL;
+fg_XQueryKeymap_fun                     fg_XQueryKeymap = NULL;
+fg_XQueryPointer_fun                    fg_XQueryPointer = NULL;
+fg_XRaiseWindow_fun                     fg_XRaiseWindow = NULL;
+fg_XRefreshKeyboardMapping_fun          fg_XRefreshKeyboardMapping = NULL;
+fg_XResizeWindow_fun                    fg_XResizeWindow = NULL;
+fg_XRRConfigCurrentConfiguration_fun    fg_XRRConfigCurrentConfiguration = NULL;
+fg_XRRConfigCurrentRate_fun             fg_XRRConfigCurrentRate = NULL;
+fg_XRRConfigRates_fun                   fg_XRRConfigRates = NULL;
+fg_XRRConfigSizes_fun                   fg_XRRConfigSizes = NULL;
+fg_XRRConfigTimes_fun                   fg_XRRConfigTimes = NULL;
+fg_XRRFreeScreenConfigInfo_fun          fg_XRRFreeScreenConfigInfo = NULL;
+fg_XRRGetScreenInfo_fun                 fg_XRRGetScreenInfo = NULL;
+fg_XRRQueryExtension_fun                fg_XRRQueryExtension = NULL;
+fg_XRRQueryVersion_fun                  fg_XRRQueryVersion = NULL;
+fg_XRRSetScreenConfig_fun               fg_XRRSetScreenConfig = NULL;
+fg_XRRSetScreenConfigAndRate_fun        fg_XRRSetScreenConfigAndRate = NULL;
+fg_XSendEvent_fun                       fg_XSendEvent = NULL;
+fg_XSetCloseDownMode_fun                fg_XSetCloseDownMode = NULL;
+fg_XSetErrorHandler_fun                 fg_XSetErrorHandler = NULL;
+fg_XSetInputFocus_fun                   fg_XSetInputFocus = NULL;
+fg_XSetWMIconName_fun                   fg_XSetWMIconName = NULL;
+fg_XSetWMName_fun                       fg_XSetWMName = NULL;
+fg_XSetWMProperties_fun                 fg_XSetWMProperties = NULL;
+fg_XSetWMProtocols_fun                  fg_XSetWMProtocols = NULL;
+fg_XStoreColor_fun                      fg_XStoreColor = NULL;
+fg_XStringListToTextProperty_fun        fg_XStringListToTextProperty = NULL;
+fg_XSync_fun                            fg_XSync = NULL;
+fg_XSynchronize_fun                     fg_XSynchronize = NULL;
+fg_XTranslateCoordinates_fun            fg_XTranslateCoordinates = NULL;
+fg_XUndefineCursor_fun                  fg_XUndefineCursor = NULL;
+fg_XUngrabKeyboard_fun                  fg_XUngrabKeyboard = NULL;
+fg_XUngrabPointer_fun                   fg_XUngrabPointer = NULL;
+fg_XUnmapWindow_fun                     fg_XUnmapWindow = NULL;
+fg_XWarpPointer_fun                     fg_XWarpPointer = NULL;
+fg_XWithdrawWindow_fun                  fg_XWithdrawWindow = NULL;
+
+static const char * fg_X_lib_names[] = {
+    FG_X_SO_NAME, NULL
+ };
+static void * fg_X_lib[sizeof(fg_X_lib_names)/sizeof(*fg_X_lib_names)] = { NULL, };
+
+static void * fg_X_dlopen(const char * name, int flags) {
+    void * lib;
+    if ((lib = dlopen(name, flags)) == NULL) {
+        size_t len = strlen(name);
+        char * path = len ? strdup(name) : NULL;
+        const char * ext;
+        if (!path) return NULL;
+        if (len > 3 && !strcasecmp((ext = name + len - 3), ".so"))
+            len -= 3;
+        else if (len > 6 && !strcasecmp((ext = name + len - 6), ".dylib"))
+            len -= 6;
+        else
+            ext = NULL;
+        while (len > 0 && (isdigit(path[len-1]) || path[len-1] == '.' || (ext && path[len-1] == '-')))
+            --len; /* loop */
+        while (ext && isdigit(path[len])) ++len;
+        path[len] = 0;
+        if (ext != NULL)
+            strcpy(path + len, ext);
+        lib = dlopen(path, flags);
+        free(path);
+    }
+    return lib;
+}
+
+void * fg_X_findsymbol(const char * name) {
+    void * sym;
+    for (void ** lib = fg_X_lib; *lib != NULL; ++lib) {
+        if ((sym = dlsym(*lib, name)) != NULL)
+            return sym;
+    }
+    return NULL;
+}
+
+int fg_X_lib_init() {
+    int ret = 0, i = 0;
+    if (*fg_X_lib != NULL)
+        return 0;
+    for (const char ** name = fg_X_lib_names; *name != NULL; ++name, ++i) {
+        if (**name == 0) { --i; continue; }
+        if ((fg_X_lib[i] = fg_X_dlopen(*name, RTLD_LOCAL|RTLD_NOW)) == NULL) {
+            return -1;
+        }
+    }
+    fg_X_lib[i] = NULL;
+    if ((fg_XChangeProperty = fg_X_findsymbol("XChangeProperty")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XChangeProperty");
+    if ((fg_XCheckIfEvent = fg_X_findsymbol("XCheckIfEvent")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XCheckIfEvent");
+    if ((fg_XCloseDisplay = fg_X_findsymbol("XCloseDisplay")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XCloseDisplay");
+    if ((fg_XCreateBitmapFromData = fg_X_findsymbol("XCreateBitmapFromData")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XCreateBitmapFromData");
+    if ((fg_XCreateColormap = fg_X_findsymbol("XCreateColormap")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XCreateColormap");
+    if ((fg_XCreateFontCursor = fg_X_findsymbol("XCreateFontCursor")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XCreateFontCursor");
+    if ((fg_XCreatePixmapCursor = fg_X_findsymbol("XCreatePixmapCursor")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XCreatePixmapCursor");
+    if ((fg_XCreateWindow = fg_X_findsymbol("XCreateWindow")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XCreateWindow");
+    if ((fg_XDefineCursor = fg_X_findsymbol("XDefineCursor")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XDefineCursor");
+    if ((fg_XDestroyWindow = fg_X_findsymbol("XDestroyWindow")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XDestroyWindow");
+    if ((fg_XDisplayName = fg_X_findsymbol("XDisplayName")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XDisplayName");
+    if ((fg_XF86VidModeGetAllModeLines = fg_X_findsymbol("XF86VidModeGetAllModeLines")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XF86VidModeGetAllModeLines");
+    if ((fg_XF86VidModeGetModeLine = fg_X_findsymbol("XF86VidModeGetModeLine")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XF86VidModeGetModeLine");
+    if ((fg_XF86VidModeGetViewPort = fg_X_findsymbol("XF86VidModeGetViewPort")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XF86VidModeGetViewPort");
+    if ((fg_XF86VidModeQueryExtension = fg_X_findsymbol("XF86VidModeQueryExtension")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XF86VidModeQueryExtension");
+    if ((fg_XF86VidModeSetViewPort = fg_X_findsymbol("XF86VidModeSetViewPort")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XF86VidModeSetViewPort");
+    if ((fg_XF86VidModeSwitchToMode = fg_X_findsymbol("XF86VidModeSwitchToMode")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XF86VidModeSwitchToMode");
+    if ((fg_XFlush = fg_X_findsymbol("XFlush")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XFlush");
+    if ((fg_XFree = fg_X_findsymbol("XFree")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XFree");
+    if ((fg_XFreeEventData = fg_X_findsymbol("XFreeEventData")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XFreeEventData");
+    if ((fg_XFreePixmap = fg_X_findsymbol("XFreePixmap")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XFreePixmap");
+    if ((fg_XGetErrorText = fg_X_findsymbol("XGetErrorText")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XGetErrorText");
+    if ((fg_XGetEventData = fg_X_findsymbol("XGetEventData")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XGetEventData");
+    if ((fg_XGetPointerMapping = fg_X_findsymbol("XGetPointerMapping")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XGetPointerMapping");
+    if ((fg_XGetWindowAttributes = fg_X_findsymbol("XGetWindowAttributes")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XGetWindowAttributes");
+    if ((fg_XGetWindowProperty = fg_X_findsymbol("XGetWindowProperty")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XGetWindowProperty");
+    if ((fg_XGetWMName = fg_X_findsymbol("XGetWMName")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XGetWMName");
+    if ((fg_XGrabKeyboard = fg_X_findsymbol("XGrabKeyboard")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XGrabKeyboard");
+    if ((fg_XGrabPointer = fg_X_findsymbol("XGrabPointer")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XGrabPointer");
+    if ((fg_XIconifyWindow = fg_X_findsymbol("XIconifyWindow")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XIconifyWindow");
+    if ((fg_XInternAtom = fg_X_findsymbol("XInternAtom")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XInternAtom");
+    if ((fg_XISelectEvents = fg_X_findsymbol("XISelectEvents")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XISelectEvents");
+    if ((fg_XLookupString = fg_X_findsymbol("XLookupString")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XLookupString");
+    if ((fg_XLowerWindow = fg_X_findsymbol("XLowerWindow")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XLowerWindow");
+    if ((fg_XMapWindow = fg_X_findsymbol("XMapWindow")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XMapWindow");
+    if ((fg_XMoveResizeWindow = fg_X_findsymbol("XMoveResizeWindow")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XMoveResizeWindow");
+    if ((fg_XMoveWindow = fg_X_findsymbol("XMoveWindow")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XMoveWindow");
+    if ((fg_XNextEvent = fg_X_findsymbol("XNextEvent")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XNextEvent");
+    if ((fg_XOpenDisplay = fg_X_findsymbol("XOpenDisplay")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XOpenDisplay");
+/*    if ((fg_XParseGeometry = fg_X_findsymbol("XParseGeometry")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XParseGeometry");*/
+    if ((fg_XPeekIfEvent = fg_X_findsymbol("XPeekIfEvent")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XPeekIfEvent");
+    if ((fg_XPending = fg_X_findsymbol("XPending")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XPending");
+    if ((fg_XPutBackEvent = fg_X_findsymbol("XPutBackEvent")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XPutBackEvent");
+    if ((fg_XQueryColor = fg_X_findsymbol("XQueryColor")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XQueryColor");
+    if ((fg_XQueryExtension = fg_X_findsymbol("XQueryExtension")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XQueryExtension");
+    if ((fg_XQueryKeymap = fg_X_findsymbol("XQueryKeymap")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XQueryKeymap");
+    if ((fg_XQueryPointer = fg_X_findsymbol("XQueryPointer")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XQueryPointer");
+    if ((fg_XRaiseWindow = fg_X_findsymbol("XRaiseWindow")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XRaiseWindow");
+    if ((fg_XRefreshKeyboardMapping = fg_X_findsymbol("XRefreshKeyboardMapping")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XRefreshKeyboardMapping");
+    if ((fg_XResizeWindow = fg_X_findsymbol("XResizeWindow")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XResizeWindow");
+    if ((fg_XRRConfigCurrentConfiguration = fg_X_findsymbol("XRRConfigCurrentConfiguration")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XRRConfigCurrentConfiguration");
+    if ((fg_XRRConfigCurrentRate = fg_X_findsymbol("XRRConfigCurrentRate")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XRRConfigCurrentRate");
+    if ((fg_XRRConfigRates = fg_X_findsymbol("XRRConfigRates")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XRRConfigRates");
+    if ((fg_XRRConfigSizes = fg_X_findsymbol("XRRConfigSizes")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XRRConfigSizes");
+    if ((fg_XRRConfigTimes = fg_X_findsymbol("XRRConfigTimes")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XRRConfigTimes");
+    if ((fg_XRRFreeScreenConfigInfo = fg_X_findsymbol("XRRFreeScreenConfigInfo")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XRRFreeScreenConfigInfo");
+    if ((fg_XRRGetScreenInfo = fg_X_findsymbol("XRRGetScreenInfo")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XRRGetScreenInfo");
+    if ((fg_XRRQueryExtension = fg_X_findsymbol("XRRQueryExtension")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XRRQueryExtension");
+    if ((fg_XRRQueryVersion = fg_X_findsymbol("XRRQueryVersion")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XRRQueryVersion");
+    if ((fg_XRRSetScreenConfig = fg_X_findsymbol("XRRSetScreenConfig")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XRRSetScreenConfig");
+    if ((fg_XRRSetScreenConfigAndRate = fg_X_findsymbol("XRRSetScreenConfigAndRate")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XRRSetScreenConfigAndRate");
+    if ((fg_XSendEvent = fg_X_findsymbol("XSendEvent")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XSendEvent");
+    if ((fg_XSetCloseDownMode = fg_X_findsymbol("XSetCloseDownMode")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XSetCloseDownMode");
+    if ((fg_XSetErrorHandler = fg_X_findsymbol("XSetErrorHandler")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XSetErrorHandler");
+    if ((fg_XSetInputFocus = fg_X_findsymbol("XSetInputFocus")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XSetInputFocus");
+    if ((fg_XSetWMIconName = fg_X_findsymbol("XSetWMIconName")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XSetWMIconName");
+    if ((fg_XSetWMName = fg_X_findsymbol("XSetWMName")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XSetWMName");
+    if ((fg_XSetWMProperties = fg_X_findsymbol("XSetWMProperties")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XSetWMProperties");
+    if ((fg_XSetWMProtocols = fg_X_findsymbol("XSetWMProtocols")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XSetWMProtocols");
+    if ((fg_XStoreColor = fg_X_findsymbol("XStoreColor")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XStoreColor");
+    if ((fg_XStringListToTextProperty = fg_X_findsymbol("XStringListToTextProperty")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XStringListToTextProperty");
+    if ((fg_XSync = fg_X_findsymbol("XSync")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XSync");
+    if ((fg_XSynchronize = fg_X_findsymbol("XSynchronize")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XSynchronize");
+    if ((fg_XTranslateCoordinates = fg_X_findsymbol("XTranslateCoordinates")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XTranslateCoordinates");
+    if ((fg_XUndefineCursor = fg_X_findsymbol("XUndefineCursor")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XUndefineCursor");
+    if ((fg_XUngrabKeyboard = fg_X_findsymbol("XUngrabKeyboard")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XUngrabKeyboard");
+    if ((fg_XUngrabPointer = fg_X_findsymbol("XUngrabPointer")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XUngrabPointer");
+    if ((fg_XUnmapWindow = fg_X_findsymbol("XUnmapWindow")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XUnmapWindow");
+    if ((fg_XWarpPointer = fg_X_findsymbol("XWarpPointer")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XWarpPointer");
+    if ((fg_XWithdrawWindow = fg_X_findsymbol("XWithdrawWindow")) == NULL && ++ret)
+        fgWarning("cannot load symbol %s", "XWithdrawWindow");
+    return ret;
+}
+
+void fg_X_lib_destroy() {
+    if (*fg_X_lib == NULL)
+        return ;
+    for (void ** lib = fg_X_lib; *lib; ++lib) {
+        dlclose(*lib);
+        *lib = NULL;
+    }
+    fg_XChangeProperty = NULL;
+    fg_XCheckIfEvent = NULL;
+    fg_XCloseDisplay = NULL;
+    fg_XCreateBitmapFromData = NULL;
+    fg_XCreateColormap = NULL;
+    fg_XCreateFontCursor = NULL;
+    fg_XCreatePixmapCursor = NULL;
+    fg_XCreateWindow = NULL;
+    fg_XDefineCursor = NULL;
+    fg_XDestroyWindow = NULL;
+    fg_XDisplayName = NULL;
+    fg_XF86VidModeGetAllModeLines = NULL;
+    fg_XF86VidModeGetModeLine = NULL;
+    fg_XF86VidModeGetViewPort = NULL;
+    fg_XF86VidModeQueryExtension = NULL;
+    fg_XF86VidModeSetViewPort = NULL;
+    fg_XF86VidModeSwitchToMode = NULL;
+    fg_XFlush = NULL;
+    fg_XFree = NULL;
+    fg_XFreeEventData = NULL;
+    fg_XFreePixmap = NULL;
+    fg_XGetErrorText = NULL;
+    fg_XGetEventData = NULL;
+    fg_XGetPointerMapping = NULL;
+    fg_XGetWindowAttributes = NULL;
+    fg_XGetWindowProperty = NULL;
+    fg_XGetWMName = NULL;
+    fg_XGrabKeyboard = NULL;
+    fg_XGrabPointer = NULL;
+    fg_XIconifyWindow = NULL;
+    fg_XInternAtom = NULL;
+    fg_XISelectEvents = NULL;
+    fg_XLookupString = NULL;
+    fg_XLowerWindow = NULL;
+    fg_XMapWindow = NULL;
+    fg_XMoveResizeWindow = NULL;
+    fg_XMoveWindow = NULL;
+    fg_XNextEvent = NULL;
+    fg_XOpenDisplay = NULL;
+//    fg_XParseGeometry = NULL;
+    fg_XPeekIfEvent = NULL;
+    fg_XPending = NULL;
+    fg_XPutBackEvent = NULL;
+    fg_XQueryColor = NULL;
+    fg_XQueryExtension = NULL;
+    fg_XQueryKeymap = NULL;
+    fg_XQueryPointer = NULL;
+    fg_XRaiseWindow = NULL;
+    fg_XRefreshKeyboardMapping = NULL;
+    fg_XResizeWindow = NULL;
+    fg_XRRConfigCurrentConfiguration = NULL;
+    fg_XRRConfigCurrentRate = NULL;
+    fg_XRRConfigRates = NULL;
+    fg_XRRConfigSizes = NULL;
+    fg_XRRConfigTimes = NULL;
+    fg_XRRFreeScreenConfigInfo = NULL;
+    fg_XRRGetScreenInfo = NULL;
+    fg_XRRQueryExtension = NULL;
+    fg_XRRQueryVersion = NULL;
+    fg_XRRSetScreenConfig = NULL;
+    fg_XRRSetScreenConfigAndRate = NULL;
+    fg_XSendEvent = NULL;
+    fg_XSetCloseDownMode = NULL;
+    fg_XSetErrorHandler = NULL;
+    fg_XSetInputFocus = NULL;
+    fg_XSetWMIconName = NULL;
+    fg_XSetWMName = NULL;
+    fg_XSetWMProperties = NULL;
+    fg_XSetWMProtocols = NULL;
+    fg_XStoreColor = NULL;
+    fg_XStringListToTextProperty = NULL;
+    fg_XSync = NULL;
+    fg_XSynchronize = NULL;
+    fg_XTranslateCoordinates = NULL;
+    fg_XUndefineCursor = NULL;
+    fg_XUngrabKeyboard = NULL;
+    fg_XUngrabPointer = NULL;
+    fg_XUnmapWindow = NULL;
+    fg_XWarpPointer = NULL;
+    fg_XWithdrawWindow = NULL;
+    return ;
+}
+
+#endif /* ! ifdef FG_X_SO_NAME */
+
--- ./src/x11/fg_main_x11.c.orig	2023-09-27 13:31:29.750000000 +0200
+++ ./src/x11/fg_main_x11.c	2023-09-18 17:45:45.047000000 +0200
@@ -30,7 +30,7 @@
 #include "../fg_internal.h"
 #include <errno.h>
 #include <stdarg.h>
-
+#include "fg_private_x11.h"
 
 /*
  * Try to get the maximum value allowed for ints, falling back to the minimum
@@ -49,14 +49,14 @@
 
 extern void fghOnReshapeNotify(SFG_Window *window, int width, int height, GLboolean forceNotify);
 extern void fghOnPositionNotify(SFG_Window *window, int x, int y, GLboolean forceNotify);
-extern void fgPlatformFullScreenToggle( SFG_Window *win );
-extern void fgPlatformPositionWindow( SFG_Window *window, int x, int y );
-extern void fgPlatformReshapeWindow ( SFG_Window *window, int width, int height );
-extern void fgPlatformPushWindow( SFG_Window *window );
-extern void fgPlatformPopWindow( SFG_Window *window );
-extern void fgPlatformHideWindow( SFG_Window *window );
-extern void fgPlatformIconifyWindow( SFG_Window *window );
-extern void fgPlatformShowWindow( SFG_Window *window );
+extern void fgPlatformFullScreenToggle_X11( SFG_Window *win );
+extern void fgPlatformPositionWindow_X11( SFG_Window *window, int x, int y );
+extern void fgPlatformReshapeWindow_X11 ( SFG_Window *window, int width, int height );
+extern void fgPlatformPushWindow_X11( SFG_Window *window );
+extern void fgPlatformPopWindow_X11( SFG_Window *window );
+extern void fgPlatformHideWindow_X11( SFG_Window *window );
+extern void fgPlatformIconifyWindow_X11( SFG_Window *window );
+extern void fgPlatformShowWindow_X11( SFG_Window *window );
 
 /* used in the event handling code to match and discard stale mouse motion events */
 static Bool match_motion(Display *dpy, XEvent *xev, XPointer arg);
@@ -70,10 +70,10 @@
  * Need to investigate why the X11 version breaks out with an error when
  * closing a window (using the window manager, not glutDestroyWindow)...
  */
- 
- 
 
-fg_time_t fgPlatformSystemTime ( void )
+
+
+fg_time_t fgPlatformSystemTime_X11 ( void )
 {
 #ifdef CLOCK_MONOTONIC
     struct timespec now;
@@ -91,7 +91,7 @@
  * happens.
  */
 
-void fgPlatformSleepForEvents( fg_time_t msec )
+void fgPlatformSleepForEvents_X11( fg_time_t msec )
 {
     /*
      * Possibly due to aggressive use of XFlush() and friends,
@@ -125,7 +125,7 @@
 /*
  * Returns GLUT modifier mask for the state field of an X11 event.
  */
-int fgPlatformGetModifiers( int state )
+int fgPlatformGetModifiers_X11( int state )
 {
     int ret = 0;
 
@@ -580,14 +580,16 @@
 #endif
 
 
-void fgPlatformProcessSingleEvent ( void )
+void fgPlatformProcessSingleEvent_X11 ( void )
 {
     SFG_Window* window;
     XEvent event;
+    SFG_WindowHandleType handle;
 
     /* This code was repeated constantly, so here it goes into a definition: */
 #define GETWINDOW(a)                             \
-    window = fgWindowByHandle( event.a.window ); \
+    handle.ptr = (void*) event.a.window;         \
+    window = fgWindowByHandle( handle );         \
     if( window == NULL )                         \
         break;
 
@@ -608,8 +610,8 @@
         {
         case ClientMessage:
             if (fgStructure.CurrentWindow)
-                if(fgIsSpaceballXEvent(&event)) {
-                    fgSpaceballHandleXEvent(&event);
+                if(fgIsSpaceballXEvent_X11(&event)) {
+                    fgSpaceballHandleXEvent_X11(&event);
                     break;
                 }
             /* Destroy the window when the WM_DELETE_WINDOW message arrives */
@@ -695,7 +697,7 @@
             break;
 
         case UnmapNotify:
-            /* We get this when iconifying a window. */ 
+            /* We get this when iconifying a window. */
             GETWINDOW( xunmap );
             INVOKE_WCB( *window, WindowStatus, ( GLUT_HIDDEN ) );
             window->State.Visible = GL_FALSE;
@@ -792,7 +794,7 @@
              * XXX track ButtonPress/ButtonRelease events in our own
              * XXX bit-mask?
              */
-            fgState.Modifiers = fgPlatformGetModifiers( event.xmotion.state );
+            fgState.Modifiers = fgPlatformGetModifiers_X11( event.xmotion.state );
             if ( event.xmotion.state & ( Button1Mask | Button2Mask | Button3Mask | Button4Mask | Button5Mask ) ) {
                 INVOKE_WCB( *window, Motion, ( event.xmotion.x,
                                                event.xmotion.y ) );
@@ -845,7 +847,7 @@
             if(!FETCH_WCB(*window, Mouse) && !FETCH_WCB(*window, MouseWheel))
                 break;
 
-            fgState.Modifiers = fgPlatformGetModifiers(event.xbutton.state);
+            fgState.Modifiers = fgPlatformGetModifiers_X11(event.xbutton.state);
 
             /* Finally execute the mouse or mouse wheel callback.
              * The mouse wheel is reported as buttons 4 (down) and 5 (up) by
@@ -951,7 +953,7 @@
                     if( keyboard_cb )
                     {
                         fgSetWindow( window );
-                        fgState.Modifiers = fgPlatformGetModifiers( event.xkey.state );
+                        fgState.Modifiers = fgPlatformGetModifiers_X11( event.xkey.state );
                         for (unsigned int i = 0; i < len; ++i) {
                             keyboard_cb( asciiCode[ i ],
                                          event.xkey.x, event.xkey.y,
@@ -1033,7 +1035,7 @@
                     if( special_cb && (special != -1) )
                     {
                         fgSetWindow( window );
-                        fgState.Modifiers = fgPlatformGetModifiers( event.xkey.state );
+                        fgState.Modifiers = fgPlatformGetModifiers_X11( event.xkey.state );
                         special_cb( special, event.xkey.x, event.xkey.y, special_ud );
                         fgState.Modifiers = INVALID_MODIFIERS;
                     }
@@ -1065,15 +1067,15 @@
     return xev->type == MotionNotify;
 }
 
-void fgPlatformMainLoopPreliminaryWork ( void )
+void fgPlatformMainLoopPreliminaryWork_X11 ( void )
 {
 }
 
 
 /* deal with work list items */
-void fgPlatformInitWork(SFG_Window* window)
+void fgPlatformInitWork_X11(SFG_Window* window)
 {
-    /* Notify windowStatus/visibility, position and size get notified on window creation with message handlers above 
+    /* Notify windowStatus/visibility, position and size get notified on window creation with message handlers above
      * XXX CHECK: do the messages happen too early like on windows, so client code cannot have registered
      * a callback yet and the message is thus never received by client?
      * -> this is a no-op
@@ -1081,42 +1083,42 @@
      return;
 }
 
-void fgPlatformPosResZordWork(SFG_Window* window, unsigned int workMask)
+void fgPlatformPosResZordWork_X11(SFG_Window* window, unsigned int workMask)
 {
     if (workMask & GLUT_FULL_SCREEN_WORK)
-        fgPlatformFullScreenToggle( window );
+        fgPlatformFullScreenToggle_X11( window );
     if (workMask & GLUT_POSITION_WORK)
-        fgPlatformPositionWindow( window, window->State.DesiredXpos, window->State.DesiredYpos );
+        fgPlatformPositionWindow_X11( window, window->State.DesiredXpos, window->State.DesiredYpos );
     if (workMask & GLUT_SIZE_WORK)
-        fgPlatformReshapeWindow ( window, window->State.DesiredWidth, window->State.DesiredHeight );
+        fgPlatformReshapeWindow_X11 ( window, window->State.DesiredWidth, window->State.DesiredHeight );
     if (workMask & GLUT_ZORDER_WORK)
     {
         if (window->State.DesiredZOrder < 0)
-            fgPlatformPushWindow( window );
+            fgPlatformPushWindow_X11( window );
         else
-            fgPlatformPopWindow( window );
+            fgPlatformPopWindow_X11( window );
     }
 }
 
-void fgPlatformVisibilityWork(SFG_Window* window)
+void fgPlatformVisibilityWork_X11(SFG_Window* window)
 {
-    /* Visibility status of window gets updated in the window message handlers above 
+    /* Visibility status of window gets updated in the window message handlers above
      * XXX: is this really the case? check
      */
     SFG_Window *win = window;
     switch (window->State.DesiredVisibility)
     {
     case DesireHiddenState:
-        fgPlatformHideWindow( window );
+        fgPlatformHideWindow_X11( window );
         break;
     case DesireIconicState:
         /* Call on top-level window */
         while (win->Parent)
             win = win->Parent;
-        fgPlatformIconifyWindow( win );
+        fgPlatformIconifyWindow_X11( win );
         break;
     case DesireNormalState:
-        fgPlatformShowWindow( window );
+        fgPlatformShowWindow_X11( window );
         break;
     }
 }
--- ./src/x11/fg_menu_x11.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/x11/fg_menu_x11.c	2023-09-17 20:22:30.750308000 +0200
@@ -28,11 +28,12 @@
 
 #include <GL/freeglut.h>
 #include "../fg_internal.h"
+#include "fg_private_x11.h"
 
 /*
  *  * Private function to get the virtual maximum screen extent
  *   */
-GLvoid fgPlatformGetGameModeVMaxExtent( SFG_Window* window, int* x, int* y )
+GLvoid fgPlatformGetGameModeVMaxExtent_X11( SFG_Window* window, int* x, int* y )
 {
     int wx, wy;
     Window w;
--- ./src/x11/fg_private_x11.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./src/x11/fg_private_x11.h	2023-09-19 21:03:19.765833423 +0200
@@ -0,0 +1,31 @@
+#ifndef FREEGLUT_X11_FG_PRIVATE_X11
+#define FREEGLUT_X11_FG_PRIVATE_X11
+
+#if !defined(EGL_VERSION_1_0) || !defined(FREEGLUT_GLES)
+#define Handle      Handle.Handle_X11
+#define Context     Context.Context_X11
+#define cmap        cmap.cmap_X11
+#define MContext    MContext.Context_X11
+#undef EGL_VERSION_1_0
+#else
+#define Handle      Handle.Handle_EGL
+#define Context     Context.Context_EGL
+#define cmap        cmap.cmap_EGL
+#define MContext    MContext.Context_EGL
+#endif
+
+#define pContext    pContext.pContext_X11
+#define pDisplay    pDisplay.pDisplay_X11
+#define pWState     pWState.pWState_X11
+
+#if !TARGET_HOST_POSIX_X11 && TARGET_HOST_POSIX_WAYLAND
+#define pJoystick   pJoystick.pJoystick_WL
+#else
+#define pJoystick   pJoystick.pJoystick_X11
+#endif
+
+#define SFG_PlatformDisplay SFG_PlatformDisplay.SFG_PlatformDisplay_X11
+
+#include "fg_lib_syms_X.h"
+
+#endif // ! ifndef FREEGLUT_X11_FG_PRIVATE_X11
--- ./src/x11/fg_spaceball_x11.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/x11/fg_spaceball_x11.c	2023-09-18 17:34:30.991000000 +0200
@@ -11,6 +11,7 @@
 
 #include <GL/freeglut.h>
 #include "../fg_internal.h"
+#include "fg_private_x11.h"
 
 #include <X11/Xlib.h>
 
@@ -52,7 +53,7 @@
 
 static SFG_Window *spnav_win;
 
-void fgPlatformInitializeSpaceball(void)
+void fgPlatformInitializeSpaceball_X11(void)
 {
     Window w;
 
@@ -71,12 +72,12 @@
     }
 }
 
-void fgPlatformSpaceballClose(void) 
+void fgPlatformSpaceballClose_X11(void)
 {
     spnav_close();
 }
 
-int fgPlatformHasSpaceball(void) 
+int fgPlatformHasSpaceball_X11(void)
 {
     /* XXX this function should somehow query the driver if there's a device
      * plugged in, as opposed to just checking if there's a driver to talk to.
@@ -84,11 +85,11 @@
     return spnav_fd() == -1 ? 0 : 1;
 }
 
-int fgPlatformSpaceballNumButtons(void) {
+int fgPlatformSpaceballNumButtons_X11(void) {
     return 2;
 }
 
-void fgPlatformSpaceballSetWindow(SFG_Window *window) 
+void fgPlatformSpaceballSetWindow_X11(SFG_Window *window)
 {
        if(spnav_win != window) {
         spnav_x11_window(window->Window.Handle);
@@ -96,7 +97,7 @@
     }
 }
 
-int fgIsSpaceballXEvent(const XEvent *xev)
+int fgIsSpaceballXEvent_X11(const XEvent *xev)
 {
     spnav_event sev;
 
@@ -112,7 +113,7 @@
     return spnav_x11_event(xev, &sev);
 }
 
-void fgSpaceballHandleXEvent(const XEvent *xev)
+void fgSpaceballHandleXEvent_X11(const XEvent *xev)
 {
     spnav_event sev;
 
--- ./src/x11/fg_state_x11.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/x11/fg_state_x11.c	2023-09-18 17:42:16.075000000 +0200
@@ -27,13 +27,14 @@
 
 #include <GL/freeglut.h>
 #include "fg_internal.h"
+#include "fg_private_x11.h"
 #ifdef EGL_VERSION_1_0
 #include "egl/fg_state_egl.h"
 #else
 #include "x11/fg_state_x11_glx.h"
 #endif
 
-int fgPlatformGlutDeviceGet ( GLenum eWhat )
+int fgPlatformGlutDeviceGet_X11 ( GLenum eWhat )
 {
     switch( eWhat )
     {
@@ -73,7 +74,7 @@
 }
 
 
-int fgPlatformGlutGet ( GLenum eWhat )
+int fgPlatformGlutGet_X11 ( GLenum eWhat )
 {
     switch( eWhat )
     {
@@ -98,7 +99,7 @@
             p = fgStructure.CurrentWindow->Parent->Window.Handle;
         else
             p = fgDisplay.pDisplay.RootWindow;
-            
+
         XTranslateCoordinates(
             fgDisplay.pDisplay.Display,
             fgStructure.CurrentWindow->Window.Handle,
@@ -111,7 +112,7 @@
         case GLUT_WINDOW_Y: return y;
         }
     }
-    
+
     case GLUT_WINDOW_BORDER_WIDTH:
     case GLUT_WINDOW_HEADER_HEIGHT:
     {
@@ -120,19 +121,19 @@
         unsigned long nitems, bytes_after;
         unsigned char *data = NULL;
         int result, top, left;
-        
+
         if (fgStructure.CurrentWindow == NULL || fgStructure.CurrentWindow->Parent)
             /* can't get widths/heights if no current window
              * and child windows don't have borders */
             return 0;
-        
+
         /* try to get through _NET_FRAME_EXTENTS */
         net_extents = XInternAtom(fgDisplay.pDisplay.Display, "_NET_FRAME_EXTENTS", False);
-        
+
         result = XGetWindowProperty(
             fgDisplay.pDisplay.Display, fgStructure.CurrentWindow->Window.Handle, net_extents,
-            0, 4, False, AnyPropertyType, 
-            &actual_type, &actual_format, 
+            0, 4, False, AnyPropertyType,
+            &actual_type, &actual_format,
             &nitems, &bytes_after, &data);
 
         if (result == Success && nitems == 4 && bytes_after == 0)
@@ -149,22 +150,22 @@
             /* try in the previous way as fall-back */
             Window w;
             int x,y;
-            
+
             XTranslateCoordinates(
                 fgDisplay.pDisplay.Display,
                 fgStructure.CurrentWindow->Window.Handle,
                 fgDisplay.pDisplay.RootWindow,
                 0, 0, &x, &y, &w);
-            
+
             if (w == 0)
                 /* logic below needs w */
                 return 0;
-            
+
             XTranslateCoordinates(
                 fgDisplay.pDisplay.Display,
                 fgStructure.CurrentWindow->Window.Handle,
-                w, 0, 0, &x, &y, &w);  
-            
+                w, 0, 0, &x, &y, &w);
+
             left = x;
             top  = y;
         }
@@ -196,12 +197,12 @@
         case GLUT_WINDOW_HEIGHT:           return winAttributes.height ;
         }
     }
-    
+
     /* Colormap size is handled in a bit different way than all the rest */
     case GLUT_WINDOW_COLORMAP_SIZE:
         if(
 #ifndef EGL_VERSION_1_0
-	   fgPlatformGetConfig( GLX_RGBA ) ||
+	   fgPlatformGetConfig_X11( GLX_RGBA ) ||
 #endif
 	   fgStructure.CurrentWindow == NULL)
         {
@@ -219,8 +220,8 @@
 	  EGLint vid = 0;
 	  XVisualInfo visualTemplate;
 	  int num_visuals;
-	  if (!eglGetConfigAttrib(fgDisplay.pDisplay.egl.Display,
-				  fgStructure.CurrentWindow->Window.pContext.egl.Config,
+	  if (!eglGetConfigAttrib(fgDisplay.egl.Display,
+				  fgStructure.CurrentWindow->Window.eglContext.Config,
 				  EGL_NATIVE_VISUAL_ID, &vid))
 	    fgError("eglGetConfigAttrib(EGL_NATIVE_VISUAL_ID) failed");
 	  visualTemplate.visualid = vid;
--- ./src/x11/fg_state_x11_glx.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/x11/fg_state_x11_glx.c	2023-09-17 21:45:38.126749999 +0200
@@ -28,6 +28,7 @@
 #include <GL/freeglut.h>
 #include "fg_internal.h"
 #include "x11/fg_window_x11_glx.h"
+#include "fg_private_x11.h"
 
 #ifndef GL_SAMPLES
 #define GL_SAMPLES	0x80a9
@@ -36,7 +37,7 @@
 /*
  * Queries the GL context about some attributes
  */
-int fgPlatformGetConfig(int attribute)
+int fgPlatformGetConfig_X11(int attribute)
 {
 	int res, retval = 0;
 	Display *dpy;
@@ -73,7 +74,7 @@
     {
     /*
      * The window/context specific queries are handled mostly by
-     * fgPlatformGetConfig().
+     * fgPlatformGetConfig_X11().
      */
     case GLUT_WINDOW_NUM_SAMPLES:
       {
@@ -89,7 +90,7 @@
      * The rest of GLX queries under X are general enough to use a macro to
      * check them
      */
-#   define GLX_QUERY(a,b) case a: return fgPlatformGetConfig( b );
+#   define GLX_QUERY(a,b) case a: return fgPlatformGetConfig_X11( b );
 
     GLX_QUERY( GLUT_WINDOW_RGBA,                GLX_RGBA                );
     GLX_QUERY( GLUT_WINDOW_DOUBLEBUFFER,        GLX_DOUBLEBUFFER        );
@@ -118,7 +119,7 @@
 #else
 		XVisualInfo *config;
 #endif
-        return fghChooseConfig(&config);
+        return fghChooseConfig_X11(&config);
     }
 
     /* This is system-dependent */
@@ -127,7 +128,7 @@
             return 0;
 
 #ifdef USE_FBCONFIG
-        return fgPlatformGetConfig( GLX_VISUAL_ID );
+        return fgPlatformGetConfig_X11( GLX_VISUAL_ID );
 #else
 		return fgStructure.CurrentWindow->Window.pContext.visinf->visualid;
 #endif
@@ -141,7 +142,7 @@
 }
 
 #ifdef USE_FBCONFIG
-int *fgPlatformGlutGetModeValues(GLenum eWhat, int *size)
+int *fgPlatformGlutGetModeValues_X11(GLenum eWhat, int *size)
 {
   int *array;
 
@@ -247,7 +248,7 @@
 
 #else	/* !def USE_FBCONFIG */
 
-int *fgPlatformGlutGetModeValues(GLenum what, int *size)
+int *fgPlatformGlutGetModeValues_X11(GLenum what, int *size)
 {
 	/* TODO */
 	*size = 0;
--- ./src/x11/fg_state_x11_glx.h.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/x11/fg_state_x11_glx.h	2023-09-18 17:25:39.719000000 +0200
@@ -29,7 +29,7 @@
 #ifndef __FG_STATE_X11_GLX_H__
 #define __FG_STATE_X11_GLX_H__
 
-int fgPlatformGetConfig(int attribute);
+int fgPlatformGetConfig_X11(int attribute);
 int fghPlatformGlutGetGLX(GLenum eWhat);
 
 #endif
--- ./src/x11/fg_structure_x11.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/x11/fg_structure_x11.c	2023-09-17 20:22:50.268062009 +0200
@@ -31,10 +31,11 @@
 #ifdef EGL_VERSION_1_0
 #include "egl/fg_structure_egl.h"
 #endif
+#include "fg_private_x11.h"
 
 extern SFG_Structure fgStructure;
 
-void fgPlatformCreateWindow ( SFG_Window *window )
+void fgPlatformCreateWindow_X11 ( SFG_Window *window )
 {
 #ifdef EGL_VERSION_1_0
     fghPlatformCreateWindowEGL(window);
--- ./src/x11/fg_window_x11.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/x11/fg_window_x11.c	2023-09-18 14:33:09.913964274 +0200
@@ -33,12 +33,16 @@
 #include <sys/types.h>  /* pid_t */
 #include "../fg_internal.h"
 
-#ifdef EGL_VERSION_1_0
+#if defined(EGL_VERSION_1_0) && defined(FREEGLUT_GLES)
 #include "egl/fg_window_egl.h"
 #define fghCreateNewContext fghCreateNewContextEGL
+#define fghChooseConfig     fghChooseConfig_EGL
 #else
 #include "x11/fg_window_x11_glx.h"
+#define fghCreateNewContext fghCreateNewContext_X11
+#define fghChooseConfig     fghChooseConfig_X11
 #endif
+#include "fg_private_x11.h"
 
 #ifndef HOST_NAME_MAX
 #define HOST_NAME_MAX	255
@@ -140,7 +144,7 @@
  * Opens a window. Requires a SFG_Window object created and attached
  * to the freeglut structure. OpenGL context is created here.
  */
-void fgPlatformOpenWindow( SFG_Window* window, const char* title,
+void fgPlatformOpenWindow_X11( SFG_Window* window, const char* title,
                            GLboolean positionUse, int x, int y,
                            GLboolean sizeUse, int w, int h,
                            GLboolean gameMode, GLboolean isSubWindow )
@@ -149,7 +153,7 @@
 	Window rootwin = fgDisplay.pDisplay.RootWindow;
 	Window parent = window->Parent ? window->Parent->Window.Handle : 0;
 	Window win;
-	Colormap cmap;
+	Colormap cmap_;
 	XVisualInfo * visualInfo = NULL;
 	XSetWindowAttributes wattr;
 	XTextProperty txprop;
@@ -173,7 +177,7 @@
 	}
 
 #ifdef EGL_VERSION_1_0
-#define WINDOW_CONFIG window->Window.pContext.egl.Config
+#define WINDOW_CONFIG window->Window.eglContext.Config
 #else
 #ifdef USE_FBCONFIG
 #define WINDOW_CONFIG window->Window.pContext.FBConfig
@@ -231,7 +235,7 @@
 
 	/*  Get the X visual.  */
 #ifdef EGL_VERSION_1_0
-	if(!eglGetConfigAttrib(fgDisplay.pDisplay.egl.Display, window->Window.pContext.egl.Config, EGL_NATIVE_VISUAL_ID, &vid)) {
+	if(!eglGetConfigAttrib(fgDisplay.egl.Display, window->Window.eglContext.Config, EGL_NATIVE_VISUAL_ID, &vid)) {
 		fgError("eglGetConfigAttrib(EGL_NATIVE_VISUAL_ID) failed");
 	}
 	visualTemplate.visualid = vid;
@@ -248,15 +252,15 @@
 #endif  /* GLX part */
 
 	if(fgState.DisplayMode & GLUT_INDEX) {
-		cmap = XCreateColormap(dpy, rootwin, visualInfo->visual, AllocAll);
-		FREEGLUT_INTERNAL_ERROR_EXIT(cmap,
+		cmap_ = XCreateColormap(dpy, rootwin, visualInfo->visual, AllocAll);
+		FREEGLUT_INTERNAL_ERROR_EXIT(cmap_,
 				"Failed to allocate the whole colormap, which is required in index color mode", "fgOpenWindow");
 		window->Window.cmap_size = visualInfo->colormap_size;
 	} else {
-		cmap = XCreateColormap(dpy, rootwin, visualInfo->visual, AllocNone);
+		cmap_ = XCreateColormap(dpy, rootwin, visualInfo->visual, AllocNone);
 		window->Window.cmap_size = 0;
 	}
-	window->Window.cmap = cmap;
+	window->Window.cmap = cmap_;
 
 	/*
 	 * XXX HINT: the masks should be updated when adding/removing callbacks.
@@ -280,7 +284,7 @@
 	wattr.background_pixmap = None;
 	wattr.background_pixel  = 0;
 	wattr.border_pixel      = 0;
-	wattr.colormap = cmap;
+	wattr.colormap = cmap_;
 
 	mask = CWBackPixmap | CWBorderPixel | CWColormap | CWEventMask;
 
@@ -448,7 +452,7 @@
 /*
  * Request a window resize
  */
-void fgPlatformReshapeWindow ( SFG_Window *window, int width, int height )
+void fgPlatformReshapeWindow_X11 ( SFG_Window *window, int width, int height )
 {
     XResizeWindow( fgDisplay.pDisplay.Display, window->Window.Handle,
                    width, height );
@@ -459,7 +463,7 @@
 /*
  * Closes a window, destroying the frame and OpenGL context
  */
-void fgPlatformCloseWindow( SFG_Window* window )
+void fgPlatformCloseWindow_X11( SFG_Window* window )
 {
 #ifdef EGL_VERSION_1_0
     fghPlatformCloseWindowEGL(window);
@@ -484,7 +488,7 @@
 /*
  * This function makes the specified window visible
  */
-void fgPlatformShowWindow( SFG_Window *window )
+void fgPlatformShowWindow_X11( SFG_Window *window )
 {
     XMapWindow( fgDisplay.pDisplay.Display, window->Window.Handle );
     XFlush( fgDisplay.pDisplay.Display ); /* XXX Shouldn't need this */
@@ -493,7 +497,7 @@
 /*
  * This function hides the specified window
  */
-void fgPlatformHideWindow( SFG_Window *window )
+void fgPlatformHideWindow_X11( SFG_Window *window )
 {
     if( window->Parent == NULL )
         XWithdrawWindow( fgDisplay.pDisplay.Display,
@@ -508,7 +512,7 @@
 /*
  * Iconify the specified window (top-level windows only)
  */
-void fgPlatformIconifyWindow( SFG_Window *window )
+void fgPlatformIconifyWindow_X11( SFG_Window *window )
 {
     XIconifyWindow( fgDisplay.pDisplay.Display, window->Window.Handle,
                     fgDisplay.pDisplay.Screen );
@@ -520,7 +524,7 @@
 /*
  * Set the current window's title
  */
-void fgPlatformGlutSetWindowTitle( const char* title )
+void fgPlatformGlutSetWindowTitle_X11( const char* title )
 {
     XTextProperty text;
 
@@ -541,7 +545,7 @@
 /*
  * Set the current window's iconified title
  */
-void fgPlatformGlutSetIconTitle( const char* title )
+void fgPlatformGlutSetIconTitle_X11( const char* title )
 {
     XTextProperty text;
 
@@ -562,7 +566,7 @@
 /*
  * Change the specified window's position
  */
-void fgPlatformPositionWindow( SFG_Window *window, int x, int y )
+void fgPlatformPositionWindow_X11( SFG_Window *window, int x, int y )
 {
     XMoveWindow( fgDisplay.pDisplay.Display, window->Window.Handle,
                  x, y );
@@ -572,7 +576,7 @@
 /*
  * Lowers the specified window (by Z order change)
  */
-void fgPlatformPushWindow( SFG_Window *window )
+void fgPlatformPushWindow_X11( SFG_Window *window )
 {
     XLowerWindow( fgDisplay.pDisplay.Display, window->Window.Handle );
 }
@@ -580,7 +584,7 @@
 /*
  * Raises the specified window (by Z order change)
  */
-void fgPlatformPopWindow( SFG_Window *window )
+void fgPlatformPopWindow_X11( SFG_Window *window )
 {
     XRaiseWindow( fgDisplay.pDisplay.Display, window->Window.Handle );
 }
@@ -588,7 +592,7 @@
 /*
  * Toggle the window's full screen state.
  */
-void fgPlatformFullScreenToggle( SFG_Window *win )
+void fgPlatformFullScreenToggle_X11( SFG_Window *win )
 {
     if(fghToggleFullscreen() != -1) {
         win->State.IsFullscreen = !win->State.IsFullscreen;
--- ./src/x11/fg_window_x11_glx.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/x11/fg_window_x11_glx.c	2023-09-17 21:49:58.336789999 +0200
@@ -29,6 +29,7 @@
 #define FREEGLUT_BUILDING_LIB
 #include <GL/freeglut.h>
 #include "fg_internal.h"
+#include "fg_private_x11.h"
 
 /* pushing attribute/value pairs into an array */
 #define ATTRIB(a) attributes[where++]=(a)
@@ -39,7 +40,7 @@
  */
 
 #ifdef USE_FBCONFIG
-int fghChooseConfig(GLXFBConfig* fbconfig)
+int fghChooseConfig_X11(GLXFBConfig* fbconfig)
 {
   GLboolean wantIndexedMode = GL_FALSE;
   int attributes[ 100 ];
@@ -201,7 +202,7 @@
 					       GLXContext share_list, Bool direct,
 					       const int *attrib_list);
 
-GLXContext fghCreateNewContext( SFG_Window* window )
+GLXContext fghCreateNewContext_X11( SFG_Window* window )
 {
   /* for color model calculation */
   int menu = ( window->IsMenu && !fgStructure.MenuContext );
@@ -217,8 +218,8 @@
 
   /* new context creation */
   int attributes[9];
-  CreateContextAttribsProc createContextAttribs = (CreateContextAttribsProc) fgPlatformGetProcAddress( "glXCreateContextAttribsARB" );
- 
+  CreateContextAttribsProc createContextAttribs = (CreateContextAttribsProc) fgPlatformGetProcAddress_X11( "glXCreateContextAttribsARB" );
+
   /* glXCreateContextAttribsARB not found, yet the user has requested the new context creation */
   if ( !createContextAttribs && !fghIsLegacyContextRequested(window) ) {
     fgWarning( "OpenGL >2.1 context requested but glXCreateContextAttribsARB is not available! Falling back to legacy context creation" );
@@ -252,7 +253,7 @@
 
 #else	/* !defined USE_FBCONFIG */
 
-int fghChooseConfig(XVisualInfo **vinf_ret)
+int fghChooseConfig_X11(XVisualInfo **vinf_ret)
 {
 	Display *dpy = fgDisplay.pDisplay.Display;
 	int scr = DefaultScreen(dpy);
@@ -324,7 +325,7 @@
 	return 0;
 }
 
-GLXContext fghCreateNewContext(SFG_Window* window)
+GLXContext fghCreateNewContext_X11(SFG_Window* window)
 {
 	Display *dpy = fgDisplay.pDisplay.Display;
 	XVisualInfo *vi = window->Window.pContext.visinf;
@@ -346,7 +347,7 @@
 }
 #endif	/* !defined USE_FBCONFIG */
 
-void fgPlatformSetWindow ( SFG_Window *window )
+void fgPlatformSetWindow_X11 ( SFG_Window *window )
 {
     if ( window )
     {
--- ./src/x11/fg_window_x11_glx.h.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/x11/fg_window_x11_glx.h	2023-09-17 21:47:47.419364001 +0200
@@ -32,10 +32,10 @@
 #include "fg_internal_x11_glx.h"
 
 #ifdef USE_FBCONFIG
-int fghChooseConfig(GLXFBConfig *fbconfig);
+int fghChooseConfig_X11(GLXFBConfig *fbconfig);
 #else
-int fghChooseConfig(XVisualInfo **vinf_ret);
+int fghChooseConfig_X11(XVisualInfo **vinf_ret);
 #endif
-GLXContext fghCreateNewContext(SFG_Window* window);
+GLXContext fghCreateNewContext_X11(SFG_Window* window);
 
 #endif
--- ./src/x11/fg_xinput_x11.c.orig	2022-10-07 18:12:51.000000000 +0200
+++ ./src/x11/fg_xinput_x11.c	2023-09-17 20:51:23.860429999 +0200
@@ -13,11 +13,13 @@
 #include <X11/Xlib.h>
 #include <X11/extensions/XInput2.h>
 
+#include "fg_private_x11.h"
+
 /* convert the XInput button state mask to the regular X mouse event button mask */
 #define BUTTON_MASK(xistate)	((xistate) << 8)
 
 /* import function from fg_main.c */
-extern int fgPlatformGetModifiers( int state );
+extern int fgPlatformGetModifiers_X11( int state );
 
 /* extension opcode for XInput */
 static int xi_opcode = -1;
@@ -157,9 +159,11 @@
 
         XIDeviceEvent* event = (XIDeviceEvent*)(cookie->data);
         XIEnterEvent *evcross;
-        /*printf("XI2 event type: %d - %d\n", cookie->evtype, event->type );*/
+        SFG_WindowHandleType handle;
 
-        SFG_Window* window = fgWindowByHandle( event->event );
+        /*printf("XI2 event type: %d - %d\n", cookie->evtype, event->type );*/
+        handle.ptr = (void*)event->event;
+        SFG_Window* window = fgWindowByHandle( handle );
         if (!window) return;
 
         switch (cookie->evtype) {
@@ -167,7 +171,7 @@
         case XI_Leave:
             evcross = (XIEnterEvent*)event;
 
-            fgState.Modifiers = fgPlatformGetModifiers( evcross->mods.base );
+            fgState.Modifiers = fgPlatformGetModifiers_X11( evcross->mods.base );
             INVOKE_WCB( *window, MultiEntry, (
                 event->deviceid,
                 (event->evtype == XI_Enter ? GLUT_ENTERED : GLUT_LEFT)
@@ -196,7 +200,7 @@
 
         case XI_ButtonPress:
         case XI_ButtonRelease:
-            fgState.Modifiers = fgPlatformGetModifiers( event->mods.base );
+            fgState.Modifiers = fgPlatformGetModifiers_X11( event->mods.base );
             INVOKE_WCB( *window, MultiButton, (
                 event->deviceid,
                 event->event_x,
@@ -221,7 +225,7 @@
             break;
 
         case XI_Motion:
-            fgState.Modifiers = fgPlatformGetModifiers( event->mods.base );
+            fgState.Modifiers = fgPlatformGetModifiers_X11( event->mods.base );
             for (i = 0; i < event->buttons.mask_len; i++) {
                 if (event->buttons.mask[i]) {
                     button = 1;
